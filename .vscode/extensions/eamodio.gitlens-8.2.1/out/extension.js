module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i.w={},i(i.s=9)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t,i){"use strict";var s,o;i.r(t),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const r=s.length;for(let a=0;a<r;a++)e(t,`${i}[${a}]`,s[a],o);0===r&&(t[i]=null)}else{let r=!0;for(const a in s)r=!1,e(t,i?`${i}.${a}`:a,s[a],o);r&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const r=t[o];"object"==typeof r?s.push(...e(r,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(s||(s={})),function(e){function t(e,i,o=!0){if(void 0===e.children)return e;const r=[...s.values(e.children)];for(const e of r)t(e,i,!1);if(!o&&1===r.length){const t=r[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.makeHierarchical=function(e,i,s,o=!1){const r={name:"",relativePath:"",children:Object.create(null),descendants:[]},a=e.reduce((e,t)=>{let o=e,r="";for(const e of i(t)){r=s(r,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:r,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},r);return o?t(a,s,!0):a},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(o||(o={}));var r=i(6);const a=i(8);a.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let r;return r="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+r:r+" ago":r}}}();const n={addSuffix:!0,locale:a};var h;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),r=s.getTime()-6e4*s.getTimezoneOffset(),a=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-a)/864e5)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(r.distanceInWordsToNow)(e,n),format:t=>Object(r.format)(e,t)}}}(h||(h={}));var c=i(3);const l=i(11),d=i(10);var m,u;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,r=c.__rest(s,["track"]);if(!0!==o)return l(e,t,r);let a=!1;const n=l(function(){return a=!1,e.apply(this,arguments)},t,i),h=function(){return a=!0,n.apply(this,arguments)};return h.pending=function(){return a},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return d(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(m||(m={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e){let t,i=0;for(;!(t=e.next()).done;)i++;return i},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(u||(u={}));class g{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}join(e){return e.join("")}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class p{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}join(e){return e.join("/")}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(t===p._fwd||t===p._bwd){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}p._fwd="/".charCodeAt(0),p._bwd="\\".charCodeAt(0);class f{isEmpty(){return void 0===this.left&&void 0===this.mid&&void 0===this.right&&void 0===this.element}}class v{constructor(e){this._iter=e}static forPaths(){return new v(new p)}static forStrings(){return new v(new g)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new f,this._root.str=i.value()),s=this._root;;){const e=i.cmp(s.str);if(e>0)s.left||(s.left=new f,s.left.str=i.value()),s=s.left;else if(e<0)s.right||(s.right=new f,s.right.str=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new f,s.mid.str=i.value()),s=s.mid}}const o=s.element;return s.element=t,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.element:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.element=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.element||i,s=s.mid}}return s&&s.element||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new v(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,[],e)}_forEach(e,t,i){void 0!==e&&(this._forEach(e.left,t,i),t.push(e.str),e.element&&i(e.element,this._iter.join(t)),this._forEach(e.mid,t,i),t.pop(),this._forEach(e.right,t,i))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(){return void 0===this._root||this._root.isEmpty()?0:u.count(this.entries())}entries(){return this._iterator(this._root,[])}values(){return u.map(this.entries(),e=>e[0])}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}*_iterator(e,t){void 0!==e&&(yield*this._iterator(e.left,t),t.push(e.str),e.element&&(yield[e.element,this._iter.join(t)]),yield*this._iterator(e.mid,t),t.pop(),yield*this._iterator(e.right,t))}}var w,C,b=i(5);!function(e){const t=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,i=/\$\{(\w*?)(?:\W|\d)*?\}/g;function s(e,t,i=" "){const s=t-h(e);return s<=0?e:i.repeat(s)+e}function o(e,t,i=" "){const s=t-h(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const i=[];let s=t.exec(e);for(;null!=s;){const o=s[2],r=s[3];i.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===r?"left":"right",collapseWhitespace:"?"===r}}),s=t.exec(e)}return i},e.interpolate=function(e,t){return e?void 0===t?e.replace(i,""):(e=e.replace(i,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(b.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(/\\/g,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=s,e.padLeftOrTruncate=function(e,t,i){const o=h(e);return o<t?s(e,t,i):o>t?a(e,t):e},e.padRight=o,e.padOrTruncate=function(e,t,i){const r=t<0;t=Math.abs(t);const n=h(e);return n<t?r?s(e,t,i):o(e,t,i):n>t?a(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=h(e);return s<t?o(e,t,i):s>t?a(e,t):e};const r=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function a(e,t,i="…"){if(!e)return e;const s=h(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),r=h(e.substring(0,o));for(;r<t;)r+=h(e[o++]);return r>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(r,t):e},e.sha1=function(e,t="base64"){return Object(b.createHash)("sha1").update(e).digest(t)},e.truncate=a;const n=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function h(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(n,"")];for(let e=0;e<o.length;e++){const r=o[e].codePointAt(0);if(!(r<=31||r>=127&&r<=159||r>=768&&r<=879))if(r>=128512&&r<=128591||r>=127744&&r<=128511||r>=128640&&r<=128767||r>=9728&&r<=9983||r>=9984&&r<=10175||r>=65024&&r<=65039||r>=129280&&r<=129535||r>=65024&&r<=65039||r>=8400&&r<=8447){if(r>=127995&&r<=127999)continue;i++,t+=2}else 8205!==r?(r>65535&&e++,t+=c(r)?2:1):(s++,t-=2)}const r=i-s;return r>1&&(t+=r-1),t}function c(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=h}(w||(w={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,r,a]=i.split(".");return t(o,r,a,s)}}(C||(C={}));var y,x,$,S,D,k,_,F,P,R,T,E,B,N,A=i(0);!function(e){e.File="file",e.Window="window"}(y||(y={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(x||(x={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}($||($={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(S||(S={})),function(e){e.Absolute="absolute",e.Relative="relative"}(D||(D={})),function(e){e.List="list",e.Tree="tree"}(k||(k={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(_||(_={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(F||(F={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(P||(P={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(R||(R={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(T||(T={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(E||(E={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(B||(B={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(N||(N={}));const U="gitlens",L="GitLens",O="GitLens",I="eamodio.gitlens",M=1e8;var W,H,j,G,V;function Q(e,t){return A.commands.executeCommand(W.SetContext,e,t)}function K(e){const t=A.window.activeTextEditor;return void 0!==t&&t.document===e}function z(e){const t=e.document.uri.scheme;return t!==j.Output&&t!==j.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(W||(W={})),function(e){e.ActiveHasRemote="gitlens:activeHasRemote",e.ActiveIsBlameable="gitlens:activeIsBlameable",e.ActiveFileIsTracked="gitlens:activeIsTracked",e.ActiveIsRevision="gitlens:activeIsRevision",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.HistoryExplorer="gitlens:historyExplorer",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(H||(H={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(j||(j={})),function(e){e.AngleBracketLeftHeavy="❰",e.AngleBracketRightHeavy="❱",e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowHeadRight="➤",e.ArrowLeft="←",e.ArrowLeftDouble="⇐",e.ArrowLeftRight="↔",e.ArrowLeftRightDouble="⇔",e.ArrowLeftRightDoubleStrike="⇎",e.ArrowLeftRightLong="⟷",e.ArrowRight="→",e.ArrowRightDouble="⇒",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.ArrowsHalfLeftRight="⇋",e.ArrowsHalfRightLeft="⇌",e.ArrowsLeftRight="⇆",e.ArrowsRightLeft="⇄",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.MuchGreaterThan="≪",e.MuchLessThan="⋘",e.Pencil="✎",e.Space=" ",e.SpaceThin=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(G||(G={})),(V||(V={})).GitLensVersion="gitlensVersion";const q=[".png",".gif",".jpg",".jpeg",".webp",".tif",".tiff",".bmp"];var Y;!function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(Y||(Y={}));class X{}const J=new class extends X{equals(e,t){return e===t}},Z=new class extends X{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?J.equals(e.document,t.document):e.id===t.id)}},ee=new class extends X{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var te,ie;!function(e){e.Computing="computing",e.Computed="computed"}(te||(te={}));class se extends A.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=se.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=A.Disposable.from(A.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(J.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=m.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=te.Computing,e===A.window.activeTextEditor&&await Q(H.AnnotationStatus,this.status),this.editor=e,this.correlationKey=se.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=te.Computed,e===A.window.activeTextEditor&&(await Q(H.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=te.Computing,await this.onProvideAnnotation(e)?(this.status=te.Computed,!0):(this.status=void 0,!1)}}function oe(e){switch(e.type){case ie.Branch:return"Branch";case ie.Branches:return"Branches";case ie.Commit:return"Commit";case ie.File:return"File";case ie.Repo:return"Repository";case ie.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(ie||(ie={}));class re{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return A.commands.executeCommand(W.Open,A.Uri.parse(e))}open(e){switch(e.type){case ie.Branch:return this.openBranch(e.branch);case ie.Branches:return this.openBranches();case ie.Commit:return this.openCommit(e.sha);case ie.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case ie.Repo:return this.openRepo();case ie.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}const ae=/(^|\s)(issue #([0-9]+))\b/gi,ne=/(^|\s)(pull request #([0-9]+))\b/gi;class he extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(ae,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ne,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const ce=/(^|\s)(issue #([0-9]+))\b/gi,le=/(^|\s)(pull request #([0-9]+))\b/gi;class de extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(ce,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(le,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class me extends re{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return w.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return w.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return w.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return w.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?w.interpolate(this.urls.fileLine,{line:s.start.line}):w.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?w.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?w.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):w.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const ue=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,ge=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class pe extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(ue,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ge,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const fe=/(^|\s)(#([0-9]+))\b/gi;class ve extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace(fe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const we=`[${L}]`;class Ce{static configure(e){e.subscriptions.push(ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}static onConfigurationChanged(e){const t=ir.initializing(e);let i=ir.name("debug").value;(t||ir.changed(e,i))&&(this.debug=ir.get(i)),i=ir.name("outputLevel").value,(t||ir.changed(e,i))&&(this.level=ir.get(i),this.level===B.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||A.window.createOutputChannel(L))}static log(e,...t){this.debug&&console.log(this.timestamp,we,e,...t),void 0===this.output||this.level!==B.Verbose&&this.level!==B.Debug||this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){this.debug&&console.error(this.timestamp,we,t,...i,e),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,t,...i,e]:[t,...i,e]).join(" "))}static warn(e,...t){this.debug&&console.warn(this.timestamp,we,e,...t),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t,i){this.level===B.Debug&&(void 0===this.gitOutput&&(this.gitOutput=A.window.createOutputChannel(`${L} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})${void 0===i?"":`\n\n${i.toString()}`}`))}}Ce.debug=!1,Ce.level=B.Silent;const be=/(^|\s)(#([0-9]+))\b/gi,ye=new Map([["bitbucket.org",(e,t)=>new he(e,t)],["github.com",(e,t)=>new pe(e,t)],["gitlab.com",(e,t)=>new ve(e,t)],["visualstudio.com",(e,t)=>new class extends re{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}enrichMessage(e){return e.replace(be,`$1[$2](${this.baseUrl}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class xe{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void Ce.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(ye);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case S.Bitbucket:return(t,i)=>new he(t,i,e.protocol,e.name,!0);case S.BitbucketServer:return(t,i)=>new de(t,i,e.protocol,e.name,!0);case S.Custom:return(t,i)=>new me(t,i,e.urls,e.protocol,e.name);case S.GitHub:return(t,i)=>new pe(t,i,e.protocol,e.name,!0);case S.GitLab:return(t,i)=>new ve(t,i,e.protocol,e.name,!0)}}}var $e=i(7),Se=i(2),De=i(1);const ke="win32"===process.platform;function _e(e){if(e.match(/[\\\/]/))return e;const t=De.join(".",e);try{if(Se.statSync(t))return t}catch(e){}const i=process.env.PATH.split(ke?";":":");for(const t of i){const i=De.join(t,e);try{if(Se.statSync(i))return i}catch(e){}}return e}function Fe(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:r}=s,a=c.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object($e.execFile)(e,t,a,(o,r,n)=>{if(!o)return n&&Ce.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(r);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${a.maxBuffer} bytes`)),Ce.warn(`Error(${a.cwd}): ${e} ${t.join(" ")})\n    (${o.code}) ${o.message}\n${n}`),s(o)});o&&n.stdin.end(o,r||"utf8")})}async function Pe(e){const t=await Fe(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!ke)return{cmd:_e(t),args:i};if(!Se.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=_e(`${t}${o}`);if(Se.existsSync(s))return e(s,i)}}return t.match(/\.ps1$/i)?{cmd:De.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)}:t.match(/\.(bat|cmd)$/i)?{cmd:De.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]}:t.match(/\.(js)$/i)?{cmd:process.execPath,args:[t].concat(i)}:{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function Re(e){return e?Pe(De.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}var Te=i(4);class Ee extends A.Uri{constructor(e,t){if(void 0===e)return void super();if(e.scheme===j.GitLensGit){const t=JSON.parse(e.query),[i,s]=Ee.ensureValidUNCPath(e.authority,De.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!Kt.isStagedUncommitted(t.sha)&&Kt.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Ee.ensureValidUNCPath(e.authority,De.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!Kt.isStagedUncommitted(t.sha)&&Kt.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&Kt.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?A.Uri.file(this.versionedPath):A.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getDirectory(e){return Ee.getDirectory(De.relative(this.repoPath||"",this.fsPath),e)}getFilename(e){return De.basename(De.relative(this.repoPath||"",this.fsPath),e)}getFormattedPath(e=w.pad(G.Dot,2,2),t){let i=De.dirname(this.fsPath);return this.repoPath&&(i=De.relative(this.repoPath,i)),void 0!==t&&(i=De.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?`${De.basename(this.fsPath)}${e}${i}`:De.basename(this.fsPath)}getRelativePath(e){let t=De.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=De.relative(e,t)),w.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Ee(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Ee(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=A.Uri.file(De.resolve(t,s&&e.originalFileName||e.fileName));return new Ee(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Ee(A.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Ee(e)}static async fromUri(e){if(e instanceof Ee)return e;if(!Zo.git.isTrackable(e))return new Ee(e);if(e.scheme===j.GitLensGit)return new Ee(e);if(e.scheme===j.Git){const t=JSON.parse(e.query),i=await Zo.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=Kt.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Ee(e,{fileName:t.path,repoPath:i,sha:s})}const t=await Zo.git.getVersionedUri(e);return void 0!==t?t:new Ee(e,await Zo.git.getRepoPath(e))}static getDirectory(e,t){let i=De.dirname(e);return void 0!==t&&(i=De.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=w.pad(G.Dot,2,2),i){let s;if(e instanceof A.Uri){if(e instanceof Ee)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Ee.getDirectory(s,i);return o?`${De.basename(s)}${t}${o}`:De.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof A.Uri){if(e instanceof Ee)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=De.relative(i||"",s);return void 0!==t&&(o=De.relative(t,o)),w.normalizePath(o)}static toKey(e){return w.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,r;"string"==typeof e?(s="string"==typeof t?t:De.resolve(i,t.fileName),o=e,r=Kt.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,r=e.shortSha);const a={fileName:w.normalizePath(De.relative(i,s)),repoPath:i,sha:o},n=De.parse(s);return A.Uri.parse(`${j.GitLensGit}:${De.join(n.dir,n.name)}:${r}${n.ext}?${JSON.stringify(a)}`)}}const Be=new Map;var Ne;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Ne||(Ne={}));const Ae={dateFormat:void 0,dateStyle:void 0,reset:()=>{Ae.dateStyle=ir.get(ir.name("defaultDateStyle").value),Ae.dateFormat=ir.get(ir.name("defaultDateFormat").value)}};class Ue{constructor(e,t,i,s,o,r,a,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=r,this.message=a,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Ae.dateStyle===D.Absolute?this.formatDate(Ae.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Tt.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Ne.Blame||this.type===Ne.File||this.type===Ne.StashFile}get isStash(){return this.type===Ne.Stash||this.type===Ne.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Tt.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Tt.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Tt.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Tt.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?A.Uri.file(De.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return A.Uri.file(De.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=w.pad(G.Dot,2,2)){return Ee.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Be.get(i);if(void 0!==s)return s;const o=(s=A.Uri.parse(`https://www.gravatar.com/avatar/${this.email?w.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Be.set(i,s),s}getShortMessage(e=`${G.Space}${G.Ellipsis}`){const t=this.message.indexOf("\n");return-1===t?this.message:`${this.message.substring(0,t)}${e}`}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await Zo.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Ee.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Le extends Ue{constructor(e,t,i,s,o,r,a,n,h,c,l){super(Ne.Blame,e,t,i,s,o,r,a,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Le(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Oe{constructor(e,t,i=!1,s,o=0,r=0){this.repoPath=e,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.current=i,this.name=t,this.tracking=""===s||null==s?void 0:s,this.state={ahead:o,behind:r}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Oe.getRemote(this.name):void 0!==this.tracking?Oe.getRemote(this.tracking):void 0}getTrackingStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.tracking||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${G.ArrowDown}${e.separator}${this.state.ahead}${G.ArrowUp}`}isValid(){return Oe.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Ie=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Me=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,We=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class He{static parse(e,t=!1){if(!e)return;const i=[];let s,o,r,a=null;do{if(null==(a=We.exec(`${e}\n@@`)))break;s=(" "+a[5]).substr(1),o=parseInt(a[3],10),r=parseInt(a[1],10),i.push(new je(s,{start:o,end:o+parseInt(a[4],10)},{start:r,end:r+parseInt(a[2],10)}))}while(null!=a);return i.length?{diff:t?e:void 0,chunks:i}:void 0}static parseChunk(e){const t=u.skip(w.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const r=[];let a=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))a={line:n.line,state:n.state,previous:[s[e]]},r.push(a);else{if(void 0===a)continue;if(void 0===a.previous){a.previous=[s[e]];continue}a.previous.push(s[e])}return r}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Ie.exec(e)))break;i.push(bt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Me.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class je{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=He.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class Ge extends Ue{constructor(e,t,i,s,o,r,a,n,h,c,l,d,m,u){super(e,t,i,s,o,r,a,n,l,d,m),this.fileStatuses=h,this.status=c,this.parentShas=u}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Tt.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?A.Uri.file(De.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=w.normalizePath(De.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Ne.StashFile:Ne.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new Ge(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ve,Qe,Ke;!function(e){e.Fetch="fetch",e.Push="push"}(Ve||(Ve={}));class ze{constructor(e,t,i,s,o,r){this.repoPath=e,this.name=t,this.domain=i,this.path=s,this.provider=o,this.types=r}}!function(e){e.Config="config",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(Qe||(Qe={}));class qe{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}(Ke||(Ke={})).StatusNode="statusNode";class Ye extends A.Disposable{constructor(e,t,i,s,o){super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new A.EventEmitter,this._onDidChangeFileSystem=new A.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this.formattedName=i?e.name:`${e.name} (${De.relative(e.uri.fsPath,t)})`,this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o;const r=A.workspace.createFileSystemWatcher(new A.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=A.Disposable.from(r,r.onDidChange(this.onRepositoryChanged,this),r.onDidCreate(this.onRepositoryChanged,this),r.onDidDelete(this.onRepositoryChanged,this),ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ir.initializing(e),i=ir.name("remotes").value;(t||ir.changed(e,i,this.folder.uri))&&(this._providerMap=xe.createMap(ir.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(Qe.Remotes)))}onFileSystemChanged(e){/\.git(?:\/|\\|$)/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(Qe.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(Qe.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(Qe.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(Qe.Config,Qe.Remotes);this.onAnyRepositoryChanged(this),this.fireChange(Qe.Repository)}}}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=m.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new qe(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=m.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}containsUri(e){return e instanceof Ee&&(e=void 0!==e.repoPath?A.Uri.file(e.repoPath):e.fileUri()),this.folder===A.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=Zo.git.getBranch(this.path)),this._branch}getBranches(){return Zo.git.getBranches(this.path)}getChangedFilesCount(e){return Zo.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=ir.get(ir.name("remotes").value,this.folder.uri);this._providerMap=xe.createMap(e)}this._remotes=Zo.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return Zo.git.getStashList(this.path)}getStatus(){return Zo.git.getStatusForRepo(this.path)}getTags(){return Zo.git.getTags(this.path)}async hasRemote(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=A.workspace.createFileSystemWatcher(new A.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=A.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}}class Xe extends Ge{constructor(e,t,i,s,o,r,a,n,h,c,l,d){super(e,i,s,"You",void 0,o,r,a,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new Xe(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class Je{constructor(e,t,i,s,o,r){this.repoPath=e,this.branch=t,this.sha=i,this.files=s,this.state=o,this.upstream=r}getDiffStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),0===this.files.length)return e.empty;if(void 0===this._diff){this._diff={added:0,deleted:0,changed:0};for(const e of this.files)switch(e.status){case"A":case"?":this._diff.added++;break;case"D":this._diff.deleted++;break;default:this._diff.changed++}}if(e.expand){let t="";return this._diff.added&&(t+=`${this._diff.added} ${1===this._diff.added?"file":"files"} added`),this._diff.changed&&(t+=`${""===t?"":e.separator}${this._diff.changed} ${1===this._diff.changed?"file":"files"} changed`),this._diff.deleted&&(t+=`${""===t?"":e.separator}${this._diff.deleted} ${1===this._diff.deleted?"file":"files"} deleted`),`${e.prefix}${t}`}return`${e.prefix}+${this._diff.added}${e.separator}~${this._diff.changed}${e.separator}-${this._diff.deleted}`}getUpstreamStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.upstream||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${G.ArrowDown}${e.separator}${this.state.ahead}${G.ArrowUp}`}}class Ze{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return A.Uri.file(De.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return Ze.getFormattedDirectory(this,e)}getFormattedPath(e=w.pad(G.Dot,2,2)){return Ze.getFormattedPath(this,e)}getOcticon(){return tt(this.status)}getStatusText(e){return Ze.getStatusText(this.status)}with(e){return new Ze(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Ee.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${w.pad(G.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=w.pad(G.Dot,2,2),i){return Ee.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Ee.getRelativePath(e.fileName,t)}static getStatusText(e){return function(e){return ot[e]||ot.X}(e)}}const et={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function tt(e,t=G.Space.repeat(4)){return et[e]||t}const it={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function st(e){return it[e]||it.X}const ot={"!":"ignored","?":"untracked",A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"modified",U:"conflict",X:"unknown",B:"unknown"};class rt{constructor(e,t){this.repoPath=e,this.name=t}}class at{static parse(e,t,i){if(!e)return;const s=new Map,o=new Map,r=[];let a,n,h=t&&i,c=void 0,l=!0;for(a of w.lines(e))if(!((n=a.split(" ")).length<2))if(void 0!==c)switch(n[0]){case"author":c.author=Tt.isUncommitted(c.sha)?"You":n.slice(1).join(" ").trim();break;case"author-mail":c.authorEmail=n.slice(1).join(" ").trim();const e=c.authorEmail.indexOf("<");if(e>=0){const t=c.authorEmail.indexOf(">",e);c.authorEmail=t>e?c.authorEmail.substring(e+1,t):c.authorEmail.substring(e+1)}break;case"author-time":c.authorDate=n[1];break;case"author-tz":c.authorTimeZone=n[1];break;case"summary":c.summary=n.slice(1).join(" ").trim();break;case"previous":c.previousSha=n[1],c.previousFileName=n.slice(2).join(" ");break;case"filename":c.fileName=n.slice(1).join(" "),l&&void 0===t&&(t=w.normalizePath(i.replace(i.startsWith("/")?`/${c.fileName}`:c.fileName,"")),h=w.normalizePath(De.relative(t,i))),l=!1,at.parseEntry(c,t,h,o,s,r),c=void 0}else c={sha:n[0],originalLine:parseInt(n[1],10)-1,line:parseInt(n[2],10)-1,lineCount:parseInt(n[3],10)};return o.forEach(e=>{if(void 0===e.author)return;const t=s.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...s.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:o,lines:r}}static parseEntry(e,t,i,s,o,r){let a=s.get(e.sha);if(void 0===a){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}a=new Le(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,a)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};a.previousSha&&(i.previousSha=a.previousSha),a.lines.push(i),r[i.line]=i}}}const nt=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,ht=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class ct{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=nt.exec(e)))break;const[o,r]=this.parseState(s[5]);i.push(new Oe(t,s[2],"*"===s[1],s[4],o,r))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=ht.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const lt=/diff --git a\/(.*) b\/(.*)/,dt={};class mt{static parse(e,t,i,s,r,a,n,h){if(!e)return;let c,l,d=void 0,m=dt,u=void 0,g=0,p=!0;const f=w.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=w.normalizePath(i));const C=new Map,b=new Map;for(;!((v=f.next()).done||(u=v.value,n&&a&&g>=a));)switch(l=u.charCodeAt(1)){case 114:m={ref:u.substring(4)};break;case 97:m.author=Tt.isUncommitted(m.ref)?"You":u.substring(4);break;case 101:m.email=u.substring(4);break;case 100:m.date=u.substring(4);break;case 112:m.parentShas=u.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(u=v.value);)void 0===m.summary?m.summary=u:m.summary+=`\n${u}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(u=v.value);)if(!u.startsWith("warning:"))if(t===Ne.Branch){const e={status:u[0],fileName:u.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(u.startsWith("diff")){const e=lt.exec(u);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}m.status=u[0],m.fileName=u.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=o.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Ne.File&&void 0!==s?(i=w.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),c=w.normalizePath(De.relative(i,s))):c=m.fileName,p=!1;const e=b.get(m.ref);void 0===e&&g++,d=mt.parseEntry(m,e,t,i,c,b,C,d)}return{repoPath:i,authors:C,commits:b,sha:r,count:g,maxCount:a,range:h,truncated:!!(a&&g>=a&&1!==a)}}static parseEntry(e,t,i,s,o,r,a,n){if(void 0===t){if(void 0!==e.author){let t=a.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},a.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Ne.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new Ge(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),r.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Ne.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const ut=/^(.*)\t(.*)\s\((.*)\)$/gm,gt=/^(?:git:\/\/(.*?)\/|https:\/\/(.*?)\/|http:\/\/(.*?)\/|git@(.*):|ssh:\/\/(?:.*@)?(.*?)(?::.*?)?\/)(.*)$/;class pt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let r=null;do{if(null==(r=ut.exec(e)))break;const a=r[2],[n,h]=this.parseGitUrl(a),c=`${n}/${h}`;let l=o[c];void 0===l?(l=new ze(t,r[1],n,h,i(n,h),[{url:a,type:r[3]}]),s.push(l),o[c]=l):l.types.push({url:a,type:r[3]})}while(null!=r);return s.length?s:[]}static parseGitUrl(e){const t=gt.exec(e);return null==t?["",""]:[t[1]||t[2]||t[3]||t[4]||t[5],t[6].replace(/\.git\/?$/,"")]}}const ft={};class vt{static parse(e,t){if(!e)return;const i=w.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=w.normalizePath(t));const r=new Map;let a,n=ft,h=void 0;for(;!(s=i.next()).done;)switch(a=(h=s.value).charCodeAt(1)){case 114:n={ref:h.substring(4)};break;case 100:n.date=h.substring(4);break;case 108:n.stashName=h.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(h=s.value);)void 0===n.summary?n.summary=h:n.summary+=`\n${h}`;void 0!==n.summary&&(n.summary=n.summary.slice(0,-1));break;case 102:if(!(s=i.next()).done&&"</f>"!==s.value){for(;!(s=i.next()).done&&"</f>"!==(h=s.value);){if(h.startsWith("warning:"))continue;const e={status:h[0],fileName:h.substring(1),originalFileName:void 0};mt.parseFileName(e),e.fileName&&(void 0===n.fileStatuses&&(n.fileStatuses=[]),n.fileStatuses.push(e))}void 0!==n.fileStatuses&&(n.fileNames=o.filterMap(n.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "))}let e=r.get(n.ref);e=vt.parseEntry(n,e,t,r)}return{repoPath:t,commits:r}}static parseEntry(e,t,i,s){return void 0===t&&(t=new Xe(Ne.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const wt=/(?:ahead ([0-9]+))/,Ct=/(?:behind ([0-9]+))/;class bt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let r,a=-1;for(;++a<e.length;){const n=e[a];if(n.startsWith("##")){const e=n.split(" ");if([i,r]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=wt.exec(t);o.ahead=null==i?0:+i[1]||0;const s=Ct.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,r]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,r.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return new Je(w.normalizePath(t),i||"","",s,o,r)}static parseV2(e,t){let i;const s=[];let o;const r={ahead:0,behind:0};let a,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":a=e[2];break;case"branch.ab":r.ahead=+e[2].substring(1),r.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return new Je(w.normalizePath(t),i||"",o||"",s,r,a)}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let r=void 0;return t.length>1&&(""!==(r="."!==t[1]?t[1].trim():void 0)&&null!==r||(r=void 0)),new Ze(e,o,r,i,s)}}class yt{static parse(e,t){if(!e)return;const i=o.filterMap(e.split("\n"),e=>e?new rt(t,e):void 0);return i.length?i:void 0}}let xt;const $t=["blame","--root","--incremental"],St=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],Dt=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],kt={notARepository:/Not a git repository/,outsideRepository:/is outside repository/,noPath:/no such path/,noCommits:/does not have any commits/,notFound:/Path \'.*?\' does not exist in/,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/,headNotABranch:/HEAD does not point to a branch/,noUpstream:/no upstream configured for branch \'(.*?)\'/,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree/};async function _t(e,...t){try{return await Pt(e,...t)}catch(i){return Rt(i,e,...t)}}const Ft=new Map;async function Pt(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=c.__rest(e,["correlationKey"]),r=e.encoding||"utf8",a=Object.assign({},o,{encoding:"utf8"===r?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,h=`(${a.cwd}${void 0!==s?s:""}): ${n}`;let l,d,m=Ft.get(h);void 0===m?(Ce.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),m=Fe(xt.path,t,a),Ft.set(h,m)):Ce.log(`Awaiting${h}`);try{l=await m}catch(e){throw d=e,e}finally{Ft.delete(h);const e=process.hrtime(i),t=`${void 0===d?"Completed":"FAILED"} in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;Ce.log(`${void 0===d?"Completed":"FAILED"}${h} ${t}`),Ce.logGitCommand(`${n} ${t}`,a.cwd,d)}return"utf8"===r||"binary"===r?l:Te.decode(Buffer.from(l,"binary"),r)}function Rt(e,t,...i){const o=e&&e.toString();if(o)for(const e of s.values(kt))if(e.test(o))return Ce.warn("git",...i,`  cwd='${t.cwd}'\n\n  `,o.replace(/\r?\n|\r/g," ")),"";throw Ce.error(e,"git",...i,`  cwd='${t.cwd}'\n\n  `),e}class Tt{static gitInfo(){return xt}static getEncoding(e){return void 0!==e&&Te.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();xt=await async function(e){try{return await Pe(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await Fe("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return Pe(e);try{return await Fe("xcode-select",["-p"]),Pe(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):Pe(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await Re(process.env.ProgramW6432).then(null,()=>Re(process.env["ProgramFiles(x86)"])).then(null,()=>Re(process.env.ProgramFiles)).then(null,()=>Pe("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}(e);const i=process.hrtime(t);return Ce.log(`Git found: ${xt.version} @ ${"git"===xt.path?"PATH":xt.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),xt}static async getVersionedFile(e,t,s){const o=await Tt.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Tt.isStagedUncommitted(s)&&(s="");const r=w.truncate(w.sanitizeForFileSystem(Tt.isSha(s)?Tt.shortenSha(s):s),50,""),a=De.extname(t),n=await Promise.resolve().then(function(){var e=i(13);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});return new Promise((i,h)=>{n.file({prefix:`${De.basename(t,a)}-${r}__`,postfix:a},(r,a,n,c)=>{r?h(r):(Ce.log(`getVersionedFile[${a}]('${e}', '${t}', ${s})`),Se.appendFile(a,o,{encoding:"binary"},e=>{e?h(e):Se.chmod(a,33060,e=>{i(a)})}))})})}static isResolveRequired(e){return Tt.isSha(e)&&!Tt.shaStrictRegex.test(e)}static isSha(e){return Tt.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Tt.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Tt.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"working",working:""},t),""===e)return t.working;if(Tt.isStagedUncommitted(e))return t.stagedUncommitted;if(Tt.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=w.normalizePath(e);const i=((t=w.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=w.normalizePath(i?De.dirname(e):t),e=w.normalizePath(i?De.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=xt.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e),a=[...$t];let n;return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),i&&(Tt.isStagedUncommitted(i)?(a.push("--contents","-"),n=await Tt.show(e,t,":")):a.push(i)),_t({cwd:r,stdin:n},...a,"--",o)}static async blame_contents(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e),a=[...$t];return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),a.push("--contents","-"),_t({cwd:r,stdin:i,correlationKey:s.correlationKey},...a,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),_t({cwd:e},...i)}static checkout(e,t,i){const[s,o]=Tt.splitPath(t,e);return _t({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await Pt({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const r=["diff","--diff-filter=M","-M","--no-ext-diff"];return i&&r.push(Tt.isStagedUncommitted(i)?"--staged":i),s&&r.push(Tt.isStagedUncommitted(s)?"--staged":s),_t({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...r,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),_t({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),_t({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),_t({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),_t({cwd:e},...o)}static log(e,t){const i=[...St,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Tt.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),_t({cwd:e},...i)}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Tt.splitPath(t,e),r=[...St];return i.maxCount&&!i.reverse&&r.push(`-n${i.maxCount}`),i.renames&&r.push("--follow","-m","--first-parent"),i.ref&&!Tt.isStagedUncommitted(i.ref)&&(i.reverse?r.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):r.push(i.ref)),null!=i.startLine&&null!=i.endLine&&r.push(`-L ${i.startLine},${i.endLine}:${s}`),r.push("--",s),_t({cwd:o},...r)}static async log_recent(e,t){try{return(await Pt({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await Pt({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...St,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),_t({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Tt.isStagedUncommitted(t.ref)&&i.push(t.ref),_t({cwd:e},...i)}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Tt.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await Pt({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),_t({cwd:e},...o,t,i)}static remote(e){return _t({cwd:e},"remote","-v")}static remote_url(e,t){return _t({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await Pt({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await Pt(i,...t)}catch(e){const s=e&&e.toString();if(kt.headNotABranch.test(s))return;const o=kt.noUpstream.exec(s);if(null!==o)return o[1];if(kt.unknownRevision.test(s))try{const t=["symbolic-ref","-q","--short","HEAD"];return await Pt(i,...t)}catch(e){return}return Rt(e,i,...t)}}static async revparse_toplevel(e){try{return(await Pt({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e);if(Tt.isStagedUncommitted(i)&&(i=":"),Tt.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const a={cwd:r,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await Pt(a,"show",n)}catch(e){const t=e&&e.toString();if(kt.notFound.test(t)||kt.foundButNotInRevision.test(t))return;return Rt(e,a,n)}}static stash_apply(e,t,i){if(t)return _t({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return _t({cwd:e},"stash","drop",t)}static stash_list(e){return _t({cwd:e},...Dt)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),_t({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),_t({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return _t({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Tt.splitPath(t,e),r=i>=2?`--porcelain=v${i}`:"--porcelain";return _t({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",r,s)}static tag(e){return _t({cwd:e},...["tag","-l"])}}Tt.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Tt.shaStrictRegex=/^[0-9a-f]{40}$/,Tt.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Tt.stagedUncommittedSha="0000000000000000000000000000000000000000:",Tt.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Tt.uncommittedSha="0000000000000000000000000000000000000000";class Et extends A.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new A.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===Zo.git&&!await m.waitUntil(()=>void 0!==Zo.git,2e3))throw Ce.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Ee.fromUri(e),this._disposed)return;const t=await Zo.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(Qe.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){Q(H.ActiveIsRevision,this.isRevision),Q(H.ActiveFileIsTracked,this.isTracked),Q(H.ActiveIsBlameable,this.isBlameable),Q(H.ActiveHasRemote,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,Ce.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&K(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=A.window.activeTextEditor;return void 0!==t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await Zo.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&void 0===(s=e.repo)&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemote(),void 0!==t){const s=this.isBlameable;if(Q(H.ActiveIsRevision,this.isRevision),Q(H.ActiveFileIsTracked,this.isTracked),Q(H.ActiveIsBlameable,s),Q(H.ActiveHasRemote,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class Bt extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new A.EventEmitter,this._onDidChangeDirtyState=new A.EventEmitter,this._onDidTriggerDirtyIdle=new A.EventEmitter,this._documentMap=new Map,this._disposable=A.Disposable.from(ir.onDidChange(this.onConfigurationChanged,this),A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,0),this),A.workspace.onDidChangeTextDocument(m.debounce(this.onTextDocumentChanged,50),this),A.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),A.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(A.window.activeTextEditor)}onConfigurationChanged(e){const t=ir.initializing(e);if(!t&&(ir.changed(e,ir.name("blame")("ignoreWhitespace").value,null)||ir.changed(e,ir.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=ir.name("advanced")("blame")("delayAfterEdit").value;(t||ir.changed(e,i))&&(this._dirtyIdleTriggerDelay=ir.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!z(e))return;if(void 0===e)return Q(H.ActiveIsRevision,!1),Q(H.ActiveFileIsTracked,!1),Q(H.ActiveIsBlameable,!1),void Q(H.ActiveHasRemote,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==j.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=A.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?K(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof A.Uri)&&(e=Ee.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Ee)try{e=await A.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){const i=t.toString();if(i.includes("File seems to be binary and cannot be opened as text"))e=new At(e);else{if(!i.includes("File not found"))throw t;e=new Ut(e)}}else e instanceof A.Uri&&(e=await A.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Ee?e=Ee.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof A.Uri)&&(e=Ee.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Ee.toKey(e.uri),i=new Et(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),A.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=m.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=m.debounce(async e=>{A.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class Nt{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=A.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}class At extends Nt{}class Ut extends Nt{}class Lt{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class Ot extends Bt{}class It{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=w.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:w.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?w.padLeft(e,i):(t.collapseWhitespace&&(i-=o),w.padRight(e,i))):o<0?w.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof It)return w.interpolate(t,e);let o=void 0;return o=null==s||"string"==typeof s?{dateFormat:s,tokenOptions:w.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}:s,void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),w.interpolate(t,this._formatter)}}It._formatter=void 0;class Mt extends It{get _ago(){return this._item.fromNow()}get _date(){return this._item.formatDate(this._options.dateFormat)}get _agoOrDate(){return(void 0!==this._options.dateStyle?this._options.dateStyle:Zo.config.defaultDateStyle)===D.Absolute?this._date:this._ago}get ago(){return this._padOrTruncate(this._ago,this._options.tokenOptions.ago)}get agoOrDate(){return this._padOrTruncate(this._agoOrDate,this._options.tokenOptions.agoOrDate)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._ago}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get authorAgoOrDate(){const e=`${this._item.author}, ${this._agoOrDate}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){return this._padOrTruncate(this._date,this._options.tokenOptions.date)}get id(){return this._item.shortSha}get message(){let e;return e=this._item.isStagedUncommitted?"Staged changes":this._item.isUncommitted?"Uncommitted changes":this._options.truncateMessageAtNewLine?this._item.getShortMessage():this._item.message,this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Wt extends It{get directory(){const e=Ze.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=De.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=Ze.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=Ze.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.path)}get status(){const e=Ze.getStatusText(this._item.status);return this._padOrTruncate(e,this._options.tokenOptions.status)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${G.Pencil} ${G.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Ht,jt,Gt,Vt,Qt;!function(e){e.Author="author",e.ChangedOccurrences="changed-occurrences",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Ht||(Ht={}));class Kt extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new A.EventEmitter,this._suspended=!1,this._repositoryTree=v.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=A.Disposable.from(A.window.onDidChangeWindowState(this.onWindowStateChanged,this),A.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return Zo.config.advanced.caching.enabled}onAnyRepositoryChanged(e){this._trackedCache.clear()}onConfigurationChanged(e){(ir.initializing(e)||ir.changed(e,ir.name("defaultDateStyle").value)||ir.changed(e,ir.name("defaultDateFormat").value))&&Ae.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:A.workspace.workspaceFolders||[],removed:[]},Ce.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==j.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==j.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...u.map(i.entries(),([t,i])=>[t,De.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=ir.get(ir.name("advanced")("repositorySearchDepth").value,t);Ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),r=[],a=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(Ce.log(`Repository found in '${n}'`),r.push(new Ye(e,n,!0,a,this._suspended))),i<=0){const e=process.hrtime(o);return Ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),r}let h=Object.assign({},A.workspace.getConfiguration("files",t).get("exclude",{}),A.workspace.getConfiguration("search",t).get("exclude",{}));h=[...u.filterMap(s.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const c=await this.repositorySearchCore(t.fsPath,i,h);for(let t of c){if(t=De.dirname(t),w.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(Ce.log(`Repository found in '${i}'`),r.push(new Ye(e,i,!1,a,this._suspended)))}const l=process.hrtime(o);return Ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*l[0]+Math.floor(l[1]/1e6)} ms`),r}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,r)=>{Se.readdir(e,async(a,n)=>{if(null!=a)return void r(a);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=De.resolve(e,t);return new Promise((e,r)=>{Se.stat(o,(r,a)=>{".git"===t?s.push(o):null==r&&!0!==i[t]&&null!=a&&a.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await Q(H.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await Q(H.HasRemotes,i),!t){const e=A.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=A.Disposable.from(e,e.onDidCreate(async e=>{const i=A.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,Ce.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Tt.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>Se.exists(De.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&u.first(s.commits.values());if(o)return o;const r=await this.findNextFileName(e,t,i);return r&&(o=(s=await this.getLogForFile(e,r,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&u.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Tt.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=u.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Tt.splitPath(s,t)):s=w.normalizePath(De.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){if(void 0===e){const e=this.getHighlanderRepoPath();if(void 0!==e)return e}if(void 0===(e=e||A.window.activeTextEditor))return;const t=await Zo.tracker.getOrAdd(e.document.uri);return void 0!==t?t.uri.repoPath:void 0}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await Zo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return Ce.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}Ce.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new Lt(i.key))}else Ce.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(Ce.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return Ce.log(`Skipping blame; '${e.fsPath}' is not tracked`),Kt.emptyPromise;const[s,o]=Tt.splitPath(e.fsPath,e.repoPath,!1);try{const r=await Tt.blame(o,s,e.sha,{ignoreWhitespace:Zo.config.blame.ignoreWhitespace});return at.parse(r,o,s)}catch(e){if(void 0!==t.state){const s=e&&e.toString();return Ce.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:Kt.emptyPromise,errorMessage:s}),t.setBlameFailure(),Kt.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${w.sha1(t)}`,s=await Zo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return Ce.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}Ce.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new Lt(s.key))}else Ce.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(Ce.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return Ce.log(`Skipping blame; '${e.fsPath}' is not tracked`),Kt.emptyPromise;const[o,r]=Tt.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Tt.blame_contents(r,o,t,{correlationKey:`:${s}`,ignoreWhitespace:Zo.config.blame.ignoreWhitespace});return at.parse(a,r,o)}catch(e){if(void 0!==i.state){const t=e&&e.toString();return Ce.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:Kt.emptyPromise,errorMessage:t}),i.setBlameFailure(),Kt.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(Ce.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Tt.blame(e.repoPath,o,e.sha,{ignoreWhitespace:Zo.config.blame.ignoreWhitespace,startLine:s,endLine:s}),r=at.parse(i,e.repoPath,o);if(void 0===r)return;return{author:u.first(r.authors.values()),commit:u.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(Ce.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const r=s.commits.get(o.sha);if(void 0===r)return;return{author:Object.assign({},s.authors.get(r.author),{lineCount:r.lines.length}),commit:r,line:o}}const o=t+1,r=e.fsPath;try{const s=await Tt.blame_contents(e.repoPath,r,i,{ignoreWhitespace:Zo.config.blame.ignoreWhitespace,startLine:o,endLine:o}),a=at.parse(s,e.repoPath,r);if(void 0===a)return;return{author:u.first(a.authors.values()),commit:u.first(a.commits.values()),line:a.lines[t]}}catch(e){return}}async getBlameForRange(e,t){Ce.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(Ce.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),r=new Map,a=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});a.set(t.sha,e);let s=r.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},r.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...r.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;Ce.log(`getBranch('${e}')`);const t=await Tt.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Oe(e,i[0],!0,i[1])}async getBranches(e){if(void 0===e)return[];Ce.log(`getBranches('${e}')`);const t=await Tt.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return ct.parse(t,e)||[]}async getChangedFilesCount(e,t){Ce.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Tt.diff_shortstat(e,t);return He.parseShortStat(i)}async getConfig(e,t){return Ce.log(`getConfig('${e}', '${t}')`),await Tt.config_get(e,t)}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await Zo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return Ce.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),r.item}Ce.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new Lt(o.key))}else Ce.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const r=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:Kt.getEncoding(e)},o,s);return void 0!==o.state&&(Ce.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getDiffForFileCore(e,t,i,s,o,r,a){const[n,h]=Tt.splitPath(t,e,!1);try{const t=await Tt.diff(h,n,i,s,o);return He.parse(t)}catch(e){if(void 0!==r.state){const t=e&&e.toString();return Ce.log(`Replace diff cache with empty promise for '${r.state.key}:${a}'`),r.state.set(a,{item:Kt.emptyPromise,errorMessage:t}),Kt.emptyPromise}return}}async getDiffForLine(e,t,i,s){Ce.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const r=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===r)return;return r.lines[t-r.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){Ce.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Tt.diff_nameStatus(e,t,i,s);return He.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Tt.log_recent(e,t)}async getLogCommit(e,t){Ce.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){Ce.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Tt.isResolveRequired(i.ref)?o||u.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),Ce.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?Zo.config.advanced.maxListItems||0:t.maxCount;try{const s=await Tt.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=mt.parse(s,Ne.Branch,e,void 0,t.ref,i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){Ce.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?Zo.config.advanced.maxListItems||0:s.maxCount,r=void 0;switch(i){case Ht.Author:r=[`--author=${t}`];break;case Ht.ChangedOccurrences:r=[`-S${t}`,"--pickaxe-regex"];break;case Ht.Changes:r=[`-G${t}`];break;case Ht.Files:r=["--",`${t}`];break;case Ht.Message:r=[`--grep=${t}`];break;case Ht.Sha:r=[t],o=1}try{const a=await Tt.log_search(e,r,{maxCount:o}),n=mt.parse(a,Ne.Branch,e,void 0,void 0,o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===w.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=Zo.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await Zo.tracker.getOrAdd(new Ee(A.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return Ce.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;if("log"!==s){const r=o.state.get("log");if(void 0!==r){if(void 0===i.ref)return Ce.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;Ce.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await r.item;if(void 0!==o&&o.commits.has(i.ref))return Ce.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item}}}Ce.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new Lt(o.key))}else Ce.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(Ce.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return Ce.log(`Skipping log; '${t}' is not tracked`),Kt.emptyPromise;const[r,a]=Tt.splitPath(t,e,!1);try{const{range:n}=i,h=c.__rest(i,["range"]),l=null==i.maxCount?Zo.config.advanced.maxListItems||0:i.maxCount,d=await Tt.log_file(a,r,Object.assign({},h,{maxCount:l,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),m=mt.parse(d,Ne.File,a,r,h.ref,l,h.reverse,n);if(void 0!==m){const s=Object.assign({},i);m.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return m}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return Ce.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:Kt.emptyPromise,errorMessage:t}),Kt.emptyPromise}return}}async hasRemote(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemote()}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async getMergeBase(e,t,i,s={}){try{const o=await Tt.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void Ce.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];Ce.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];Ce.log(`getRemotesCore('${e}')`),t=t||xe.createMap(ir.get(ir.name("remotes").value,null));try{const i=await Tt.remote(e);return pt.parse(i,e,xe.factory(t))}catch(e){return Ce.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(void 0===e)return await this.getActiveRepoPath();if(e instanceof Ee)return e.repoPath;const i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await Zo.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s),r=void 0===o?A.workspace.getWorkspaceFolder(A.Uri.file(s)):o.folder;if(void 0!==r){const e=new Ye(r,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended);this._repositoryTree.set(s,e),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}return s}async getRepoPathCore(e,t){try{return await Tt.revparse_toplevel(t?e:De.dirname(e))}catch(e){return void Ce.error(e,"GitService.getRepoPathCore")}}async getRepositories(){return(await this.getRepositoryTree()).values()}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Ee){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;Ce.log(`getStashList('${e}')`);const t=await Tt.stash_list(e);return vt.parse(t,e)}async getStatusForFile(e,t){Ce.log(`getStatusForFile('${e}', '${t}')`);const i=Tt.validateVersion(2,11)?2:1,s=await Tt.status_file(e,t,i),o=bt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;Ce.log(`getStatusForRepo('${e}')`);const t=Tt.validateVersion(2,11)?2:1,i=await Tt.status(e,t);return bt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];Ce.log(`getTags('${e}')`);const t=await Tt.tag(e);return yt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(Ce.log(`getVersionedFile('${e}', '${t}', '${i}')`),!i||Tt.isUncommitted(i)&&!Tt.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await Tt.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Ee.toKey(s),new Ee(A.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return Ce.log(`getVersionedFileText('${e}', '${t}', ${i})`),Tt.show(e,t,i,{encoding:Kt.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Ee.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===j.File||t===j.Git||t===j.GitLensGit}async isTracked(e,t,i={}){if(i.ref===Kt.deletedSha)return!1;let s,o,r=i.ref;if("string"==typeof e)[o,t]=Tt.splitPath(e,t),s=Ee.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,r=e.sha,s=Ee.toKey(o)}void 0!==r&&(s+=`:${r}`),Ce.log(`isTracked('${o}', '${t}', '${r}')`);let a=this._trackedCache.get(s);return void 0!==a?await a:(a=this.isTrackedCore(o,void 0===t?"":t,r),i.skipCacheUpdate?a:(this._trackedCache.set(s,a),a=await a,this._trackedCache.set(s,a),a))}async isTrackedCore(e,t,i){if(i===Kt.deletedSha)return!1;try{let s=!!await Tt.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Tt.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Tt.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return Ce.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Tt.config_get("diff.guitool",e)||await Tt.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return Ce.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Tt.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return Ce.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Tt.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return Kt.isResolveRequired(t)?(Ce.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),void 0===i?await Tt.revparse(e,t)||t:await Tt.log_resolve(e,w.normalizePath(De.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return Ce.log(`stashApply('${e}', '${t}', ${i})`),Tt.stash_apply(e,t,i)}stashDelete(e,t){return Ce.log(`stashDelete('${e}', '${t}')`),Tt.stash_delete(e,t)}stashSave(e,t,i){if(Ce.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Tt.stash_save(e,t);const s=i.map(t=>Tt.splitPath(t.fsPath,e)[0]);return Tt.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?A.Uri.file(De.join(e,t)):e;return Tt.getEncoding(A.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Tt.getGitInfo(e)}static getGitPath(){return Tt.gitInfo().path}static getGitVersion(){return Tt.gitInfo().version}static isResolveRequired(e){return Tt.isResolveRequired(e)}static isSha(e){return Tt.isSha(e)}static isStagedUncommitted(e){return Tt.isStagedUncommitted(e)}static isUncommitted(e){return Tt.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===Kt.deletedSha?t.deleted:Tt.isSha(e)||Tt.isStagedUncommitted(e)?Tt.shortenSha(e,t):e}static validateGitVersion(e,t){const[i,s]=this.getGitVersion().split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}}Kt.emptyPromise=Promise.resolve(void 0),Kt.deletedSha="ffffffffffffffffffffffffffffffffffffffff",Kt.stagedUncommittedSha=Tt.stagedUncommittedSha,Kt.uncommittedSha=Tt.uncommittedSha,function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(jt||(jt={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:branch:current",e.CurrentBranchWithTracking="gitlens:branch:current:tracking",e.RemoteBranch="gitlens:branch:remote",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:file:commit",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:results:comparison",e.FileHistory="gitlens:history-file",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.ResultsCommits="gitlens:results:commits",e.ResultsFiles="gitlens:results:files",e.SearchResults="gitlens:results:search",e.Stash="gitlens:stash",e.StashFile="gitlens:file:stash",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:file:status",e.StatusFiles="gitlens:status:files",e.StatusFileCommits="gitlens:status:file-commits",e.StatusUpstream="gitlens:status:upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(Gt||(Gt={}));class zt extends A.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class qt extends zt{get repoPath(){return this.uri.repoPath}}class Yt extends zt{constructor(e,t){super(new Ee),this.message=e,this.tooltip=t}getChildren(){return[]}getTreeItem(){const e=new A.TreeItem(this.message,A.TreeItemCollapsibleState.None);return e.contextValue=Gt.Message,e.tooltip=this.tooltip,e}}class Xt extends zt{constructor(e,t,i){super(new Ee),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new A.TreeItem(this.message,A.TreeItemCollapsibleState.None);return e.contextValue=Gt.Pager,e.command=this.getCommand(),e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:Zo.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class Jt extends Xt{constructor(e,t,i){super(`${e} ${G.Space}${G.Dash}${G.Space} this may take a while`,t,i),this.args={maxCount:0}}}class Zt extends zt{constructor(e,t,i,s,o){super(Ee.fromRepoPath(e)),this.repoPath=e,this.branchFolderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of s.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new Zt(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Folder,e.iconPath=A.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.branchFolderName}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(Vt||(Vt={}));class ei extends zt{constructor(e,t,i,s){super(Ee.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await Zo.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,e.tooltip=this.tooltip,(this.displayAs&Vt.CommitIcon)===Vt.CommitIcon)e.iconPath={dark:Zo.context.asAbsolutePath(De.join("images","dark","icon-commit.svg")),light:Zo.context.asAbsolutePath(De.join("images","light","icon-commit.svg"))};else if((this.displayAs&Vt.StatusIcon)===Vt.StatusIcon){const t=st(this.status.status);e.iconPath={dark:Zo.context.asAbsolutePath(De.join("images","dark",t)),light:Zo.context.asAbsolutePath(De.join("images","light",t))}}else(this.displayAs&Vt.Gravatar)===Vt.Gravatar&&(e.iconPath=this.commit.getGravatarUri(Zo.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,this._tooltip=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=De.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&Vt.CommitLabel?Mt.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dataFormat:Zo.config.defaultDateFormat}):Wt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0,this._tooltip=void 0}get resourceType(){return Gt.CommitFile}get tooltip(){return void 0===this._tooltip&&(this.displayAs&Vt.CommitLabel?this._tooltip=Mt.fromTemplate(this.commit.isUncommitted?`\${author} ${G.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${G.Dash} \${id}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dataFormat:Zo.config.defaultDateFormat}):this._tooltip=Wt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status)),this._tooltip}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:Qt.DiffWithPrevious,arguments:[Ee.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ti extends zt{constructor(e,t,i,s,o){super(Ee.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(ti.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==_.List){e=[];for(const t of s.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new ti(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof ti?-1:1)-(t instanceof ti?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Folder,e.iconPath=A.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||_.Auto;if(s===_.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return _.List}return _.Tree}return s}}class ii extends qt{constructor(e,t,i,s){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i,this.trackingRef=s}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...u.map(e.fileStatuses,t=>new ei(t,e.toFileCommit(t),this.explorer,Vt.File))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(De.join(...e)),this.explorer.config.files.compact),i=new ti(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){let e=Mt.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:Zo.config.defaultDateFormat});this.trackingRef===this.commit.sha&&(e=`${G.AngleBracketLeftHeavy}${G.SpaceThin}${this.branch.tracking}${G.SpaceThin}${G.AngleBracketRightHeavy}${G.ArrowHeadRight}${G.Space} ${e}`);const t=new A.TreeItem(e,A.TreeItemCollapsibleState.Collapsed);return t.contextValue=void 0===this.branch||this.branch.current?Gt.CommitOnCurrentBranch:Gt.Commit,this.explorer.config.avatars?t.iconPath=this.commit.getGravatarUri(Zo.config.defaultGravatarsStyle):t.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-commit.svg"),light:Zo.context.asAbsolutePath("images/light/icon-commit.svg")},t.tooltip=Mt.fromTemplate(this.commit.isUncommitted?`\${author} ${G.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${G.Dash} \${id}${this.trackingRef===this.commit.sha?` (${this.branch.tracking})`:""}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dataFormat:Zo.config.defaultDateFormat}),t}getCommand(){return{title:"Compare File with Previous Revision",command:Qt.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class si extends qt{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===k.List?e:Oe.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await Zo.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new Yt("No commits yet")];let t=void 0;void 0!==this.branch.tracking&&(t=await Zo.git.getMergeBase(this.uri.repoPath,this.branch.name,this.branch.tracking));const i=[...u.map(e.commits.values(),e=>new ii(e,this.explorer,this.branch,t))];return e.truncated&&i.push(new Jt("Show All Commits",this,this.explorer)),i}async getTreeItem(){let e=this.label,t=`${this.branch.getName()}${this.branch.current?" (current)":""}`,i="";this.branch.remote||void 0===this.branch.tracking||(this.explorer.config.showTrackingBranch&&(e+=` ${G.Space}${G.ArrowLeftRightLong}${this.branch.getTrackingStatus({prefix:`${G.Space} `})}${G.Space} ${this.branch.tracking}`),t+=`\n\nTracking ${G.Dash} ${this.branch.tracking}\n${this.branch.getTrackingStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(this.branch.state.ahead||this.branch.state.behind)&&(this.branch.state.behind&&(i="-red"),this.branch.state.ahead&&(i=this.branch.state.behind?"-yellow":"-green")));const s=new A.TreeItem(`${this.branch.current?`${G.Check} ${G.Space}`:""}${e}`,A.TreeItemCollapsibleState.Collapsed);return s.tooltip=t,this.branch.remote?s.contextValue=Gt.RemoteBranch:this.branch.current?s.contextValue=this.branch.tracking?Gt.CurrentBranchWithTracking:Gt.CurrentBranch:s.contextValue=this.branch.tracking?Gt.BranchWithTracking:Gt.Branch,s.iconPath={dark:Zo.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:Zo.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},s}}class oi extends zt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:branches`}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...u.filterMap(e,e=>e.remote?void 0:new si(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===k.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),r=new Zt(this.repo.path,"",void 0,s,this.explorer),a=await r.getChildren();return void 0!==i&&a.splice(0,0,i),a}async getTreeItem(){const e=new A.TreeItem("Branches",this.active?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Gt.BranchesWithRemotes:Gt.Branches,e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-branch.svg"),light:Zo.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class ri extends zt{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...u.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new si(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===k.List)return t;const i=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Zt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ve.Fetch),t=this.remote.types.find(e=>e.type===Ve.Push);let i;i=e&&t?G.ArrowLeftRightLong:e?G.ArrowLeft:t?G.ArrowRight:G.Dash;const s=`${this.remote.name} ${G.Space}${i}${G.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${G.Space}${G.Dot}${G.Space} ${this.remote.path}`,o=new A.TreeItem(s,A.TreeItemCollapsibleState.Collapsed);return o.contextValue=Gt.Remote,o.tooltip=`${this.remote.name}\n${this.remote.path} (${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain})`,void 0!==this.remote.provider?o.iconPath={dark:Zo.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:Zo.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:o.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-remote.svg"),light:Zo.context.asAbsolutePath("images/light/icon-remote.svg")},o}}class ai extends zt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:remotes`}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new Yt("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...u.map(e,e=>new ri(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new A.TreeItem("Remotes",A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Remotes,e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-remote.svg"),light:Zo.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class ni extends zt{constructor(e,t,i,s){super(Ee.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new ei(this.status,e,this.explorer,Vt.CommitLabel|(this.explorer.config.avatars?Vt.Gravatar:Vt.CommitIcon)))}async getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.Collapsed);1===this.commits.length&&this.commit.isUncommitted?(e.collapsibleState=A.TreeItemCollapsibleState.None,e.contextValue=Gt.StatusFile,this.commit.isStagedUncommitted?e.tooltip=Wt.fromTemplate("${status} in index\n\n${file}\n${directory}/",this.status):e.tooltip=Wt.fromTemplate("${status} in working tree\n\n${file}\n${directory}/",this.status),e.command=this.getCommand()):(e.contextValue=Gt.StatusFileCommits,e.tooltip=Wt.fromTemplate(`\${status} in ${this.getChangedIn()}\n\n\${file}\n\${directory}/`,this.status));const t=st(this.status.status);return e.iconPath={dark:Zo.context.asAbsolutePath(De.join("images","dark",t)),light:Zo.context.asAbsolutePath(De.join("images","light",t))},this._label=void 0,e.tooltip=e.tooltip.charAt(0).toUpperCase()+e.tooltip.slice(1),e}get folderName(){return void 0===this._folderName&&(this._folderName=De.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Wt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getChangedIn(){const e=[];let t=0;for(const i of this.commits)i.isUncommitted?i.isStagedUncommitted?e.push("working tree"):e.push("index"):t++;return t>0&&e.push(`${t} ${1===t?"commit":"commits"}`),e.length>2&&(e[e.length-1]=`and ${e[e.length-1]}`),e.join(e.length>2?", ":" and ")}getCommand(){return{title:"Compare File with Previous Revision",command:Qt.DiffWithPrevious,arguments:[Ee.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class hi extends zt{constructor(e,t,i,s=!1){super(Ee.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await Zo.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(u.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...u.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new Ge(Ne.File,t,Kt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,Kt.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new Ge(Ne.File,t,Kt.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new Ge(Ne.File,t,Kt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new Ge(Ne.File,t,Kt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const r=o.groupBy(e,e=>e.fileName);let a=[...u.map(s.values(r),e=>new ni(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(a,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(De.join(...e)),this.explorer.config.files.compact),i=new ti(t,"",void 0,e,this.explorer);a=await i.getChildren()}else a.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&a.push(new Jt("Show All Changes",this,this.explorer)),a}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await Zo.git.getChangedFilesCount(this.repoPath,this.status.upstream);void 0!==t&&(e=t.files)}const t=`${e} ${1===e?"file":"files"} changed`,i=new A.TreeItem(t,A.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=Gt.StatusFiles,i.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-diff.svg"),light:Zo.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class ci extends zt{constructor(e,t,i,s=!1){super(Ee.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream:${this.direction}`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await Zo.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...u.map(t.commits.values(),e=>new ii(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await Zo.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=u.first(t.commits.values())),[...u.map(i,e=>new ii(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} ${1===this.status.state.ahead?"commit":"commits"} (ahead of ${this.status.upstream})`:`${this.status.state.behind} ${1===this.status.state.behind?"commit":"commits"} (behind ${this.status.upstream})`,t=new A.TreeItem(e,A.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Gt.StatusUpstream,t.iconPath={dark:Zo.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:Zo.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class li extends zt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new ci(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new ci(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new hi(e,t,this.explorer,this.active))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new A.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=A.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o=`${e.getUpstreamStatus({prefix:`${G.Space} `})}${i?e.getDiffStatus({prefix:`${G.Space} `}):""}`,r=`${e.branch} (current)`,a="";e.upstream&&(this.explorer.config.showTrackingBranch&&(o+=`${G.Space} ${e.upstream}`),r+=`\n\nTracking ${G.Dash} ${e.upstream}\n${e.getUpstreamStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(e.state.ahead||e.state.behind)&&(t=!0,e.state.behind&&(a="-red"),e.state.ahead&&(a=e.state.behind?"-yellow":"-green"))),o=`${e.branch}${""===o?"":` ${G.Space}${e.upstream?G.ArrowLeftRightLong:G.Dash}${o}`}`,i&&(r+=`\n\nHas uncommitted changes${e.getDiffStatus({expand:!0,prefix:"\n",separator:"\n"})}`),s=t||i?this.active?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.Collapsed:A.TreeItemCollapsibleState.None;const n=new A.TreeItem(o,s);return n.id=this.id,n.contextValue=Gt.Status,n.tooltip=r,n.iconPath={dark:Zo.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:Zo.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},n}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class di extends ei{constructor(e,t,i){super(e,t,i,Vt.File)}get resourceType(){return Gt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class mi extends qt{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await Zo.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=u.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new di(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new A.TreeItem(Mt.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:Zo.config.defaultDateFormat}),A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Stash,e.tooltip=Mt.fromTemplate("${ago} (${date})\n\n${message}",this.commit,{dataFormat:Zo.config.defaultDateFormat}),e}}class ui extends zt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:stashes`}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new Yt("No stashed changes")]:[...u.map(e.commits.values(),e=>new mi(e,this.explorer))]}getTreeItem(){const e=new A.TreeItem("Stashes",A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Stashes,e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-stash.svg"),light:Zo.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class gi extends qt{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get ref(){return this.tag.name}async getChildren(){const e=await Zo.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new Yt("No commits yet")];const t=[...u.map(e.commits.values(),e=>new ii(e,this.explorer))];return e.truncated&&t.push(new Jt("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new A.TreeItem(this.tag.name,A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Tag,e}}class pi extends zt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:tags`}async getChildren(){const e=await this.repo.getTags();return 0===e.length?[new Yt("No tags yet")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...e.map(e=>new gi(e,this.uri,this.explorer))])}async getTreeItem(){const e=new A.TreeItem("Tags",A.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Tags,e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-tag.svg"),light:Zo.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class fi extends zt{constructor(e,t,i,s=!1,o){super(e),this.repo=t,this.explorer=i,this.active=s,this.activeParent=o}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return this.resetChildren(),this.updateSubscription(),this.children=[new li(this.uri,this.repo,this.explorer,this.active),new oi(this.uri,this.repo,this.explorer,this.active),new ai(this.uri,this.repo,this.explorer,this.active),new ui(this.uri,this.repo,this.explorer,this.active),new pi(this.uri,this.repo,this.explorer,this.active)],this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${w.pad(G.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new A.TreeItem(e,this.active?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Gt.Repository,t}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||A.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(Ce.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(Qe.Repository)||e.changed(Qe.Config))this.explorer.refreshNode(this.active&&void 0!==this.activeParent?this.activeParent:this);else{if(e.changed(Qe.Stashes)){const e=this.children.find(e=>e instanceof ui);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(Qe.Remotes)){const e=this.children.find(e=>e instanceof ai);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(Qe.Tags)){const e=this.children.find(e=>e instanceof pi);void 0!==e&&this.explorer.refreshNode(e)}}}}class vi extends zt{constructor(e){super(void 0),this.explorer=e,Zo.context.subscriptions.push(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(A.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!z(e))return;let t=!1;try{const i=await Zo.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await Zo.git.getRepository(i);if(void 0===s)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new fi(Ee.fromRepoPath(s.path),s,this.explorer,!0,this)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new A.TreeItem("No active repository",A.TreeItemCollapsibleState.None);return e.id=this.id,e}}class wi extends zt{constructor(e,t,i=Gt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new ii(this.commit,this.explorer).getChildren();return e.splice(0,0,new Yt(Mt.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!0}),Mt.fromTemplate("${message}",this.commit))),e}async getTreeItem(){const e=Mt.fromTemplate(`Commit \${sha} ${w.pad(G.Dash,1,1)} \${authorAgo}`,this.commit,Zo.config.defaultDateFormat),t=new A.TreeItem(e,A.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class Ci extends zt{constructor(e,t,i,s,o=Gt.ResultsCommits){super(Ee.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...u.map(e.commits.values(),e=>new ii(e,this.explorer))];return e.truncated&&t.push(new Jt("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new A.TreeItem(await this.getLabel(),e&&e.count>0?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class bi extends zt{constructor(e,t,i,s,o){super(Ee.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.None);e.contextValue=Gt.StatusFile,e.tooltip=Wt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status);const t=st(this.status.status);return e.iconPath={dark:Zo.context.asAbsolutePath(De.join("images","dark",t)),light:Zo.context.asAbsolutePath(De.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=De.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Wt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:Qt.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Ee.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class yi extends zt{constructor(e,t,i,s){super(Ee.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...u.map(e,e=>new bi(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(De.join(...e)),this.explorer.config.files.compact),i=new ti(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new A.TreeItem(await this.getLabel(),e&&e.length>0?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.None);return t.contextValue=Gt.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await Zo.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),t=void 0!==e?e.length:0,i=`${0===t?"No":t} ${1===t?"file":"files"} changed`;this._cache={label:i,diff:e}}return this._cache}async getDiff(){return(await this.ensureCache()).diff}async getLabel(){return(await this.ensureCache()).label}}class xi extends zt{constructor(e,t,i,s){super(Ee.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){return this.resetChildren(),this.children=[new Ci(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>Zo.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new yi(this.uri.repoPath,this.ref1.ref,this.ref2.ref,this.explorer)],this.children}async getTreeItem(){let e="";if(await Zo.git.getRepositoryCount()>1){const t=await Zo.git.getRepository(this.uri.repoPath);e=` ${w.pad(G.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new A.TreeItem(`Comparing ${this.ref1.label||Kt.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||Kt.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,A.TreeItemCollapsibleState.Expanded);return t.contextValue=Gt.ComparisonResults,t}}class $i extends zt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=Vt.CommitLabel|(this.explorer.config.avatars?Vt.Gravatar:Vt.StatusIcon),i=await Zo.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=Kt.uncommittedSha,void 0!==i.indexStatus?o=Kt.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=Kt.stagedUncommittedSha,o="HEAD");const r=new Ge(Ne.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new ei(i,r,this.explorer,t))}const s=await Zo.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...u.map(s.commits.values(),e=>new ei(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new Yt("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new A.TreeItem(`${this.uri.getFormattedPath()}`,A.TreeItemCollapsibleState.Expanded);return e.contextValue=Gt.FileHistory,e.tooltip=`History of ${this.uri.getFilename()}\n${this.uri.getDirectory()}/`,e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-history.svg"),light:Zo.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.disposable=this.disposable||this.repo.onDidChange(this.onRepoChanged,this)}onRepoChanged(e){e.changed(Qe.Repository)&&(Ce.log(`FileHistoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class Si extends zt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new $i(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new A.TreeItem(`${this.uri.getFormattedPath()}`,A.TreeItemCollapsibleState.Expanded);return e.contextValue=Gt.History,e.iconPath={dark:Zo.context.asAbsolutePath("images/dark/icon-history.svg"),light:Zo.context.asAbsolutePath("images/light/icon-history.svg")},e}}class Di extends zt{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return this.resetChildren(),this.children=this.repositories.sort((e,t)=>e.index-t.index).map(e=>new fi(Ee.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new vi(this.explorer)),this.children}getTreeItem(){const e=new A.TreeItem("Repositories",A.TreeItemCollapsibleState.Expanded);return e.contextValue=Gt.Repositories,e}}function ki(e,t){return e instanceof A.Uri?e:void 0!==t&&void 0!==t.document?t.document.uri:void 0}function _i(e){return"view"===e.type&&e.node.branch&&e.node.branch instanceof Oe}function Fi(e){return"view"===e.type&&e.node.commit&&e.node.commit instanceof Ue}function Pi(e){return"view"===e.type&&e.node.remote&&e.node.remote instanceof ze}function Ri(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates)}function Ti(e){return void 0!==e&&void 0!==e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.DiffHeadWithBranch="gitlens.diffHeadWithBranch",e.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame"}(Qt||(Qt={}));class Ei extends A.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=A.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>A.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=A.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=Ei.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(void 0===o||function(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(void 0===o||o instanceof A.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof zt){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(Ti(o)){const t=[];let s=0;for(const e of i){if(!Ti(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(Ri(o)){const t=[];let s=0;for(const e of i){if(!Ri(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class Bi extends Ei{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,A.window.activeTextEditor,...t)}}let Ni=void 0;class Ai extends Bi{constructor(e){super(e)}_execute(e,...t){return Ni={command:e,args:t},super._execute(e,...t)}}class Ui extends A.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(A.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=A.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Li(e,t={}){const{rethrow:i}=t,s=c.__rest(t,["rethrow"]);try{if(e instanceof Ee&&(e=e.fileUri({noSha:!0})),e.scheme===j.GitLensGit){const t=Ee.fromRevisionUri(e);if(q.includes(De.extname(t.fsPath))){const i=await Zo.git.getVersionedFile(t.repoPath,t.fsPath,t.sha);if(void 0!==i)return e=A.Uri.file(i),void await A.commands.executeCommand(W.Open,e)}}const o=await A.workspace.openTextDocument(e);return A.window.showTextDocument(o,Object.assign({preserveFocus:!1,preview:!0,viewColumn:A.ViewColumn.Active},s))}catch(t){if(t.toString().includes("File seems to be binary and cannot be opened as text"))return void await A.commands.executeCommand(W.Open,e);if(i)throw t;return void Ce.error(t,"openEditor")}}class Oi extends Ui{constructor(){super([Qt.ClearFileAnnotations,Qt.ComputingFileAnnotations])}async execute(e,t,i){if(void 0!==e){if(void 0!==i&&!ee.equals(i,e.document.uri)){const t=A.window.visibleTextEditors.find(e=>ee.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return Zo.fileAnnotations.clear(e)}catch(e){return Ce.error(e,"ClearFileAnnotationsCommand"),A.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class Ii extends A.Disposable{constructor(){super(()=>this.dispose());const e=m.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=A.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return A.commands.executeCommand(W.CloseActiveEditor)}async next(){return A.commands.executeCommand(W.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=0,t(e))}),s=setTimeout(()=>{t(A.window.activeTextEditor),s=0},e)});return this._resolver=void 0,t}}var Mi;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ResultsExplorerNotice="suppressResultsExplorerNotice",e.ShowKeyBindingsNotice="suppressShowKeyBindingsNotice"}(Mi||(Mi={}));class Wi{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Wi.showMessage("info","Commit has no previous commit.",Mi.CommitHasNoPreviousCommitWarning):Wi.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit.`,Mi.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Wi.showMessage("warn",`${e}. The commit could not be found.`,Mi.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Wi.showMessage("warn",`${e}. The file is probably not under source control.`,Mi.FileNotUnderSourceControlWarning)}static async showKeyBindingsInfoMessage(){const e=ir.name("advanced")("messages").value,t=ir.get(e);if(t[Mi.ShowKeyBindingsNotice])return;if(Zo.config.keymap!==E.Alternate)return t[Mi.ShowKeyBindingsNotice]=!0,void await ir.update(e,t,A.ConfigurationTarget.Global);const i=[{title:"Keep Shortcuts",isCloseAffordance:!0},{title:"Switch Shortcuts"},{title:"No Shortcuts"}],s=await Wi.showMessage("info","GitLens is using keyboard shortcuts which can conflict with menu mnemonics and different keyboard layouts. To avoid such conflicts, it is recommended to switch to the new default keyboard shortcuts.",Mi.ShowKeyBindingsNotice,null,...i);switch(s){case i[1]:await ir.update(ir.name("keymap").value,E.Chorded,A.ConfigurationTarget.Global);break;case i[2]:await ir.update(ir.name("keymap").value,E.None,A.ConfigurationTarget.Global)}return s}static showLineUncommittedWarningMessage(e){return Wi.showMessage("warn",`${e}. The line has uncommitted changes.`,Mi.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Wi.showMessage("warn",`${e}. No repository could be found.`,Mi.NoRepositoryWarning)}static showResultExplorerInfoMessage(){return Wi.showMessage("info",'If you can\'t find your results, click on "GITLENS RESULTS" at the bottom of the Explorer view.',Mi.ResultsExplorerNotice,null)}static showUnsupportedGitVersionErrorMessage(e){return Wi.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git.`,Mi.GitVersionWarning)}static async showMessage(e,t,i,s={title:"Don't Show Again"},...o){if(Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),ir.get(ir.name("advanced")("messages")(i).value))return void Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let r=void 0;switch(e){case"info":r=await A.window.showInformationMessage(t,...o);break;case"warn":r=await A.window.showWarningMessage(t,...o);break;case"error":r=await A.window.showErrorMessage(t,...o)}if(null===s||r===s){Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`);const o=ir.name("advanced")("messages").value,a=ir.get(o);if(a[i]=!0,await ir.update(o,a,A.ConfigurationTarget.Global),r===s)return}return Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${r?r.title:r}`),r}}class Hi extends Bi{constructor(){super(Qt.CloseUnchangedFiles)}async execute(e,t,i={}){t=ki(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await Zo.git.getRepoPath(t);if(!e)return Wi.showNoRepositoryWarningMessage("Unable to close unchanged files");const s=await Zo.git.getStatusForRepo(e);if(void 0===s)return A.window.showWarningMessage("Unable to close unchanged files");i.uris=s.files.map(e=>e.uri)}if(0===i.uris.length)return A.commands.executeCommand(W.CloseAllEditors);const s=new Ii;let o=0,r=void 0,a=A.window.activeTextEditor;for(;;){if(void 0!==a){if(Z.equals(r,a,{useId:!0,usePosition:!0}))break;if(void 0!==a.document&&(a.document.isDirty||i.uris.some(e=>ee.equals(e,a.document&&a.document.uri)))){const e=r;if(r=a,a=await s.awaitNext(500),Z.equals(e,a,{useId:!0,usePosition:!0}))break;continue}}if(r=a,a=await s.awaitClose(500),void 0===r&&void 0===a){if(++o>=4)break}else o=0}return void s.dispose()}catch(e){return Ce.error(e,"CloseUnchangedFilesCommand"),A.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class ji extends Bi{constructor(){super(Qt.CopyMessageToClipboard)}async preExecute(e,t={}){return Fi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=ki(t,e);const o=await Promise.resolve().then(function(){var e=i(12);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});try{if(s=Object.assign({},s),void 0===t){const t=await Zo.git.getActiveRepoPath(e);if(!t)return;const i=await Zo.git.getLog(t,{maxCount:1});if(!i)return;return s.message=u.first(i.commits.values()).message,void o.copy(s.message)}const i=await Ee.fromUri(t);if(void 0===s.message){if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Zo.git.getBlameForLineContents(i,t,e.document.getText()):await Zo.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return Ce.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const t=await Zo.git.getLogCommit(i.repoPath,s.sha);if(void 0===t)return;s.message=t.message}return void o.copy(s.message,e=>{if(e){if(e.message.includes("xclip"))return void A.window.showErrorMessage("Unable to copy message, xclip is not installed. You can install it via `sudo apt-get install xclip`");Ce.error(e,"CopyMessageToClipboardCommand"),A.window.showErrorMessage("Unable to copy message. See output channel for more details")}})}catch(e){return Ce.error(e,"CopyMessageToClipboardCommand"),A.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class Gi extends Bi{constructor(){super(Qt.CopyShaToClipboard)}async preExecute(e,t={}){return Fi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=ki(t,e);const o=await Promise.resolve().then(function(){var e=i(12);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});try{if(s=Object.assign({},s),void 0===t){const t=await Zo.git.getActiveRepoPath(e);if(!t)return;const i=await Zo.git.getLog(t,{maxCount:1});if(!i)return;return s.sha=u.first(i.commits.values()).sha,void o.copy(s.sha)}const i=await Ee.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Zo.git.getBlameForLineContents(i,t,e.document.getText()):await Zo.git.getBlameForLine(i,t);if(void 0===o)return;s.sha=o.commit.sha}catch(e){return Ce.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.copy(s.sha,e=>{if(e){if(e.message.includes("xclip"))return void A.window.showErrorMessage("Unable to copy commit id, xclip is not installed. You can install it via `sudo apt-get install xclip`");Ce.error(e,"CopyShaToClipboardCommand"),A.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}})}catch(e){return Ce.error(e,"CopyShaToClipboardCommand"),A.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}function Vi(){return!ir.get(ir.name("advanced")("quickPick")("closeOnFocusOut").value)}function Qi(e,t){const i=new A.CancellationTokenSource;return async function(e,t,i){const s=i&&await Zo.keyboard.beginScope(i);try{await A.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Vi()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class Ki{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):A.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class zi extends Ki{constructor(e){super({label:e,description:""})}}class qi extends Ki{constructor(e,t){super({label:"",description:""},e,t)}}class Yi extends Ki{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Li(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Xi extends Ki{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Li(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ji{constructor(e){this.commit=e;const t=e.getShortMessage(`${G.Space}$(ellipsis)`);e.isStash?(this.label=t,this.description="",this.detail=`${G.Space} ${e.stashName||e.shortSha} ${w.pad(G.Dot,1,1)} ${e.formattedDate} ${w.pad(G.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${w.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${G.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${w.pad(G.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class Zi extends Ki{constructor(e,t={label:"Show in Results",description:`${w.pad(G.Dash,2,2)} displays commit in the GitLens Results view`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){Zo.resultsExplorer.showCommitInResults(this.commit)}}class es extends Ki{constructor(e,t,i={label:"Show in Results",description:`${w.pad(G.Dash,2,2)} displays commits in the GitLens Results view`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){Zo.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class ts extends es{constructor(e,t,i={label:"Show in Results",description:`${w.pad(G.Dash,2,2)} displays results in the GitLens Results view`}){super(e,{label:t},i),this.results=e,this.search=t}}class is extends Ki{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${w.pad(G.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=cs.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([Zo.git.getBranches(this.repoPath),Zo.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return cs.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.cancel()}}}const ss=Object.create(null),os=["left","right",",",".","escape"],rs=[];class as extends A.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||ss}async dispose(){const e=rs.indexOf(this.mapping);Ce.log("KeyboardScope.dispose",rs.length,e),e===rs.length-1?(rs.pop(),await this.updateKeyCommandsContext(rs[rs.length-1])):rs.splice(e,1)}async begin(){return rs.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=rs[rs.length-1];t===this.mapping&&t[e]&&(Ce.log("KeyboardScope.clearKeyCommand",rs.length,e),t[e]=void 0,await Q(`${H.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=rs[rs.length-1];i===this.mapping&&(Ce.log("KeyboardScope.setKeyCommand",rs.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await Q(`${H.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of os)t.push(Q(`${H.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class ns extends A.Disposable{constructor(){super(()=>this.dispose());const e=os.map(e=>A.commands.registerCommand(`${U}.key.${e}`,()=>this.execute(e),this));this._disposable=A.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return Ce.log("Keyboard.beginScope",rs.length),await new as(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(rs.length)try{let t=rs[rs.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return Ce.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void Ce.error(e,"Keyboard.execute")}}}class hs{constructor(e){this.branchOrTag=e,e instanceof Oe?(this.label=`${e.current?`$(check)${G.Space}`:G.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${G.Space.repeat(2)} remote branch`:""):(this.label=`${G.Space.repeat(4)} ${e.name}`,this.description=`${G.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Oe&&this.branchOrTag.remote}}class cs{static showProgress(e){return Qi(e,{left:ss,",":ss,".":ss})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new hs(e)),...t.map(e=>new hs(e)),...e.filter(e=>e.remote).map(e=>new hs(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await Zo.keyboard.beginScope({left:s.goBackCommand||ss});s.progressCancellation&&s.progressCancellation.cancel();const a=await A.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:Vi()});return await r.dispose(),a}}class ls{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${G.Space}`:G.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${G.Space.repeat(2)} remote branch`:""}}class ds{static async show(e,t,i={}){const s=e.map(e=>new ls(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await A.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:Vi()})}}class ms extends Ki{constructor(e,t){super({label:`$(link-external) Open ${oe(t)} in ${e.provider.name}`,description:`${w.pad(G.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class us extends Ki{constructor(e,t,i){const s=oe(t);let o="";switch(t.type){case ie.Branch:o=`$(git-branch) ${t.branch}`;break;case ie.Branches:o="$(git-branch) Branches";break;case ie.Commit:o=`$(git-commit) ${Kt.shortenSha(t.sha)}`;break;case ie.File:o=`$(file-text) ${De.basename(t.fileName)}`;break;case ie.Repo:o="$(repo) Repository";break;case ie.Revision:if(void 0!==t.commit&&t.commit instanceof Ge)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${De.basename(t.fileName)} in ${G.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${G.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${De.basename(t.fileName)} in ${G.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":Kt.shortenSha(t.sha);o=`$(file-text) ${De.basename(t.fileName)}${e?` in ${G.Space}$(git-commit) ${e}`:""}`}}const r=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===r.provider.name)?r.provider.name:"Remote"}${G.Ellipsis}`,description:`${w.pad(G.Dash,2,3)} ${o}`},Qt.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${r.provider.name}`,description:`${w.pad(G.Dash,2,3)} $(repo) ${r.provider.path} ${w.pad(G.Dot,1,1)} ${o}`},Qt.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class gs{static async show(e,t,i,s){const o=e.map(e=>new ms(e,i));s&&o.splice(0,0,s);const r=await A.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Vi()});if(void 0!==r)return r}}class ps{static showProgress(e){return Qi(`${e} history ${G.Dash} search by commit message, filename, or commit id`,{left:ss,",":ss,".":ss})}static async show(e,t,i,s,o,r){const a=Array.from(u.map(e.commits.values(),e=>new Ji(e))),n=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${i} history`},Qt.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=await Zo.git.getRemotes(t&&t.repoPath||e.repoPath);h.length&&a.splice(0,0,new us(h,{type:"branch",branch:i},n)),a.splice(0,0,new Ki({label:"$(search) Show Commit Search",description:`${w.pad(G.Dash,2,3)} search for commits by message, author, files, or commit id`},Qt.ShowCommitSearch,[Ee.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&a.splice(0,0,new Ki({label:"$(sync) Show All Commits",description:`${w.pad(G.Dash,2,3)} this may take a while`},Qt.ShowQuickBranchHistory,[Ee.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),r&&a.splice(0,0,r),e.truncated)){const s=new Ki({label:"$(arrow-right) Show Next Commits",description:`${w.pad(G.Dash,2,3)} shows ${e.maxCount} newer commits`},Qt.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),n=u.last(e.commits.values());null!=n&&(c=new Ki({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(G.Dash,2,3)} shows ${e.maxCount} older commits`},Qt.ShowQuickBranchHistory,[new Ee(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),a.splice(0,0,c))}if(o&&a.splice(0,0,o),s.token.isCancellationRequested)return;const l=await Zo.keyboard.beginScope({left:o,",":c,".":r});s.cancel();const d=await A.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${G.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Vi()});return await l.dispose(),d}}class fs extends Ki{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${w.pad(G.Dash,2,3)} $(file-text) ${De.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await Zo.git.checkoutFile(e),Li(e,{preserveFocus:!0,preview:!1})}}class vs extends Yi{constructor(e,t){super(A.Uri.file(De.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${w.pad(G.Dash,2,3)} ${De.basename(e.fileName)}`})}}class ws extends Yi{constructor(e,t){let i,s;"D"===e.status?(s=Ee.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${w.pad(G.Dash,2,3)} ${De.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.previousShortSha} (deleted in ${G.Space}$(git-commit) ${e.shortSha})`):(s=Ee.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${w.pad(G.Dash,2,3)} ${De.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class Cs{static async show(e,t,i,s,o){const r=[],a=e.isStash,n=e.workingFileName&&De.basename(e.workingFileName)||De.basename(e.fileName),h=e.isUncommitted;if(h){const t=await Zo.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),a&&r.push(new fs(e)),e.previousFileShortSha&&r.push(new Ki({label:"$(git-compare) Open Changes",description:`${w.pad(G.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${G.Space} $(git-compare) ${G.Space} $(git-commit) ${e.shortSha}`},Qt.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new Ki({label:"$(git-compare) Open Changes with Working Tree",description:`${w.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha} ${G.Space} $(git-compare) ${G.Space} $(file-text) ${n}`},Qt.DiffWithWorking,[A.Uri.file(De.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new vs(e)),r.push(new ws(e));const c=await Zo.git.getRemotes(e.repoPath);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await Zo.git.getBranch(e.repoPath);r.push(new us(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}a||r.push(new us(c,{type:"revision",fileName:e.fileName,commit:e},s))}a||(r.push(new fs(e)),r.push(new Ki({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(G.Dash,2,3)} ${e.shortSha}`},Qt.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new Ki({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},Qt.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new Ki({label:"$(history) Show File History",description:`${w.pad(G.Dash,2,3)} of ${De.basename(e.fileName)}`},Qt.ShowQuickFileHistory,[A.Uri.file(De.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),a||(r.push(new Ki({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${w.pad(G.Dash,2,3)} of ${De.basename(e.fileName)} ${w.pad(G.Dot,1,1)} from ${G.Space}$(git-commit) ${e.shortSha}`},Qt.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),r.push(new Ki({label:"$(git-commit) Show Commit Details",description:`${w.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha}`},Qt.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&r.splice(0,0,i);let l=void 0,d=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.previousSha){if(void 0===(s=await Zo.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:Zo.config.advanced.maxListItems,ref:e.sha,renames:!0})))return ss;void 0===(r=s&&s.commits.get(e.sha))&&e.isMerge&&(r=u.first(s.commits.values())),r&&(r.nextSha=e.nextSha,r.nextFileName=e.nextFileName)}return void 0===r||void 0===r.previousSha?ss:new qi(Qt.ShowQuickCommitFileDetails,[r.previousUri,{fileLog:s,sha:r.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.nextSha){s=void 0,r=void 0;const i=await Zo.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((r=e).nextSha=i.sha,r.nextFileName=i.originalFileName||i.fileName)}return void 0===r||void 0===r.nextSha?ss:new qi(Qt.ShowQuickCommitFileDetails,[r.nextUri,{fileLog:s,sha:r.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new qi(Qt.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new qi(Qt.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const m=await Zo.keyboard.beginScope({left:i,",":l,".":d}),g=await A.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${w.pad(G.Dot,1,1)} ${h?`Uncommitted ${G.ArrowRightHollow} `:""}${e.shortSha} ${w.pad(G.Dot,1,1)} ${e.author}, ${e.formattedDate} ${w.pad(G.Dot,1,1)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`,ignoreFocusOut:Vi(),onDidSelectItem:e=>{m.setKeyCommand("right",e)}});return await m.dispose(),g}}class bs extends Yi{constructor(e,t){const i=tt(t.status),s=Ze.getFormattedDirectory(t,!0);super(Ee.toRevisionUri(e.sha,t,e.repoPath),{label:`${w.pad(i,4,2)} ${De.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):A.commands.executeCommand(Qt.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class ys extends Xi{constructor(e,t=!1,i){const s=e.repoPath;super(o.filterMap(e.fileStatuses,e=>Ee.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class xs extends Xi{constructor(e,t){super(o.filterMap(e.fileStatuses,t=>Ee.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${w.pad(G.Dash,2,3)} in ${G.Space}$(git-commit) ${e.shortSha}`})}}class $s{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new bs(e,t)),a=e.isStash;let n=0;if(a)r.splice(n++,0,new Ki({label:"$(git-pull-request) Apply Stashed Changes",description:`${w.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},Qt.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Ki({label:"$(x) Delete Stashed Changes",description:`${w.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},Qt.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Zi(e));else{r.splice(n++,0,new Zi(e));const t=await Zo.git.getRemotes(e.repoPath);t.length&&r.splice(n++,0,new us(t,{type:"commit",sha:e.sha},s))}r.splice(n++,0,new ys(e)),r.splice(n++,0,new xs(e)),r.splice(n++,0,new Ki({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${w.pad(G.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${G.Space} $(git-compare) ${G.Space} $(git-commit) ${e.shortSha}`},Qt.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(n++,0,new Ki({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${w.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha} ${G.Space} $(git-compare) ${G.Space} $(file-directory) Working Tree`},Qt.DiffDirectory,[t,{ref1:e.sha}])),a||r.splice(n++,0,new Ki({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(G.Dash,2,3)} ${e.shortSha}`},Qt.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(n++,0,new Ki({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},Qt.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(n++,0,new Ki({label:"Changed Files",description:e.getDiffStatus()},Qt.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let h=void 0,c=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await Zo.git.getLog(e.repoPath,{maxCount:Zo.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?ss:new qi(Qt.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await Zo.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&u.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?ss:new qi(Qt.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new qi(Qt.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new qi(Qt.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await Zo.keyboard.beginScope({left:i,",":h,".":c}),d=await A.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${w.pad(G.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${w.pad(G.Dot,1,1)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`,ignoreFocusOut:Vi(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class Ss{static showProgress(e){return Qi(e,{left:ss,",":ss,".":ss})}static async show(e,t,i,s){const o=e&&[...u.map(e.commits.values(),e=>new Ji(e))]||[new zi("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const r=await Zo.keyboard.beginScope({left:s.goBackCommand});i.cancel();const a=await A.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Vi()});return await r.dispose(),a}}class Ds{static showProgress(e){return Qi(e,{left:ss,",":ss,".":ss})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(u.map(e.commits.values(),e=>new Ji(e)));let r=0;if(s.pickerOnly&&(r++,o.splice(0,0,new is(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(r++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)r++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await Zo.git.findWorkingFileName(De.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,o.splice(0,0,new Ki({label:"$(history) Show File History",description:`${w.pad(G.Dash,2,3)} of ${De.basename(i)}`},Qt.ShowQuickFileHistory,[A.Uri.file(De.resolve(e.repoPath,i)),{goBackCommand:new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${De.basename(t.fsPath)}${t.sha?` from ${G.Space}$(git-commit) ${t.shortSha}`:""}`},Qt.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(r++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(r++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await Zo.git.getBranch(t.repoPath),a=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${De.basename(t.fsPath)}${t.sha?` from ${G.Space}$(git-commit) ${t.shortSha}`:""}`},Qt.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(r++,0,new Ki({label:"$(history) Show Branch History",description:`${w.pad(G.Dash,2,3)} shows  ${G.Space}$(git-branch) ${i.name} history`},Qt.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:a}]));const n=await Zo.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(r++,0,new us(n,e,a))}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await Zo.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await A.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Vi()});return await a.dispose(),n}}class ks{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class _s{static async show(e,t){const i=[...u.map(await Zo.git.getRepositories(),e=>new ks(e))];return void 0!==t&&i.splice(0,0,t),await A.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Vi()})}}class Fs extends Yi{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":G.Space.repeat(3)}${w.pad(s,2,2)} ${De.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new Ge(Ne.File,e.repoPath,Kt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new Ge(Ne.File,e.repoPath,Kt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?Kt.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return A.commands.executeCommand(Qt.DiffWithPrevious,Ee.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class Ps extends Ki{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},Qt.OpenChangedFiles,[void 0,{uris:i}])}}class Rs{static computeStatus(e){let t=0,i=0,s=0,o=0,r=0,a=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":r++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":a++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+r,l=i+o+a;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${r}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${a}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...u.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new Fs(e.with({indexStatus:null}),e.indexStatus),new Fs(e.with({workTreeStatus:null}))]:[new Fs(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${e.branch} status`},Qt.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const r=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;r>-1&&(i.splice(r,0,new Ki({label:"Unstaged Files",description:o.unstagedStatus},Qt.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(r,0,new Ps(o.stagedAddsAndChanges,{label:`${G.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new Ps(o.unstagedAddsAndChanges,{label:`${G.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Ki({label:"Staged Files",description:o.stagedStatus},Qt.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Ki({label:"Unstaged Files",description:o.unstagedStatus},Qt.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new Ps(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new Ki({label:"$(x) Close Unchanged Files",description:""},Qt.CloseUnchangedFiles))):i.push(new Ki({label:"No changes in the working tree",description:""},Qt.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Ki({label:"$(inbox) Show Stashed Changes",description:`${w.pad(G.Dash,2,3)} shows stashed changes in the repository`},Qt.ShowQuickStashList,[Ee.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Ki({label:`$(cloud-upload)${G.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${G.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(G.Dash,2,3)} shows commits in ${G.Space}$(git-branch) ${e.branch} but not ${G.Space}$(git-branch) ${e.upstream}`},Qt.ShowQuickBranchHistory,[Ee.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new Ki({label:`$(cloud-download)${G.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${G.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(G.Dash,2,3)} shows commits in ${G.Space}$(git-branch) ${e.upstream} but not ${G.Space}$(git-branch) ${e.branch}${e.sha?` (since ${G.Space}$(git-commit) ${Kt.shortenSha(e.sha)})`:""}`},Qt.ShowQuickBranchHistory,[Ee.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Ki({label:`$(git-branch) ${e.branch} is up-to-date with ${G.Space}$(git-branch) ${e.upstream}`,description:""},Qt.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await Zo.keyboard.beginScope({left:t}),a=await A.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${w.pad(G.ArrowLeftRightLong,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Vi(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),a}}class Ts{static showProgress(e){return Qi("apply"===e?`Apply stashed changes to your working tree${G.Ellipsis}`:`stashed changes ${G.Dash} search by message, filename, or commit id`,{left:ss,",":ss,".":ss})}static async show(e,t,i,s,o){const r=e&&Array.from(u.map(e.commits.values(),e=>new Ji(e)))||[];if("list"===t&&r.splice(0,0,new Ki({label:"$(plus) Stash Changes",description:`${w.pad(G.Dash,2,3)} stashes all changes`},Qt.StashSave,[{goBackCommand:o}])),s&&r.splice(0,0,s),i.token.isCancellationRequested)return;const a=await Zo.keyboard.beginScope({left:s});i.cancel();const n=await A.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${G.Ellipsis}`:`stashed changes ${G.Dash} search by message, filename, or commit id`,ignoreFocusOut:Vi()});return await a.dispose(),n}}class Es extends Bi{constructor(){super([Qt.DiffHeadWithBranch,Qt.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case Qt.DiffHeadWithBranch:t.ref2="HEAD";break;case Qt.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=ki(t,e);try{const o=await Zo.git.getRepoPath(t);if(!o)return Wi.showNoRepositoryWarningMessage("Unable to open branch compare");if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to ${G.Ellipsis}`;break;case"HEAD":e=`Compare HEAD to ${G.Ellipsis}`;break;default:e=`Compare ${i.ref2} to ${G.Ellipsis}`}s=cs.showProgress(e);const[t,r]=await Promise.all([Zo.git.getBranches(o),Zo.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await cs.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Ki)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void Zo.resultsExplorer.showComparisonInResults(o,i.ref1,i.ref2)}catch(e){return Ce.error(e,"DiffBranchWithBranchCommand"),A.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.cancel()}}}class Bs extends Bi{constructor(){super([Qt.DiffDirectory,Qt.ExternalDiffAll,Qt.ExplorersOpenDirectoryDiff,Qt.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case Qt.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case Qt.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof xi&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case Qt.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof qt})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=ki(t,e);try{const o=await Zo.git.getRepoPath(t);if(!o)return Wi.showNoRepositoryWarningMessage("Unable to open directory compare");if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to ${G.Ellipsis}`;s=cs.showProgress(e);const[t,r]=await Promise.all([Zo.git.getBranches(o),Zo.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await cs.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Ki)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void Zo.git.openDirectoryDiff(o,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await A.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return A.commands.executeCommand(W.Open,A.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return Ce.error(e,"DiffDirectoryCommand"),A.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.cancel()}}}class Ns extends Bi{constructor(){super(Qt.DiffLineWithPrevious)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;const s=await Ee.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Kt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Zo.git.getBlameForLineContents(s,t,e.document.getText()):await Zo.git.getBlameForLine(s,t);if(void 0===o)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await Zo.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:Kt.stagedUncommittedSha}))}}catch(e){return Ce.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Kt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,o)}}class As extends Bi{constructor(){super(Qt.DiffLineWithWorking)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;const s=await Ee.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Kt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Zo.git.getBlameForLineContents(s,t,e.document.getText()):await Zo.git.getBlameForLine(s,t);if(void 0===o)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await Zo.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?Kt.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return Ce.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,o)}}class Us extends Bi{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Ue){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:Kt.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(Qt.DiffWith,i)}constructor(){super(Qt.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{Kt.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await Zo.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),Kt.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await Zo.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[t,s]=await Promise.all([Zo.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),Zo.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===s?o=Kt.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==t&&i.lhs.sha!==Kt.deletedSha||(o="added in ");let r="";if(void 0===t&&""===i.rhs.sha&&(void 0!==s?(r="not in ",o=""):r="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==Kt.deletedSha&&(void 0!==t||""!==r)){const e=Kt.shortenSha(i.lhs.sha)||"";i.lhs.title=`${De.basename(i.lhs.uri.fsPath)}${""!==e?` (${r}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==Kt.deletedSha){const e=Kt.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${De.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const a=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${G.ArrowLeftRightLong} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=A.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new A.Range(i.line,0,i.line,0)),await A.commands.executeCommand(W.Diff,void 0===t?Ee.toRevisionUri(Kt.deletedSha,i.lhs.uri.fsPath,i.repoPath):A.Uri.file(t),void 0===s?Ee.toRevisionUri(Kt.deletedSha,i.rhs.uri.fsPath,i.repoPath):A.Uri.file(s),a,i.showOptions)}catch(e){return Ce.error(e,"DiffWithCommand","getVersionedFile"),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class Ls extends Bi{constructor(){super(Qt.DiffWithBranch)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Ee.fromUri(t);if(!s.repoPath)return Wi.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${De.basename(s.fsPath)} with ${G.Ellipsis}`,r=cs.showProgress(o);try{const[e,t]=await Promise.all([Zo.git.getBranches(s.repoPath),Zo.git.getTags(s.repoPath)]);if(r.token.isCancellationRequested)return;const a=await cs.show(e,t,o,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===a)return;if(a instanceof Ki)return a.execute();const n=a.name;if(void 0===n)return;let h,c;const l=await Zo.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=w.normalizePath(De.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=A.Uri.file(De.join(s.repoPath,t.originalFileName)),c=`${De.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:a.remote?`remotes/${n}`:n,uri:h||s,title:c||`${De.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,d)}finally{r.cancel()}}}class Os extends Bi{constructor(){super(Qt.DiffWithNext)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Ee.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof Ge)||void 0!==i.range)try{const r=void 0===i.commit?s.sha:i.commit.sha;if(Kt.isStagedUncommitted(r))return A.commands.executeCommand(Qt.DiffWithWorking,t);const a=await Zo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==r?void 0:2,range:i.range,renames:!0});if(void 0===a)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=r&&a.commits.get(r)||u.first(a.commits.values()),void 0===s.sha&&void 0!==(o=await Zo.git.getStatusForFile(s.repoPath,s.fsPath)))return A.commands.executeCommand(Qt.DiffWithWorking,t)}catch(e){return Ce.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await Zo.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Kt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,e)}return A.commands.executeCommand(Qt.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,r)}}class Is extends Bi{constructor(){super(Qt.DiffWithPrevious)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Ee.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===Kt.deletedSha)return Wi.showCommitHasNoPreviousCommitWarningMessage();let o=!1;Kt.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0);const r=await Zo.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===r)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&r.commits.get(s)||u.first(r.commits.values()),void 0===e.sha){const s=await Zo.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Kt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:Kt.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,e)}return A.commands.executeCommand(Qt.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return Ce.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Kt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,s)}}class Ms extends Bi{constructor(){super(Qt.DiffWithRevision)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Ee.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${w.pad(G.Dot,1,1)} ${s.shortSha}`:""} with ${G.Ellipsis}`,r=Ds.showProgress(o);try{const a=await Zo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===a)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Ki({label:"$(arrow-right) Show Next Commits",description:`${w.pad(G.Dash,2,3)} shows ${a.maxCount} newer commits`},Qt.DiffWithRevision,[t,Object.assign({},i)]),s=u.last(a.commits.values());null!=s&&(n=new Ki({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(G.Dash,2,3)} shows ${a.maxCount} older commits`},Qt.DiffWithRevision,[new Ee(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await Ds.show(a,s,o,{pickerOnly:!0,progressCancellation:r,currentCommand:new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${G.Space}$(git-commit) ${s.shortSha}`:""}`},Qt.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Ki({label:"$(sync) Show All Commits",description:`${w.pad(G.Dash,2,3)} this may take a while`},Qt.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;let c;if(h instanceof is){const e=await h.execute();if(void 0===e)return;if(e instanceof Ki)return e.execute();c=e.name}else{if(h instanceof Ki)return h.execute();c=h.commit.sha}const l={repoPath:s.repoPath,lhs:{sha:c,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await A.commands.executeCommand(Qt.DiffWith,l)}catch(e){return Ce.error(e,"DiffWithRevisionCommand"),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.cancel()}}}class Ws extends Bi{constructor(){super(Qt.DiffWithWorking)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;const s=await Ee.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Kt.isUncommitted(i.commit.sha)){if(void 0===s.sha)return A.window.showInformationMessage("File matches the working tree");if(Kt.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await Zo.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:Kt.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,e)}}try{if(i.commit=await Zo.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return Ce.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await Zo.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(Qt.DiffWith,r)}}var Hs,js;!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(Hs||(Hs={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(js||(js={}));class Gs{constructor(e,t){this.uri=e,this.staged=t}}class Vs extends Ei{constructor(){super(Qt.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new Gs(e.resourceUri,e.resourceGroupType===js.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=o.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new Gs(e.resourceUri,e.resourceGroupType===js.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Hs.BOTH_MODIFIED||t===Hs.INDEX_MODIFIED||t===Hs.MODIFIED}async execute(e={}){try{const t=await Zo.git.getRepoPath(void 0);if(!t)return Wi.showNoRepositoryWarningMessage("Unable to open external file compare");const i=await Zo.git.getDiffTool(t);if(void 0===i){if(!await A.window.showWarningMessage("Unable to open external file compare because there is no Git diff tool configured","View Git Docs"))return;return A.commands.executeCommand(W.Open,A.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await Zo.git.getStatusForRepo(t);if(void 0===i)return A.window.showWarningMessage("Unable to open external file compare");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new Gs(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new Gs(t.uri,!1))}for(const s of e.files)Zo.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return Ce.error(e,"ExternalDiffCommand"),A.window.showErrorMessage("Unable to open external file compare. See output channel for more details")}}}class Qs extends Bi{constructor(){super(Qt.OpenChangedFiles)}async execute(e,t,i={}){t=ki(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await Zo.git.getRepoPath(t);if(!e)return Wi.showNoRepositoryWarningMessage("Unable to open changed files");const s=await Zo.git.getStatusForRepo(e);if(void 0===s)return A.window.showWarningMessage("Unable to open changed files");i.uris=o.filterMap(s.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Li(e,{preserveFocus:!0,preview:!1});return}catch(e){return Ce.error(e,"OpenChangedFilesCommand"),A.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class Ks extends Bi{constructor(){super(Qt.OpenBranchesInRemote)}async preExecute(e,t={}){return Pi(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ki(t,e))&&await Ee.fromUri(t),o=void 0===s?Zo.git.getHighlanderRepoPath():s.repoPath;if(o)try{const s=await Zo.git.getRemotes(o);return A.commands.executeCommand(Qt.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:s})}catch(e){return Ce.error(e,"OpenBranchesInRemoteCommand"),A.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class zs extends Bi{constructor(){super(Qt.OpenBranchInRemote)}async preExecute(e,t={}){return _i(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ki(t,e))&&await Ee.fromUri(t),o=void 0===s?Zo.git.getHighlanderRepoPath():s.repoPath;if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=await Zo.git.getBranches(o),t=await ds.show(e,`Show history for branch${G.Ellipsis}`);if(void 0===t)return;if(t instanceof Ki)return;if(i.branch=t.branch.name,void 0===i.branch)return}const s=await Zo.git.getRemotes(o);return A.commands.executeCommand(Qt.OpenInRemote,t,{resource:{type:"branch",branch:i.branch},remote:i.remote,remotes:s})}catch(e){return Ce.error(e,"OpenBranchInRemoteCommandArgs"),A.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class qs extends Bi{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Qt.OpenCommitInRemote,t)}constructor(){super(Qt.OpenCommitInRemote)}async preExecute(e,t={}){return Fi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;const s=await Ee.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=void 0===e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await Zo.git.getBlameForLineContents(s,t,e.document.getText()):await Zo.git.getBlameForLine(s,t);if(void 0===o)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let r=o.commit;r.isUncommitted&&(r=r.with({sha:r.previousSha,fileName:r.previousFileName,previousSha:null,previousFileName:null})),i.sha=r.sha}const o=await Zo.git.getRemotes(s.repoPath);return A.commands.executeCommand(Qt.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return Ce.error(e,"OpenCommitInRemoteCommand"),A.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class Ys extends Bi{constructor(){super(Qt.OpenFileInRemote)}async preExecute(e,t={range:!0}){return Fi(e)?((t=Object.assign({},t)).range=!1,_i(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(void 0===(t=ki(t,e)))return;const s=await Ee.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await Zo.git.getBranch(s.repoPath);void 0!==e&&(i.branch=e.name)}try{const o=await Zo.git.getRemotes(s.repoPath),r=i.range&&void 0!==e?new A.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return A.commands.executeCommand(Qt.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch,fileName:s.getRelativePath(),range:r,sha:s.sha},remotes:o})}catch(e){return Ce.error(e,"OpenFileInRemoteCommand"),A.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class Xs extends Bi{static getMarkdownCommandArgs(e,t,i){let s;return s=e instanceof A.Uri?{uri:e,line:i,annotationType:t}:e,super.getMarkdownCommandArgsCore(Qt.OpenFileRevision,s)}constructor(){super(Qt.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=ki(t,e)))return;const o=await Ee.fromUri(t),r=`Open ${o.getFormattedPath()}${o.sha?` ${w.pad(G.Dot,1,1)} ${o.shortSha}`:""} in revision ${G.Ellipsis}`;s=Ds.showProgress(r);const a=await Zo.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===a)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Ki({label:"$(arrow-right) Show Next Commits",description:`${w.pad(G.Dash,2,3)} shows ${a.maxCount} newer commits`},Qt.OpenFileRevision,[t,Object.assign({},i)]),s=u.last(a.commits.values());null!=s&&(n=new Ki({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(G.Dash,2,3)} shows ${a.maxCount} older commits`},Qt.OpenFileRevision,[new Ee(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await Ds.show(a,o,r,{pickerOnly:!0,progressCancellation:s,currentCommand:new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${G.Space}$(git-commit) ${o.shortSha}`:""}`},Qt.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Ki({label:"$(sync) Show All Commits",description:`${w.pad(G.Dash,2,3)} this may take a while`},Qt.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof is){const e=await h.execute();if(void 0===e)return;if(e instanceof Ki)return e.execute();i.uri=Ee.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof Ki)return h.execute();i.uri=Ee.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new A.Range(i.line,0,i.line,0));const o=await Li(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:Zo.fileAnnotations.show(o,i.annotationType,i.line)}catch(e){return Ce.error(e,"OpenFileRevisionCommand"),A.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.cancel()}}}class Js extends Bi{constructor(){super(Qt.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length)return this.ensureRemoteBranchName(i),new ms(i.remotes[0],i.resource).execute();let t="";switch(i.resource.type){case ie.Branch:this.ensureRemoteBranchName(i),t=`open ${i.resource.branch} branch in${G.Ellipsis}`;break;case ie.Commit:t=`open commit ${Kt.shortenSha(i.resource.sha)} in${G.Ellipsis}`;break;case ie.File:t=`open ${i.resource.fileName} in${G.Ellipsis}`;break;case ie.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof Ge)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,t=`open ${i.resource.fileName} ${w.pad(G.Dot,1,1)} ${i.resource.commit.previousShortSha} in${G.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,t=`open ${i.resource.fileName} ${w.pad(G.Dot,1,1)} ${i.resource.commit.shortSha} in${G.Ellipsis}`);else{const e=void 0===i.resource.sha?"":Kt.shortenSha(i.resource.sha),s=e?` ${w.pad(G.Dot,1,1)} ${e}`:"";t=`open ${i.resource.fileName}${s} in${G.Ellipsis}`}}if(1===i.remotes.length)return new ms(i.remotes[0],i.resource).execute();const s=await gs.show(i.remotes,t,i.resource,i.goBackCommand);if(void 0===s)return;return s.execute()}catch(e){return Ce.error(e,"OpenInRemoteCommand"),A.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class Zs extends Bi{constructor(){super(Qt.OpenRepoInRemote)}async preExecute(e,t={}){return Pi(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ki(t,e))&&await Ee.fromUri(t),o=void 0===s?Zo.git.getHighlanderRepoPath():s.repoPath;if(o)try{const s=await Zo.git.getRemotes(o);return A.commands.executeCommand(Qt.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:s})}catch(e){return Ce.error(e,"OpenRepoInRemoteCommand"),A.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class eo extends Bi{constructor(){super(Qt.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=ki(t,e)))return;if(i.uri=await Ee.fromUri(t),i.uri instanceof Ee&&i.uri.sha){const[e,t]=await Zo.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Ee(A.Uri.file(De.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new A.Range(i.line,0,i.line,0));const s=await Li(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:Zo.fileAnnotations.show(s,i.annotationType,i.line)}catch(e){return Ce.error(e,"OpenWorkingFileCommand"),A.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class to extends Ei{constructor(){super(Qt.ResetSuppressedWarnings)}async execute(){await ir.update(ir.name("advanced")("messages").value,void 0,A.ConfigurationTarget.Global)}}const io=/^([@~=:#])/,so=new Map([["@",Ht.Author],["~",Ht.Changes],["=",Ht.ChangedOccurrences],[":",Ht.Files],["#",Ht.Sha]]);class oo extends Ai{constructor(){super(Qt.ShowCommitSearch)}async execute(e,t,i={}){const s=void 0===(t=ki(t,e))?void 0:await Ee.fromUri(t);let o=void 0===s?Zo.git.getHighlanderRepoPath():s.repoPath;if(!o){const e=await _s.show(`Search for commits in which repository${G.Ellipsis}`,i.goBackCommand);if(e instanceof Ki)return e.execute();if(void 0===e)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();o=e.repoPath}i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&void 0!==e&&void 0!==s){const t=await Zo.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){Ce.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await A.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=io.exec(i.search);t&&t[1]?(i.searchBy=so.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):Kt.isSha(i.search)?i.searchBy=Ht.Sha:i.searchBy=Ht.Message}void 0===i.searchBy&&(i.searchBy=Ht.Message);let a=void 0;switch(i.searchBy){case Ht.Author:a=`commits with an author matching '${i.search}'`;break;case Ht.Changes:a=`commits with changes matching '${i.search}'`;break;case Ht.ChangedOccurrences:a=`commits with changed occurrences matching '${i.search}'`;break;case Ht.Files:a=`commits with files matching '${i.search}'`;break;case Ht.Message:a=`commits with a message matching '${i.search}'`;break;case Ht.Sha:a=`commits with an id matching '${i.search}'`}const n=Ss.showProgress(a);try{const s=await Zo.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const h=i.goBackCommand||new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to commit search`},Qt.ShowCommitSearch,[t,r]),c=await Ss.show(s,a,n,{goBackCommand:h,showAllCommand:void 0!==s&&s.truncated?new Ki({label:"$(sync) Show All Commits",description:`${w.pad(G.Dash,2,3)} this may take a while`},Qt.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:h})]):void 0,showInResultsExplorerCommand:void 0!==s?new ts(s,a):void 0});if(void 0===c)return;return c instanceof Ki?c.execute():A.commands.executeCommand(Qt.ShowQuickCommitDetails,c.commit.toGitUri(),{sha:c.commit.sha,commit:c.commit,goBackCommand:new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,2)} to search for ${a}`},Qt.ShowCommitSearch,[t,i])})}catch(e){return Ce.error(e,"ShowCommitSearchCommand"),A.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.cancel()}}}class ro extends Ei{constructor(){super(Qt.ShowLastQuickPick)}async execute(){const e=Ni;if(void 0!==e)try{return A.commands.executeCommand(e.command,...e.args)}catch(e){return Ce.error(e,"ShowLastQuickPickCommand"),A.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class ao extends Ai{constructor(){super(Qt.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=ki(t,e))&&await Ee.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:ps.showProgress(i.branch);try{const r=void 0===s?Zo.git.getHighlanderRepoPath():s.repoPath;if(!r)return Wi.showNoRepositoryWarningMessage("Unable to show branch history");if(void 0===i.branch){const e=await Zo.git.getBranches(r),t=await ds.show(e,`Show history for branch${G.Ellipsis}`);if(void 0===t)return;if(t instanceof Ki)return t.execute();if(i.branch=t.branch.name,void 0===i.branch)return;o=ps.showProgress(i.branch)}if(void 0===i.log&&(i.log=await Zo.git.getLog(r,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return A.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const a=await ps.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===a)return;if(a instanceof Ki)return a.execute();const n=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${i.branch} history`},Qt.ShowQuickBranchHistory,[t,Object.assign({},i)]);return A.commands.executeCommand(Qt.ShowQuickCommitDetails,a.commit.toGitUri(),{sha:a.commit.sha,commit:a.commit,repoLog:i.log,goBackCommand:n})}catch(e){return Ce.error(e,"ShowQuickBranchHistoryCommand"),A.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.cancel()}}}class no extends Ai{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Qt.ShowQuickCommitDetails,t)}constructor(){super(Qt.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Fi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;const s=await Ee.fromUri(t);let o=s.repoPath,r=De.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const a=await Zo.git.getBlameForLine(s,t);if(void 0===a)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(a.commit.isUncommitted)return Wi.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=a.commit.sha,o=a.commit.repoPath,r=a.commit.fileName,i.commit=a.commit}catch(e){return Ce.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await Zo.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Wi.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Wi.showCommitNotFoundWarningMessage("Unable to show commit details");void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand&&(i.goBackCommand=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to branch history`},Qt.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]));const s=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to details of ${G.Space}$(git-commit) ${i.commit.shortSha}`},Qt.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),a=await $s.show(i.commit,t,i.goBackCommand,s,i.repoLog);if(void 0===a)return;return a instanceof bs?A.commands.executeCommand(Qt.ShowQuickCommitFileDetails,a.commit.toGitUri(),{commit:a.commit,sha:a.sha,goBackCommand:s}):a.execute()}catch(e){return Ce.error(e,"ShowQuickCommitDetailsCommand"),A.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class ho extends Ai{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Qt.ShowQuickCommitFileDetails,t)}constructor(){super(Qt.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Fi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Ee.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const r=await Zo.git.getBlameForLine(o,t);if(void 0===r)return Wi.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(r.commit.isUncommitted)return Wi.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=r.commit.sha,i.commit=r.commit,s=De.relative(i.commit.repoPath,o.fsPath)}catch(e){return Ce.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await Zo.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Wi.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Wi.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await Zo.git.findWorkingFileName(i.commit);const r=Kt.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to details of ${G.Space}$(git-commit) ${r}`},Qt.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const a=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to details of ${G.Space}$(file-text) ${De.basename(i.commit.fileName)} in ${G.Space}$(git-commit) ${r}`},Qt.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await Cs.show(i.commit,t,i.goBackCommand,a,i.fileLog);if(void 0===n)return;return n instanceof Ki?n.execute():void 0}catch(e){return Ce.error(e,"ShowQuickCommitFileDetailsCommand"),A.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class co extends Ai{constructor(){super(Qt.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=ki(t,e);try{const s=await Zo.git.getRepoPath(t);if(!s)return Wi.showNoRepositoryWarningMessage("Unable to show branch history");const o=await Zo.git.getBranch(s);if(void 0===o)return;return A.commands.executeCommand(Qt.ShowQuickBranchHistory,t,{branch:o.name,goBackCommand:i.goBackCommand})}catch(e){return Ce.error(e,"ShowQuickCurrentBranchHistoryCommand"),A.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class lo extends Ai{constructor(){super(Qt.ShowQuickFileHistory)}async execute(e,t,i={}){if(void 0===(t=ki(t,e)))return A.commands.executeCommand(Qt.ShowQuickCurrentBranchHistory);const s=await Ee.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${w.pad(G.Dot,1,1)} ${s.shortSha}`:""}`,r=Ds.showProgress(o);try{if(void 0===i.log&&(i.log=await Zo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Wi.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let a=void 0;if(i.log.truncated){const e=new Ki({label:"$(arrow-right) Show Next Commits",description:`${w.pad(G.Dash,2,3)} shows ${i.log.maxCount} newer commits`},Qt.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),o=u.last(i.log.commits.values());null!=o&&(a=new Ki({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(G.Dash,2,3)} shows ${i.log.maxCount} older commits`},Qt.ShowQuickFileHistory,[new Ee(t,o),Object.assign({},i,{log:void 0,nextPageCommand:e})]))}const n=await Ds.show(i.log,s,o,{progressCancellation:r,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:a,showAllCommand:void 0!==i.log&&i.log.truncated?new Ki({label:"$(sync) Show All Commits",description:`${w.pad(G.Dash,2,3)} this may take a while`},Qt.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new es(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===n)return;if(n instanceof Ki)return n.execute();const h=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${De.basename(n.commit.fileName)}${s.sha?` from ${G.Space}$(git-commit) ${s.shortSha}`:""}`},Qt.ShowQuickFileHistory,[t,i]);return A.commands.executeCommand(Qt.ShowQuickCommitFileDetails,n.commit.toGitUri(),{commit:n.commit,fileLog:i.log,sha:n.commit.sha,goBackCommand:h})}catch(e){return Ce.error(e,"ShowQuickFileHistoryCommand"),A.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.cancel()}}}class mo extends Ai{constructor(){super(Qt.ShowQuickRepoStatus)}async execute(e,t,i={}){t=ki(t,e);try{const s=await Zo.git.getRepoPath(t);if(!s)return Wi.showNoRepositoryWarningMessage("Unable to show repository status");const o=await Zo.git.getStatusForRepo(s);if(void 0===o)return A.window.showWarningMessage("Unable to show repository status");const r=await Rs.show(o,i.goBackCommand);if(void 0===r)return;return r instanceof Ki?r.execute():void 0}catch(e){return Ce.error(e,"ShowQuickRepoStatusCommand"),A.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class uo extends Ai{constructor(){super(Qt.ShowQuickStashList)}async execute(e,t,i={}){t=ki(t,e);const s=Ts.showProgress("list");try{const o=await Zo.git.getRepoPath(t);if(!o)return Wi.showNoRepositoryWarningMessage("Unable to show stashed changes");const r=await Zo.git.getStashList(o);if(void 0===r)return A.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const a=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to stashed changes`},Qt.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),n=await Ts.show(r,"list",s,i.goBackCommand,a);if(void 0===n)return;return n instanceof Ki?n.execute():A.commands.executeCommand(Qt.ShowQuickCommitDetails,n.commit.toGitUri(),{commit:n.commit,sha:n.commit.sha,goBackCommand:a})}catch(e){return Ce.error(e,"ShowQuickStashListCommand"),A.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.cancel()}}}class go extends Ei{constructor(){super(Qt.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return Fi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await Zo.git.getActiveRepoPath();if(!i){const s=await _s.show(`Apply stashed changes from which repository${G.Ellipsis}`,e.goBackCommand);if(s instanceof Ki)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to pick another repository`},Qt.StashApply,[e]),i=s.repoPath}const s=Ts.showProgress("apply");try{const o=await Zo.git.getStashList(i);if(void 0===o)return A.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const r=new Ki({label:`go back ${G.ArrowBack}`,description:`${w.pad(G.Dash,2,3)} to apply stashed changes`},Qt.StashApply,[e]),a=await Ts.show(o,"apply",s,t||e.goBackCommand,r);if(a instanceof Ki)return a.execute();if(void 0===a)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=a.commit}finally{s.cancel()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${G.Ellipsis}`:e.stashItem.message,i=await A.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await Zo.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return Ce.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?A.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?A.window.showInformationMessage("Stash applied with conflicts"):A.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class po extends Ei{constructor(){super(Qt.StashDelete)}async preExecute(e,t={confirm:!0}){return Fi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${G.Ellipsis}`:e.stashItem.message,i=await A.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await Zo.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return Ce.error(e,"StashDeleteCommand"),A.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class fo extends Ei{constructor(){super(Qt.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await Zo.git.getHighlanderRepoPath();if(!t){const i=await _s.show(`Stash changes for which repository${G.Ellipsis}`,e.goBackCommand);if(i instanceof Ki)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await A.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await Zo.git.stashSave(t,e.message,e.uris)}catch(e){return Ce.error(e,"StashSaveCommand"),A.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class vo extends Ei{constructor(){super(Qt.ToggleCodeLens)}execute(){return Zo.codeLens.toggleCodeLens()}}class wo extends Bi{constructor(){super(Qt.ToggleFileBlame)}async execute(e,t,i={}){if(void 0!==e&&void 0!==t&&!ee.equals(t,e.document.uri)){const i=A.window.visibleTextEditors.find(e=>ee.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:F.Blame})),Zo.fileAnnotations.toggle(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return Ce.error(e,"ToggleFileBlameCommand"),A.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Co extends Bi{constructor(){super(Qt.ToggleFileHeatmap)}async execute(e,t){A.commands.executeCommand(Qt.ToggleFileBlame,t,{type:F.Heatmap})}}class bo extends Bi{constructor(){super(Qt.ToggleFileRecentChanges)}async execute(e,t){A.commands.executeCommand(Qt.ToggleFileBlame,t,{type:F.RecentChanges})}}class yo extends Bi{constructor(){super(Qt.ToggleLineBlame)}async execute(e,t){try{return Zo.lineAnnotations.toggle(e)}catch(e){return Ce.error(e,"ToggleLineBlameCommand"),A.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const xo=/[`\>\#\*\_\-\+\.]/g;class $o{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=h.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${G.MuchGreaterThan}\`](${Us.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===F.RecentChanges&&(i=F.Blame);const t=Ee.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${G.SquareWithTopShadow}\`](${Xs.getMarkdownCommandArgs(t,i||F.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${G.ArrowUpRight}\`](${qs.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+`[\`${G.MiddleEllipsis}\`](${ho.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s,o=0){null===t&&(t="MMMM Do, YYYY h:mma");let r="",a="",n="";if(e.isUncommitted)n=`\`${"working"===e.shortSha?"00000000":e.shortSha}\``;else{a=`\n\n${this.getHoverCommandBar(e,0!==i.length,s,o)}`,n=`[\`${e.shortSha}\`](${no.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,r=e.message;for(const e of i)if(void 0!==e.provider){r=e.provider.enrichMessage(r);break}r.replace(xo,"\\$&").replace(/^===/gm,`${G.ZeroWidthSpace}===`).replace(/\n/g,"  \n"),r=`\n\n> ${r}`}const h=new A.MarkdownString(`${n} &nbsp; ![](${e.getGravatarUri(Zo.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${r}${a}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&Kt.isStagedUncommitted(t.sha)?`[\`Changes\`](${Us.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; [\`${e.previousShortSha}\`](${no.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${G.ArrowLeftRightLong} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Us.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; _uncommitted changes_\n${s}`:`[\`Changes\`](${Us.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; [\`${e.previousShortSha}\`](${no.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${G.ArrowLeftRightLong} [\`${e.shortSha}\`](${no.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const r=new A.MarkdownString(o);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&Kt.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await Zo.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const r=Mt.fromTemplate(t,e,i);return o.renderOptions.before.contentText=w.pad(r.replace(/ /g,G.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let r=0;for(const e of s.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){r=-1;break}r+=e.truncateTo}r>=0&&(r+=w.width(w.interpolate(i,void 0)))>0&&(r+=3);let a=void 0,n=void 0;return t.enabled&&(a="solid",n="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new A.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:a,borderWidth:n,color:new A.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:r>=0?`${r}ch`:void 0,uncommittedColor:new A.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return $o.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:G.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i,s=!0){const o=Mt.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new A.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new A.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:w.pad(o.replace(/ /g,G.Space),1,1),fontWeight:"normal",fontStyle:"normal",textDecoration:`none;${s?"":" position: absolute;"}`}}}}}class So extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?Zo.git.getBlameForFileContents(this._uri,e.document.getText()):Zo.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?Zo.git.getBlameForFileContents(this._uri,this.editor.document.getText()):Zo.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=u.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=o.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new A.Range(e.line,0,e.line,M)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!Zo.config.hovers.enabled||!Zo.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(A.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(A.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=A.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await Zo.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const r=$o.getHoverMessage(o||s,Zo.config.defaultDateFormat,await Zo.git.getRemotes(s.repoPath),this.annotationType,this.editor.selection.active.line);return new A.Hover(r,e.validateRange(new A.Range(t.line,0,t.line,M)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await $o.changesHover(s,t.line,await Ee.fromUri(e.uri));return new A.Hover(o.hoverMessage,e.validateRange(new A.Range(t.line,0,t.line,M)))}async getCommitForHover(e){if("line"!==Zo.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class Do extends So{async onProvideAnnotation(e,t){this.annotationType=F.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),r=Zo.config.blame,a=w.getTokensFromTemplate(r.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===r.dateFormat?Zo.config.defaultDateFormat:r.dateFormat,tokenOptions:a},h=Date.now(),c=r.avatars,l=Zo.config.defaultGravatarsStyle,d=r.separateLines,m=$o.gutterRenderOptions(d,r.heatmap,r.format,n);this.decorations=[];const u=Object.create(null),g=c?Object.create(null):void 0;let p,f,v,C=!1;for(const e of i.lines){const t=e.line;v!==e.sha?(C=!1,v=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=u[e.sha])?(f=$o.gutter(p,r.format,n,m),r.heatmap.enabled&&$o.applyHeatmap(f,p.date,h),f.range=new A.Range(t,0,t,0),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g),u[e.sha]=f):(f=Object.assign({},f,{range:new A.Range(t,0,t,0)}),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g)))):(f=Object.assign({},f),r.compact&&!C&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:G.Space.repeat(w.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),C=!0),f.range=new A.Range(t,0,t,0),this.decorations.push(f),c&&!r.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),c)){this.additionalDecorations=[];for(const e of s.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const b=process.hrtime(o);return Ce.log(`${1e3*b[0]+Math.floor(b[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(Zo.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:A.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class ko extends So{async onProvideAnnotation(e,t){this.annotationType=F.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),r=$o.heatmapRenderOptions();this.decorations=[];const a=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=a[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=$o.heatmap(n,o,r)).range=new A.Range(t,0,t,0),this.decorations.push(h),a[e.sha]=h):(h=Object.assign({},h,{range:new A.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return Ce.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(Zo.config.hovers.annotations),this.selection(e,i),!0}}class _o extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=F.RecentChanges;const t=await Zo.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await Zo.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=Zo.config,r=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new A.Range(new A.Position(i,0),new A.Position(i,M)));let a=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:$o.getHoverMessage(t,r,await Zo.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),o.hovers.annotations.changes&&(a=$o.getHoverDiffMessage(t,this._uri,s))),this.decorations.push({hoverMessage:a,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const a=process.hrtime(s);return Ce.log(`${1e3*a[0]+Math.floor(a[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var Fo;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(Fo||(Fo={}));const Po={blameAnnotation:A.window.createTextEditorDecorationType({rangeBehavior:A.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:A.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class Ro extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new A.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=A.Disposable.from(ir.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(ir.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),Po.blameAnnotation&&Po.blameAnnotation.dispose(),Po.blameHighlight&&Po.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ir.initializing(e),i=Zo.config;if(t||ir.changed(e,ir.name("blame")("highlight").value)){Po.blameHighlight&&Po.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?Po.blameHighlight=A.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:A.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new A.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new A.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?Zo.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?Zo.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):Po.blameHighlight=void 0}if(t||ir.changed(e,ir.name("recentChanges")("highlight").value)){Po.recentChangesAnnotation&&Po.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;Po.recentChangesAnnotation=A.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:A.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new A.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new A.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?Zo.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?Zo.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||ir.changed(e,ir.name("blame")("toggleMode").value))&&(this._toggleModes.set(F.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==y.File||this.clearAll()),(t||ir.changed(e,ir.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(F.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==y.File||this.clearAll()),(t||ir.changed(e,ir.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(F.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==y.File||this.clearAll()),!t&&(ir.changed(e,ir.name("blame").value)||ir.changed(e,ir.name("recentChanges").value)||ir.changed(e,ir.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===F.RecentChanges?e.reset({decoration:Po.recentChangesAnnotation,highlightDecoration:Po.recentChangesHighlight}):e.annotationType===F.Blame?e.reset({decoration:Po.blameAnnotation,highlightDecoration:Po.blameHighlight}):this.show(e.editor,F.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!z(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.show(e,this._annotationType);const t=this.getProvider(e);void 0===t?(Q(H.AnnotationStatus,void 0),this.detachKeyboardHook()):(Q(H.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=A.window.activeTextEditor;void 0!==t&&this.clear(t,Fo.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,Fo.DocumentChanged)}onTextDocumentClosed(e){if(Zo.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,Fo.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=u.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,Fo.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===y.Window}getToggleMode(e){return void 0===e?y.File:this._toggleModes.get(e)||y.File}clear(e,t=Fo.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(se.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,Fo.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await Zo.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(se.getCorrelationKey(e))}async show(e,t,i){if(this.getToggleMode(t)===y.Window){let i=void 0===this._annotationType;const s=!i&&this._annotationType!==t;if(this._annotationType=t,s&&(await this.clearAll(),i=!0),i)for(const i of A.window.visibleTextEditors)i!==e&&this.show(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await Zo.tracker.getOrAdd(e.document)).isBlameable)return!1;const s=this.getProvider(e);return void 0!==s&&s.annotationType===t?(await s.selection(i),!0):void 0!==await A.window.withProgress({location:A.ProgressLocation.Window},async o=>{await Q(H.AnnotationStatus,te.Computing);const r=this.showAnnotationsCore(s,e,t,i,o),a=await r;return e===this._editor&&await Q(H.AnnotationStatus,a&&a.status),r})}async toggle(e,t,i){if(void 0!==e){const i=await Zo.tracker.getOrAdd(e.document);if(t===F.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.show(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,Fo.User),!!o&&this.show(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await Zo.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,Fo.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(Ce.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==se.getCorrelationKey(this._editor)||(await Q(H.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(Ce.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case F.Blame:e="blame annotations";break;case F.Heatmap:e="heatmap annotations";break;case F.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${De.basename(t.document.fileName)}`})}this.attachKeyboardHook();const r=await Zo.tracker.getOrAdd(t.document);let a=void 0;switch(i){case F.Blame:a=new Do(t,r,Po.blameAnnotation,Po.blameHighlight);break;case F.Heatmap:a=new ko(t,r,Po.heatmapAnnotation,Po.heatmapHighlight);break;case F.RecentChanges:a=new _o(t,r,Po.recentChangesAnnotation,Po.recentChangesHighlight)}if(void 0!==a&&await a.validate())return void 0!==e&&await this.clearCore(e.correlationKey,Fo.User),this._annotationsDisposable||0!==this._annotationProviders.size||(Ce.log("Add listener registrations for annotations"),this._annotationsDisposable=A.Disposable.from(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,50),this),A.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),A.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleTextEditorsChanged,50),this),A.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),Zo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Zo.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(a.correlationKey,a),await a.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),a):void 0}}class To extends A.CodeLens{constructor(e,t,i,s,o,r,a,n){super(r,n),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame&&this.blame()}}class Eo extends A.CodeLens{constructor(e,t,i,s,o,r,a){super(r),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame()}}class Bo{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new A.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=ir.get(ir.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=ir.get(ir.name("codeLens").value,e.uri);let r=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==r?r={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}:(void 0===r.scopes&&(r.scopes=o.scopes),void 0===r.symbolScopes&&(r.symbolScopes=o.symbolScopes)),r.symbolScopes=null!=r.symbolScopes?r.symbolScopes=r.symbolScopes.map(e=>e.toLowerCase()):[];const a=[],n=i.uri;let h,c;if(s)1===r.scopes.length&&r.scopes.includes($.Document)||(c=await A.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return a;if(1===r.scopes.length&&r.scopes.includes($.Document)?h=e.isDirty?await this._git.getBlameForFileContents(n,e.getText()):await this._git.getBlameForFile(n):[h,c]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(n,e.getText()):this._git.getBlameForFile(n),A.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri)]),void 0===h||0===h.lines.length)return a}if(t.isCancellationRequested)return a;const l=m.once(()=>e.validateRange(new A.Range(0,1e6,1e6,1e6))),d=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==c&&(Ce.log("GitCodeLensProvider.provideCodeLenses:",`${c.length} symbol(s) found`),c.forEach(t=>this.provideCodeLens(a,e,t,r,l,h,n,o,s,d))),(r.scopes.includes($.Document)||r.symbolScopes.includes("file"))&&!r.symbolScopes.includes("!file")&&!a.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=l();let t=void 0;(s||o.recentChange.enabled)&&(s||(t=m.once(()=>this._git.getBlameForRangeSync(h,n,e))),a.push(new To(A.SymbolKind.File,n,t,e,!0,new A.Range(0,0,0,e.start.character),o.recentChange.command,d))),!s&&o.authors.enabled&&(void 0===t&&(t=m.once(()=>this._git.getBlameForRangeSync(h,n,e))),a.push(new Eo(A.SymbolKind.File,n,t,e,!0,new A.Range(0,1,0,e.start.character),o.authors.command)))}return a}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const r=A.SymbolKind[e.kind].toLowerCase();switch(e.kind){case A.SymbolKind.File:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&(s=i());break;case A.SymbolKind.Package:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case A.SymbolKind.Class:case A.SymbolKind.Interface:case A.SymbolKind.Module:case A.SymbolKind.Namespace:case A.SymbolKind.Struct:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;case A.SymbolKind.Constructor:case A.SymbolKind.Enum:case A.SymbolKind.Function:case A.SymbolKind.Method:(t.scopes.includes($.Blocks)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;default:t.symbolScopes.includes(r)&&(o=!t.symbolScopes.includes(`!${r}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,r,a,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let u,g=0;if((h||n.recentChange.enabled)&&(h||(u=m.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new To(i.kind,a,u,l,!1,d.range.with(new A.Position(d.range.start.line,g)),n.recentChange.command,c)),g++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case A.SymbolKind.File:break;case A.SymbolKind.Package:case A.SymbolKind.Module:case A.SymbolKind.Namespace:case A.SymbolKind.Class:case A.SymbolKind.Interface:case A.SymbolKind.Constructor:case A.SymbolKind.Method:case A.SymbolKind.Function:case A.SymbolKind.Enum:s=!0}s&&!h&&(void 0===u&&(u=m.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Eo(i.kind,a,u,l,!1,d.range.with(new A.Position(d.range.start.line,g)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof To?this.resolveGitRecentChangeCodeLens(e,t):e instanceof Eo?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=u.first(i.commits.values());let o=`${s.author}, ${s.formattedDate}`;switch(Zo.config.debug&&(o+=` [${A.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i,s);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i,s);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i,s);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i,s);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i,s);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let o=`${s} ${s>1?"authors":"author"} (${u.first(i.authors.values()).name}${s>1?" and others":""})`;switch(Zo.config.debug&&(o+=` [${A.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${u.join(u.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:Qt.DiffWithPrevious,arguments:[A.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitDetails,arguments:[A.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitFileDetails,arguments:[A.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickCurrentBranchHistory,arguments:[A.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickFileHistory,arguments:[A.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:Qt.ToggleFileBlame,arguments:[A.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?ir.get(ir.name("strings")("codeLens")("unsavedChanges")("recentChangeAndAuthors").value):e.recentChange.enabled?ir.get(ir.name("strings")("codeLens")("unsavedChanges")("recentChangeOnly").value):ir.get(ir.name("strings")("codeLens")("unsavedChanges")("authorsOnly").value)}}Bo.selector=[{scheme:j.File},{scheme:j.Git},{scheme:j.GitLensGit}];class No extends A.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=A.Disposable.from(ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ir.initializing(e),i=ir.name("codeLens").value;if(t||ir.changed(e,i,null)||ir.changed(e,ir.name("defaultDateStyle").value)||ir.changed(e,ir.name("defaultDateFormat").value)){t||Ce.log("CodeLens config changed; resetting CodeLens provider");const e=ir.get(i);e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,Q(H.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(Ce.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=ir.get(ir.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||(Ce.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(Ce.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new Bo(Zo.context,Zo.git,Zo.tracker),this._providerDisposable=A.Disposable.from(A.languages.registerCodeLensProvider(Bo.selector,this._provider),Zo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Zo.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}const Ao=A.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:A.DecorationRangeBehavior.ClosedOpen});class Uo extends A.Disposable{constructor(){super(()=>this.dispose()),this._enabled=!1,this._disposable=A.Disposable.from(ir.onDidChange(this.onConfigurationChanged,this),Zo.fileAnnotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),A.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),Zo.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ir.initializing(e);(t||ir.changed(e,ir.name("currentLine").value))&&((t||ir.changed(e,ir.name("currentLine")("enabled").value))&&(ir.get().currentLine.enabled?(this._enabled=!0,Zo.lineTracker.start(this,A.Disposable.from(Zo.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))):(this._enabled=!1,Zo.lineTracker.stop(this))),this.refresh(A.window.activeTextEditor))}get suspended(){return!this._enabled||void 0!==this._suspended}resume(e="user"){switch(e){case"debugging":if("user"!==this._suspended)return this._suspended=void 0,!0;break;case"user":if(void 0!==this._suspended)return this._suspended=void 0,!0}return!1}suspend(e="user"){return"user"!==this._suspended&&(this._suspended=e,!0)}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor):this.refresh(e.editor)}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=A.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this)),this.suspend("debugging")&&this.refresh(A.window.activeTextEditor)}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resume("debugging")&&this.refresh(A.window.activeTextEditor)}onFileAnnotationsToggled(){this.refresh(A.window.activeTextEditor)}async clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e)}async toggle(e){this._enabled=!(this._enabled&&!this.suspended),this._enabled?this.resume("user")&&await this.refresh(e):this.suspend("user")&&await this.refresh(e)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Ao,[])}async refresh(e){if(void 0===e&&void 0===this._editor)return;const t=Zo.lineTracker.lines;if(void 0===e||void 0===t||!z(e))return this.clear(this._editor);this._editor!==e&&(this.clear(this._editor),this._editor=e);const i=Zo.config.currentLine;if(this.suspended)return this.clear(e);if(!(await Zo.tracker.getOrAdd(e.document)).isBlameable&&this.suspended)return this.clear(e);if(void 0===e.document||!Zo.lineTracker.includesAll(t))return;const s=Zo.config.currentLine.scrollable,o=[];for(const r of t){const t=Zo.lineTracker.getState(r);if(void 0===t||void 0===t.commit)continue;const a=$o.trailing(t.commit,i.format,null===i.dateFormat?Zo.config.defaultDateFormat:i.dateFormat,s);a.range=e.document.validateRange(new A.Range(r,M,r,M)),o.push(a)}e.setDecorations(Ao,o)}}class Lo extends A.Disposable{constructor(){super(()=>this.dispose()),this._disposable=A.Disposable.from(ir.onDidChange(this.onConfigurationChanged,this),A.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}dispose(){this.unregister(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),Zo.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){if(!ir.initializing(e)&&!ir.changed(e,ir.name("hovers")("enabled").value)&&!ir.changed(e,ir.name("hovers")("currentLine")("enabled").value))return;const t=ir.get();t.hovers.enabled&&t.hovers.currentLine.enabled?(Zo.lineTracker.start(this,A.Disposable.from(Zo.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))),this.register(A.window.activeTextEditor)):(Zo.lineTracker.stop(this),this.unregister())}get debugging(){return void 0!==this._debugSessionEndDisposable}onActiveLinesChanged(e){e.pending||"editor"!==e.reason||(void 0!==e.editor&&void 0!==e.lines?this.register(e.editor):this.unregister())}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=A.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0)}async provideDetailsHover(e,t,i){if(!Zo.lineTracker.includes(t.line))return;const s=Zo.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;const r=await Zo.fileAnnotations.getAnnotationType(A.window.activeTextEditor);if(void 0!==r&&Zo.config.hovers.annotations.details)return;const a=!this.debugging&&"line"===Zo.config.hovers.currentLine.over;if(!a&&Zo.lineAnnotations.suspended)return;const n=e.validateRange(new A.Range(t.line,a?0:M,t.line,M));if(!a&&n.start.character!==t.character)return;let h=void 0!==s?s.logCommit:void 0;if(void 0!==h||o.isUncommitted||void 0!==(h=await Zo.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(h.previousSha=o.previousSha,h.previousFileName=o.previousFileName,void 0!==s&&(s.logCommit=h)),void 0===await Zo.tracker.get(e))return;const c=$o.getHoverMessage(h||o,Zo.config.defaultDateFormat,await Zo.git.getRemotes(o.repoPath),r,t.line);return new A.Hover(c,n)}async provideChangesHover(e,t,i){if(!Zo.lineTracker.includes(t.line))return;const s=Zo.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;if(Zo.config.hovers.annotations.changes&&void 0!==await Zo.fileAnnotations.getAnnotationType(A.window.activeTextEditor))return;const r=!this.debugging&&"line"===Zo.config.hovers.currentLine.over;if(!r&&Zo.lineAnnotations.suspended)return;const a=e.validateRange(new A.Range(t.line,r?0:M,t.line,M));if(!r&&a.start.character!==t.character)return;const n=await Zo.tracker.get(e);if(void 0===n)return;const h=await $o.changesHover(o,t.line,n.uri);return void 0!==h.hoverMessage?new A.Hover(h.hoverMessage,a):void 0}register(e){if(this.unregister(),void 0===e)return;const t=Zo.config.hovers;if(!t.enabled||!t.currentLine.enabled||!t.currentLine.details&&!t.currentLine.changes)return;const i=[];t.currentLine.changes&&i.push(A.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.currentLine.details&&i.push(A.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=A.Disposable.from(...i)}unregister(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}}class Oo extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new A.EventEmitter,this._onDidChangeTreeData=new A.EventEmitter,Zo.explorerCommands,A.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),A.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),A.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(_.Auto),this),A.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(_.List),this),A.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(_.Tree),this),A.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(Zo.config.gitExplorer.autoRefresh,!0),this),A.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(Zo.config.gitExplorer.autoRefresh,!1),this),A.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>Oo.setRenameFollowing(!0),this),A.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>Oo.setRenameFollowing(!1),this),A.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(P.History),this),A.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(P.Repository),this),A.commands.registerCommand("gitlens.gitExplorer.undockHistory",this.undockHistory,this),Zo.context.subscriptions.push(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this),A.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleEditorsChanged,500),this),ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ir.initializing(e);if(!(t||ir.changed(e,ir.name("gitExplorer").value)||ir.changed(e,ir.name("explorers").value)||ir.changed(e,ir.name("defaultGravatarsStyle").value)||ir.changed(e,ir.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||ir.changed(e,ir.name("gitExplorer")("enabled").value))&&Q(H.GitExplorer,this.config.enabled),(t||ir.changed(e,ir.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(Zo.config.gitExplorer.autoRefresh);let i=this.view;if((t||ir.changed(e,ir.name("gitExplorer")("view").value))&&((i=this.config.view)===P.Auto&&(i=Zo.context.workspaceState.get(Y.GitExplorerView,P.Repository)),t))return this.view=i,Q(H.GitExplorerView,this.view),this.setRoot(await this.getRootNode(A.window.activeTextEditor)),void(this._disposable=A.window.registerTreeDataProvider("gitlens.gitExplorer",this));this.reset(i,ir.changed(e,ir.name("advanced")("fileHistoryFollowsRenames").value))}async onActiveEditorChanged(e){if(this.view!==P.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(jt.ActiveEditorChanged,t)}onRepositoriesChanged(){this.view===P.Repository&&(this.clearRoot(),Ce.log(`GitExplorer[view=${this.view}].onRepositoriesChanged`),this.refresh(jt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this.view===P.History&&(0!==e.length&&e.some(e=>e.document&&Zo.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(jt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&Zo.context.workspaceState.get(Y.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},Zo.config.explorers,Zo.config.gitExplorer)}get view(){return this._view}set view(e){this._view=Zo.config.historyExplorer.enabled?P.Repository:e}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this.view===P.History?[new Yt(`No active file ${G.Dash} no history to show`)]:[new Yt("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=jt.Command),Ce.log(`GitExplorer[view=${this.view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this.view===P.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(A.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){Ce.log(`GitExplorer[view=${this.view}].refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){this.setView(e),t&&void 0!==this._root&&this.clearRoot(),(this.setRoot(await this.getRootNode(A.window.activeTextEditor))||t)&&this.refresh(jt.ViewChanged)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=Zo.context.workspaceState.get(Y.GitExplorerAutoRefresh,!0):(i=t,await Zo.context.workspaceState.update(Y.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=Zo.git.onDidChangeRepositories(this.onRepositoriesChanged,this),Zo.context.subscriptions.push(this._autoRefreshDisposable))),Q(H.GitExplorerAutoRefresh,e&&t),i&&this.refresh(jt.AutoRefreshChanged)}setView(e){this.view!==e&&(Zo.config.gitExplorer.view===P.Auto&&Zo.context.workspaceState.update(Y.GitExplorerView,e),this.view=e,Q(H.GitExplorerView,this.view),e!==P.Repository&&Zo.git.stopWatchingFileSystem())}async switchTo(e){this.view!==e&&this.reset(e,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){switch(this.view){case P.History:{const t=this.getHistoryNode(e||A.window.activeTextEditor);return this._loading=t.then(e=>m.wait(0)),t}default:{const e=Zo.git.getRepositories();this._loading=e.then(e=>m.wait(0));const t=[...await e];if(0===t.length)return;if(1===t.length){const e=t[0];return new fi(Ee.fromRepoPath(e.path),e,this,!0)}return new Di(t,this)}}}async getHistoryNode(e){return Oo.getHistoryNode(this,e,this._root)}async setFilesLayout(e){return ir.update(ir.name("gitExplorer")("files")("layout").value,e,A.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}async undockHistory(e=!0){Zo.historyExplorer.undock(e)}static async getHistoryNode(e,t,i){if(void 0===t||0===A.window.visibleTextEditors.length||!A.window.visibleTextEditors.some(e=>e.document&&Zo.git.isTrackable(e.document.uri)))return;if(void 0===t.document||!Zo.git.isTrackable(t.document.uri))return i;const s=await Ee.fromUri(t.document.uri),o=await Zo.git.getRepository(s);return void 0!==o?ee.equals(s,i&&i.uri)?i:new Si(s,o,e):void 0}static setRenameFollowing(e){ir.updateEffective(ir.name("advanced")("fileHistoryFollowsRenames").value,e)}}class Io extends A.Disposable{constructor(){super(()=>this.dispose()),A.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),A.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),A.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),A.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),A.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),A.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),A.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),A.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),A.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),A.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),A.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),A.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),A.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),A.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),A.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),A.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),A.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),A.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),A.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),A.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),A.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),A.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),A.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),A.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),A.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),A.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),A.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),A.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),A.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),A.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),A.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await Zo.git.checkoutFile(e.uri),this.openFile(e)}compareWithHead(e){e instanceof qt&&Zo.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&Zo.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof qt&&Zo.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await Zo.git.getBranch(e.repoPath);if(void 0===t)return;const i=await Zo.git.getMergeBase(e.repoPath,t.name,e.ref);void 0!==i&&Zo.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${Kt.shortenSha(i)})`},"")}compareWithSelected(e){void 0!==this._selection&&e instanceof qt&&this._selection.repoPath===e.repoPath&&Zo.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof qt))return;const t=e instanceof si?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},Q(H.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,A.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return A.commands.executeCommand(Qt.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Li(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Li(t.uri||("D"===e.commit.status?Ee.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Ee.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Ee.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:Kt.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Ee.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>Ee.fromFileStatus(e,i));for(const e of s)await Li(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=o.filterMap(e.commit.fileStatuses,t=>Ee.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Li(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return A.commands.executeCommand(Qt.DiffWith,o)}async openFileRevisionInRemote(e){return A.commands.executeCommand(Qt.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){e instanceof si&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof qt))return;let t=!1,i=void 0;e instanceof si&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await A.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});void 0!==s&&""!==s&&this.sendTerminalCommand("branch",`${t?"-t ":""}${s} ${e.ref}`,e.repoPath)}terminalDeleteBranch(e){e instanceof si&&(e.branch.remote?this.sendTerminalCommand("push",`${e.branch.remote} :${e.ref}`,e.repoPath):this.sendTerminalCommand("branch",`-d ${e.ref}`,e.repoPath))}terminalMergeBranch(e){e instanceof si&&this.sendTerminalCommand("merge",`${e.ref}`,e.repoPath)}terminalRebaseBranch(e){e instanceof si&&this.sendTerminalCommand("rebase",`-i ${e.ref}`,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof si){if(!e.branch.current||!e.branch.tracking)return;this.sendTerminalCommand("rebase",`-i ${e.branch.tracking}`,e.repoPath)}else e instanceof ci&&this.sendTerminalCommand("rebase",`-i ${e.status.upstream}`,e.status.repoPath)}terminalSquashBranchIntoCommit(e){e instanceof si&&this.sendTerminalCommand("merge",`--squash ${e.ref}`,e.repoPath)}terminalCherryPickCommit(e){e instanceof ii&&this.sendTerminalCommand("cherry-pick",`-e ${e.ref}`,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof ii))return;const t=e.branch||await Zo.git.getBranch(e.repoPath);void 0!==t&&this.sendTerminalCommand("push",`${t.getRemote()} ${e.ref}:${t.getName()}`,e.repoPath)}terminalRebaseCommit(e){e instanceof ii&&this.sendTerminalCommand("rebase",`-i ${e.ref}^`,e.repoPath)}terminalResetCommit(e){e instanceof ii&&this.sendTerminalCommand("reset",`--soft ${e.ref}^`,e.repoPath)}terminalRevertCommit(e){e instanceof ii&&this.sendTerminalCommand("revert",`-e ${e.ref}`,e.repoPath)}terminalRemoveRemote(e){e instanceof ri&&this.sendTerminalCommand("remote",`remove ${e.remote.name}`,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof qt))return;const t=await A.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await A.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand("tag",s,e.repoPath)}terminalDeleteTag(e){e instanceof gi&&this.sendTerminalCommand("tag",`-d ${e.ref}`,e.repoPath)}ensureTerminal(e){return void 0===this._terminal&&(this._terminal=A.window.createTerminal(O),this._disposable=A.window.onDidCloseTerminal(e=>{e.name===O&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),Zo.context.subscriptions.push(this._disposable),this._terminalCwd=void 0),this._terminalCwd!==e&&(this._terminal.sendText(`cd "${e}"`,!0),this._terminalCwd=e),this._terminal}sendTerminalCommand(e,t,i){const s=this.ensureTerminal(i);s.show(!1),s.sendText(`git ${e} ${t}`,!1)}}class Mo{async provideTextDocumentContent(e,t){const i=Ee.fromRevisionUri(e);if(!i.repoPath||i.sha===Kt.deletedSha)return"";try{return await Zo.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return Ce.error(e,"GitContentProvider","getVersionedFileText"),void A.window.showErrorMessage(`Unable to show Git revision ${Kt.shortenSha(i.sha)} of '${De.relative(i.repoPath,i.fsPath)}'`)}}}Mo.scheme=j.GitLensGit;class Wo extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLines=new A.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||z(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.trigger("editor"))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!z(e.textEditor))return;const t=this._editor===e.textEditor?"selection":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.trigger(t))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return Wo.includesAll(e,this._lines)}refresh(){this.trigger("editor")}reset(){this._state.clear()}start(e,t){void 0===this._disposable&&(this._disposable=A.Disposable.from(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,0),this),A.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(A.window.activeTextEditor)))}stop(e){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}async fireLinesChanged(e){this._onDidChangeActiveLines.fire(e)}trigger(e){this.onLinesChanged({editor:this._editor,lines:this._lines,reason:e})}onLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=m.debounce(e=>{A.window.activeTextEditor===e.editor&&Wo.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this.fireLinesChanged(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this.fireLinesChanged(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{A.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this.fireLinesChanged(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&t.length===e.length&&t.every((t,i)=>t===e[i])}}class Ho{constructor(e,t){this.commit=e,this.logCommit=t}}class jo extends Wo{constructor(){super(...arguments),this._count=0,this._subscriptions=new Map,this._suspended=!1}async fireLinesChanged(e){this.reset();let t=!1;this._suspended||e.pending||void 0===e.lines||void 0===e.editor||(t=await this.updateState(e.lines,e.editor)),super.fireLinesChanged(t?e:Object.assign({},e,{lines:void 0}))}onBlameStateChanged(e){this.trigger("editor")}onDirtyIdleTriggered(e){const t=Zo.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||this.resume()}async onDirtyStateChanged(e){e.dirty?this.suspend():this.resume({force:!0})}async resume(e={}){(e.force||this._suspended)&&(this._suspended=!1,this.trigger("editor"))}async suspend(e={}){!e.force&&this._suspended||(this._suspended=!0,this.trigger("editor"))}start(e,t){this._subscriptions.has(e)||(this._subscriptions.set(e,t),this._count++,1===this._count&&(super.start(),this._disposable=A.Disposable.from(this._disposable,Zo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Zo.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),Zo.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))))}stop(e){const t=this._subscriptions.get(e);void 0!==t&&(this._subscriptions.delete(e),t.dispose(),void 0!==this._disposable?(this._count--,0===this._count&&super.stop()):this._count=0)}async updateState(e,t){const i=await Zo.tracker.getOrAdd(t.document);if(!i.isBlameable||!this.includesAll(e))return!1;if(1===e.length){const s=t.document.isDirty?await Zo.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await Zo.git.getBlameForLine(i.uri,e[0]);if(void 0===s)return!1;this.setState(s.line.line,new Ho(s.commit))}else{const s=t.document.isDirty?await Zo.git.getBlameForFileContents(i.uri,t.document.getText()):await Zo.git.getBlameForFile(i.uri);if(void 0===s)return!1;for(const t of e){const e=s.lines[t];this.setState(t,new Ho(s.commits.get(e.sha)))}}return!(!i.isBlameable||!this.includesAll(e)||(t.document.isDirty&&i.setForceDirtyStateChangeOnNextDocumentChange(),0))}}class Go extends A.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Vo extends A.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Qo{async provideCodeLenses(e,t){const i=Ee.fromRevisionUri(e.uri),s=[],o=await Zo.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new Vo(o.previousUri.fsPath,o,new A.Range(0,0,0,1))),s.push(new Go(o.uri.fsPath,o,new A.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof Go?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof Vo?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:Qt.DiffWithWorking,arguments:[A.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:Qt.DiffWithPrevious,arguments:[A.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}Qo.selector={scheme:j.GitLensGit};class Ko extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeTreeData=new A.EventEmitter,Zo.explorerCommands,A.commands.registerCommand("gitlens.historyExplorer.refresh",this.refresh,this),A.commands.registerCommand("gitlens.historyExplorer.refreshNode",this.refreshNode,this),A.commands.registerCommand("gitlens.historyExplorer.close",()=>this.dock(!1),this),A.commands.registerCommand("gitlens.historyExplorer.dock",this.dock,this),A.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOn",()=>Oo.setRenameFollowing(!0),this),A.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOff",()=>Oo.setRenameFollowing(!1),this),Zo.context.subscriptions.push(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this),A.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleEditorsChanged,500),this),ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ir.initializing(e);(t||ir.changed(e,ir.name("historyExplorer").value)||ir.changed(e,ir.name("explorers").value)||ir.changed(e,ir.name("defaultGravatarsStyle").value)||ir.changed(e,ir.name("advanced")("fileHistoryFollowsRenames").value))&&((t||ir.changed(e,ir.name("historyExplorer")("enabled").value))&&(Zo.config.historyExplorer.enabled?this.undock(!t):this.dock(!t)),t||void 0!==this._root||this.refresh(jt.ConfigurationChanged),t&&(this.setRoot(await this.getRootNode(A.window.activeTextEditor)),this._disposable=A.window.registerTreeDataProvider("gitlens.historyExplorer",this)))}async onActiveEditorChanged(e){const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(jt.ActiveEditorChanged,t)}onVisibleEditorsChanged(e){void 0!==this._root&&(0!==e.length&&e.some(e=>e.document&&Zo.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(jt.VisibleEditorsChanged)))}get config(){return Object.assign({},Zo.config.explorers)}async getChildren(e){return void 0===this._root?[new Yt(`No active file ${G.Dash} no history to show`)]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async dock(e=!0){e&&await Zo.gitExplorer.switchTo(P.History),Q(H.HistoryExplorer,!1),ir.updateEffective(ir.name("historyExplorer")("enabled").value,!1)}getQualifiedCommand(e){return`gitlens.historyExplorer.${e}`}async refresh(e,t){void 0===e&&(e=jt.Command),Ce.log("HistoryExplorer.refresh",`reason='${e}'`),void 0!==this._root&&void 0!==t||(this.clearRoot(),this.setRoot(await this.getRootNode(A.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){Ce.log(`HistoryExplorer.refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._root===e?void 0:e)}async undock(e=!0){e&&await Zo.gitExplorer.switchTo(P.Repository),Q(H.HistoryExplorer,!0),ir.updateEffective(ir.name("historyExplorer")("enabled").value,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){return Oo.getHistoryNode(this,e,this._root)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}}const zo=A.Uri.parse("gitlens://authority/settings"),qo=A.Uri.parse("gitlens://authority/welcome");class Yo extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChange=new A.EventEmitter,this._scope=new Map,this._disposable=A.Disposable.from(A.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),A.workspace.registerTextDocumentContentProvider(zo.scheme,this),A.commands.registerCommand("gitlens.showSettingsPage",this.showSettings,this),A.commands.registerCommand("gitlens.showWelcomePage",this.showWelcome,this),A.commands.registerCommand("gitlens.saveSettings",this.save,this))}get onDidChange(){return this._onDidChange.event}dispose(){this._disposable.dispose()}onTextDocumentClosed(e){this._scope.delete(e.uri.toString())}async provideTextDocumentContent(e){let t=(await A.workspace.openTextDocument(A.Uri.file(Zo.context.asAbsolutePath(`${e.path}.html`)))).getText().replace(/{{root}}/g,A.Uri.file(Zo.context.asAbsolutePath(".")).toString());return t.includes("'{{data}}'")&&(t=t.replace(/'{{data}}'/g,JSON.stringify({config:Zo.config,scope:this.getScope(e),scopes:this.getAvailableScopes(),uri:e.toString()}))),t}getAvailableScopes(){const e=[["user","User Settings"]];return void 0!==A.workspace.workspaceFolders&&A.workspace.workspaceFolders.length&&e.push(["workspace","Workspace Settings"]),e}getScope(e){return this._scope.get(e.toString())||"user"}refresh(e){Ce.log("PageProvider.refresh"),this._onDidChange.fire(e||zo)}async save(e){Ce.log(`PageProvider.save: options=${JSON.stringify(e)}`),this._scope.set(e.uri,e.scope);const t="workspace"===e.scope?A.ConfigurationTarget.Workspace:A.ConfigurationTarget.Global;for(const i in e.changes)(await ir.inspect(i)).defaultValue===e.changes[i]?await ir.update(i,void 0,t):await ir.update(i,e.changes[i],t)}async showSettings(){return await A.commands.executeCommand("vscode.previewHtml",zo,A.ViewColumn.Active,"GitLens Settings")}async showWelcome(){return await A.commands.executeCommand("vscode.previewHtml",qo,A.ViewColumn.Active,"Welcome to GitLens")}}class Xo extends A.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new A.EventEmitter,Zo.explorerCommands,A.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),A.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),A.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(_.Auto),this),A.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(_.List),this),A.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(_.Tree),this),A.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),A.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),A.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),A.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),A.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),Q(H.ResultsExplorerKeepResults,this.keepResults),Zo.context.subscriptions.push(ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ir.initializing(e);(t||ir.changed(e,ir.name("resultsExplorer").value)||ir.changed(e,ir.name("explorers").value)||ir.changed(e,ir.name("defaultGravatarsStyle").value))&&(t||0===this._roots.length||this.refresh(jt.ConfigurationChanged),t&&(this._disposable=A.window.registerTreeDataProvider("gitlens.resultsExplorer",this)))}get config(){return Object.assign({},Zo.config.explorers,Zo.config.resultsExplorer)}get keepResults(){return Zo.context.workspaceState.get(Y.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),Q(H.ResultsExplorer,!1)}async getChildren(e){return 0===this._roots.length?[new Yt("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=jt.Command),Ce.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){Ce.log(`ResultsExplorer.refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){Ce.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}showComparisonInResults(e,t,i){this.addResults(new xi(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)),this.showResults()}showCommitInResults(e){this.addResults(new wi(e,this)),this.showResults()}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.addResults(new Ci(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,r=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let a="";if(await Zo.git.getRepositoryCount()>1){const t=await Zo.git.getRepository(e.repoPath);a=` ${w.pad(G.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${r.singular} for ${t.label}${a}`:`${0===s?"No":`${s}${o?"+":""}`} ${r.plural} for ${t.label}${a}`},m.seeded(i,e),this,Gt.SearchResults)),this.showResults()}async showResults(){await A.commands.executeCommand("workbench.view.explorer"),Wi.showResultExplorerInfoMessage(),Q(H.ResultsExplorer,!0)}addResults(e){return!this._roots.includes(e)&&(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),!0)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return ir.update(ir.name("resultsExplorer")("files")("layout").value,e,A.ConfigurationTarget.Global)}setKeepResults(e){Zo.context.workspaceState.update(Y.ResultsExplorerKeepResults,e),Q(H.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof xi&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class Jo extends A.Disposable{constructor(){super(()=>this.dispose()),this._disposable=A.Disposable.from(ir.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ir.initializingChangeEvent)}dispose(){this.clear(),this._statusBarItem&&this._statusBarItem.dispose(),Zo.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ir.initializing(e);if(!t&&!ir.changed(e,ir.name("statusBar").value))return;const i=ir.get();if(i.statusBar.enabled){const s="left"!==i.statusBar.alignment?A.StatusBarAlignment.Right:A.StatusBarAlignment.Left;ir.changed(e,ir.name("statusBar")("alignment").value)&&void 0!==this._statusBarItem&&this._statusBarItem.alignment!==s&&(this._statusBarItem.dispose(),this._statusBarItem=void 0),this._statusBarItem=this._statusBarItem||A.window.createStatusBarItem(s,s===A.StatusBarAlignment.Right?1e3:0),this._statusBarItem.command=i.statusBar.command,(t||ir.changed(e,ir.name("statusBar")("enabled").value))&&Zo.lineTracker.start(this,A.Disposable.from(Zo.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))}else ir.changed(e,ir.name("statusBar")("enabled").value)&&(Zo.lineTracker.stop(this),void 0!==this._statusBarItem&&(this._statusBarItem.dispose(),this._statusBarItem=void 0))}onActiveLinesChanged(e){let t=!(Zo.config.statusBar.reduceFlicker&&"selection"===e.reason&&(e.pending||void 0!==e.lines));if(!e.pending&&void 0!==e.lines){const i=Zo.lineTracker.getState(e.lines[0]);if(void 0!==i&&void 0!==i.commit)return void this.updateStatusBar(i.commit,e.editor);t=!0}t&&this.clear()}async clear(){void 0!==this._statusBarItem&&this._statusBarItem.hide()}updateStatusBar(e,t){const i=Zo.config.statusBar;if(i.enabled&&void 0!==this._statusBarItem&&z(t)){switch(this._statusBarItem.text=`$(git-commit) ${Mt.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?Zo.config.defaultDateFormat:i.dateFormat})}`,i.command){case N.ToggleFileBlame:this._statusBarItem.tooltip="Toggle Blame Annotations";break;case N.DiffWithPrevious:this._statusBarItem.command=Qt.DiffLineWithPrevious,this._statusBarItem.tooltip="Compare Line Revision with Previous";break;case N.DiffWithWorking:this._statusBarItem.command=Qt.DiffLineWithWorking,this._statusBarItem.tooltip="Compare Line Revision with Working";break;case N.ToggleCodeLens:this._statusBarItem.tooltip="Toggle Git CodeLens";break;case N.ShowQuickCommitDetails:this._statusBarItem.tooltip="Show Commit Details";break;case N.ShowQuickCommitFileDetails:this._statusBarItem.tooltip="Show Line Commit Details";break;case N.ShowQuickFileHistory:this._statusBarItem.tooltip="Show File History";break;case N.ShowQuickCurrentBranchHistory:this._statusBarItem.tooltip="Show Branch History"}this._statusBarItem.show()}}}class Zo{static initialize(e,t){if(this._context=e,this._config=t,e.subscriptions.push(this._lineTracker=new jo),e.subscriptions.push(this._tracker=new Ot),e.subscriptions.push(this._git=new Kt),this._tracker.initialize(),e.subscriptions.push(this._fileAnnotationController=new Ro),e.subscriptions.push(this._lineAnnotationController=new Uo),e.subscriptions.push(this._lineHoverController=new Lo),e.subscriptions.push(this._statusBarController=new Jo),e.subscriptions.push(this._codeLensController=new No),e.subscriptions.push(this._keyboard=new ns),e.subscriptions.push(this._pageProvider=new Yo),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new Oo);else{let t;t=ir.onDidChange(i=>{ir.changed(i,ir.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new Oo))})}if(t.historyExplorer.enabled)e.subscriptions.push(this._historyExplorer=new Ko);else{let t;t=ir.onDidChange(i=>{ir.changed(i,ir.name("historyExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._historyExplorer=new Ko))})}e.subscriptions.push(A.workspace.registerTextDocumentContentProvider(Mo.scheme,new Mo)),e.subscriptions.push(A.languages.registerCodeLensProvider(Qo.selector,new Qo))}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=ir.get()),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new Io),this._explorerCommands}static get fileAnnotations(){return this._fileAnnotationController}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get historyExplorer(){return void 0===this._historyExplorer&&this._context.subscriptions.push(this._historyExplorer=new Ko),this._historyExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._lineAnnotationController}static get lineHovers(){return this._lineHoverController}static get lineTracker(){return this._lineTracker}static get pages(){return this._pageProvider}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new Xo),this._resultsExplorer}static get statusBar(){return this._statusBarController}static get tracker(){return this._tracker}static resetConfig(){this._config=void 0}}const er=new Proxy({},{get:(e,t,i)=>er});class tr{constructor(){this._onDidChange=new A.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1}}static configure(e){e.subscriptions.push(A.workspace.onDidChangeConfiguration(ir.onConfigurationChanged,ir))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(U,null))return;Zo.resetConfig(),void 0!==Zo.pages&&Zo.pages.refresh(),ir.changed(e,ir.name("defaultGravatarsStyle").value)&&Be.clear();const t=ir.name("keymap").value;ir.changed(e,t)&&Q(H.KeyMap,this.get(t)),this._onDidChange.fire(e)}get(e,t,i){return void 0===i?A.workspace.getConfiguration(void 0===e?void 0:U,t).get(void 0===e?U:e):A.workspace.getConfiguration(void 0===e?void 0:U,t).get(void 0===e?U:e,i)}changed(e,t,i){return e.affectsConfiguration(`${U}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return A.workspace.getConfiguration(void 0===e?void 0:U,t).inspect(void 0===e?U:e)}async migrate(e,t,i={}){const s=ir.inspect(e);if(void 0===s)return!1;let o=!1;return void 0!==s.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,A.ConfigurationTarget.Global),o=!0),void 0!==s.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,A.ConfigurationTarget.Workspace),o=!0),void 0!==s.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,A.ConfigurationTarget.WorkspaceFolder),o=!0),o||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,A.ConfigurationTarget.Global),o=!0),o}async migrateIfMissing(e,t,i={}){const s=ir.inspect(e);if(void 0===s)return;const o=ir.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,A.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,A.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,A.ConfigurationTarget.WorkspaceFolder))}name(e){return m.propOf(er,e)}update(e,t,i,s){return A.workspace.getConfiguration(U,i===A.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await ir.inspect(e,i);if(void 0!==s.workspaceFolderValue){if(s.workspaceFolderValue===t)return;await ir.update(e,t,A.ConfigurationTarget.WorkspaceFolder,i)}else if(void 0!==s.workspaceValue){if(s.workspaceValue===t)return;await ir.update(e,t,A.ConfigurationTarget.Workspace)}else{if(s.globalValue===t)return;await ir.update(e,t,A.ConfigurationTarget.Global)}}}const ir=new tr;async function sr(e){const t=process.hrtime();Ce.configure(e);const i=A.extensions.getExtension(I).packageJSON.version,s=A.workspace.getConfiguration("git",null).get("enabled",!0);if(!s)return Ce.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),void Q(H.Enabled,s);tr.configure(e);const o=e.globalState.get(V.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=C.fromString(t);try{if(1!==C.compare(i,C.from(7,5,10))&&(await ir.migrate("annotations.file.gutter.gravatars",ir.name("blame")("avatars").value),await ir.migrate("annotations.file.gutter.compact",ir.name("blame")("compact").value),await ir.migrate("annotations.file.gutter.dateFormat",ir.name("blame")("dateFormat").value),await ir.migrate("annotations.file.gutter.format",ir.name("blame")("format").value),await ir.migrate("annotations.file.gutter.heatmap.enabled",ir.name("blame")("heatmap")("enabled").value),await ir.migrate("annotations.file.gutter.heatmap.location",ir.name("blame")("heatmap")("location").value),await ir.migrate("annotations.file.gutter.lineHighlight.enabled",ir.name("blame")("highlight")("enabled").value),await ir.migrate("annotations.file.gutter.lineHighlight.locations",ir.name("blame")("highlight")("locations").value),await ir.migrate("annotations.file.gutter.separateLines",ir.name("blame")("separateLines").value),await ir.migrate("codeLens.locations",ir.name("codeLens")("scopes").value),await ir.migrate("codeLens.perLanguageLocations",ir.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await ir.migrate("codeLens.customLocationSymbols",ir.name("codeLens")("symbolScopes").value),await ir.migrate("annotations.line.trailing.dateFormat",ir.name("currentLine")("dateFormat").value),await ir.migrate("blame.line.enabled",ir.name("currentLine")("enabled").value),await ir.migrate("annotations.line.trailing.format",ir.name("currentLine")("format").value),await ir.migrate("annotations.file.gutter.hover.changes",ir.name("hovers")("annotations")("changes").value),await ir.migrate("annotations.file.gutter.hover.details",ir.name("hovers")("annotations")("details").value),await ir.migrate("annotations.file.gutter.hover.details",ir.name("hovers")("annotations")("enabled").value),await ir.migrate("annotations.file.gutter.hover.wholeLine",ir.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ir.migrate("annotations.line.trailing.hover.changes",ir.name("hovers")("currentLine")("changes").value),await ir.migrate("annotations.line.trailing.hover.details",ir.name("hovers")("currentLine")("details").value),await ir.migrate("blame.line.enabled",ir.name("hovers")("currentLine")("enabled").value),await ir.migrate("annotations.line.trailing.hover.wholeLine",ir.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ir.migrate("gitExplorer.gravatars",ir.name("explorers")("avatars").value),await ir.migrate("gitExplorer.commitFileFormat",ir.name("explorers")("commitFileFormat").value),await ir.migrate("gitExplorer.commitFormat",ir.name("explorers")("commitFormat").value),await ir.migrate("gitExplorer.stashFileFormat",ir.name("explorers")("stashFileFormat").value),await ir.migrate("gitExplorer.stashFormat",ir.name("explorers")("stashFormat").value),await ir.migrate("gitExplorer.statusFileFormat",ir.name("explorers")("statusFileFormat").value),await ir.migrate("recentChanges.file.lineHighlight.locations",ir.name("recentChanges")("highlight")("locations").value)),1!==C.compare(i,C.from(8,0,0,"beta2"))&&(await ir.migrate("debug",ir.name("outputLevel").value,{migrationFn:e=>e?B.Debug:ir.get(ir.name("outputLevel").value)}),await ir.migrate("debug",ir.name("debug").value,{migrationFn:e=>void 0})),1!==C.compare(i,C.from(8,0,0,"rc"))){let e=ir.name("blame")("highlight")("locations").value;await ir.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=ir.name("recentChanges")("highlight")("locations").value,await ir.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==C.compare(i,C.from(8,0,0))&&(await ir.migrateIfMissing("annotations.file.gutter.gravatars",ir.name("blame")("avatars").value),await ir.migrateIfMissing("annotations.file.gutter.compact",ir.name("blame")("compact").value),await ir.migrateIfMissing("annotations.file.gutter.dateFormat",ir.name("blame")("dateFormat").value),await ir.migrateIfMissing("annotations.file.gutter.format",ir.name("blame")("format").value),await ir.migrateIfMissing("annotations.file.gutter.heatmap.enabled",ir.name("blame")("heatmap")("enabled").value),await ir.migrateIfMissing("annotations.file.gutter.heatmap.location",ir.name("blame")("heatmap")("location").value),await ir.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",ir.name("blame")("highlight")("enabled").value),await ir.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",ir.name("blame")("highlight")("locations").value),await ir.migrateIfMissing("annotations.file.gutter.separateLines",ir.name("blame")("separateLines").value),await ir.migrateIfMissing("codeLens.locations",ir.name("codeLens")("scopes").value),await ir.migrateIfMissing("codeLens.perLanguageLocations",ir.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await ir.migrateIfMissing("codeLens.customLocationSymbols",ir.name("codeLens")("symbolScopes").value),await ir.migrateIfMissing("annotations.line.trailing.dateFormat",ir.name("currentLine")("dateFormat").value),await ir.migrateIfMissing("blame.line.enabled",ir.name("currentLine")("enabled").value),await ir.migrateIfMissing("annotations.line.trailing.format",ir.name("currentLine")("format").value),await ir.migrateIfMissing("annotations.file.gutter.hover.changes",ir.name("hovers")("annotations")("changes").value),await ir.migrateIfMissing("annotations.file.gutter.hover.details",ir.name("hovers")("annotations")("details").value),await ir.migrateIfMissing("annotations.file.gutter.hover.details",ir.name("hovers")("annotations")("enabled").value),await ir.migrateIfMissing("annotations.file.gutter.hover.wholeLine",ir.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ir.migrateIfMissing("annotations.line.trailing.hover.changes",ir.name("hovers")("currentLine")("changes").value),await ir.migrateIfMissing("annotations.line.trailing.hover.details",ir.name("hovers")("currentLine")("details").value),await ir.migrateIfMissing("blame.line.enabled",ir.name("hovers")("currentLine")("enabled").value),await ir.migrateIfMissing("annotations.line.trailing.hover.wholeLine",ir.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ir.migrateIfMissing("gitExplorer.gravatars",ir.name("explorers")("avatars").value),await ir.migrateIfMissing("gitExplorer.commitFileFormat",ir.name("explorers")("commitFileFormat").value),await ir.migrateIfMissing("gitExplorer.commitFormat",ir.name("explorers")("commitFormat").value),await ir.migrateIfMissing("gitExplorer.stashFileFormat",ir.name("explorers")("stashFileFormat").value),await ir.migrateIfMissing("gitExplorer.stashFormat",ir.name("explorers")("stashFormat").value),await ir.migrateIfMissing("gitExplorer.statusFileFormat",ir.name("explorers")("statusFileFormat").value),await ir.migrateIfMissing("recentChanges.file.lineHighlight.locations",ir.name("recentChanges")("highlight")("locations").value)),1!==C.compare(i,C.from(8,0,2))){const e=ir.name("keymap").value;await ir.migrate(e,e,{fallbackValue:E.Alternate,migrationFn:e=>"standard"===e?E.Alternate:e})}}catch(e){Ce.error(e,"migrateSettings")}}(0,o);const r=ir.get();try{await Kt.initialize(r.advanced.git||A.workspace.getConfiguration("git").get("path"))}catch(e){return Ce.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await A.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${U}.${ir.name("advanced")("git").value}' is pointed to its installed location.`),void Q(H.Enabled,!1)}Zo.initialize(e,r),Q(H.KeyMap,Zo.config.keymap),Zo.context.subscriptions.push(new Hi),Zo.context.subscriptions.push(new Qs),Zo.context.subscriptions.push(new Vs),Zo.context.subscriptions.push(new ji),Zo.context.subscriptions.push(new Gi),Zo.context.subscriptions.push(new Es),Zo.context.subscriptions.push(new Bs),Zo.context.subscriptions.push(new Ns),Zo.context.subscriptions.push(new As),Zo.context.subscriptions.push(new Us),Zo.context.subscriptions.push(new Ls),Zo.context.subscriptions.push(new Os),Zo.context.subscriptions.push(new Is),Zo.context.subscriptions.push(new Ms),Zo.context.subscriptions.push(new Ws),Zo.context.subscriptions.push(new Ks),Zo.context.subscriptions.push(new zs),Zo.context.subscriptions.push(new qs),Zo.context.subscriptions.push(new Ys),Zo.context.subscriptions.push(new Xs),Zo.context.subscriptions.push(new Js),Zo.context.subscriptions.push(new Zs),Zo.context.subscriptions.push(new eo),Zo.context.subscriptions.push(new Oi),Zo.context.subscriptions.push(new wo),Zo.context.subscriptions.push(new Co),Zo.context.subscriptions.push(new bo),Zo.context.subscriptions.push(new yo),Zo.context.subscriptions.push(new to),Zo.context.subscriptions.push(new ro),Zo.context.subscriptions.push(new ao),Zo.context.subscriptions.push(new co),Zo.context.subscriptions.push(new no),Zo.context.subscriptions.push(new ho),Zo.context.subscriptions.push(new oo),Zo.context.subscriptions.push(new lo),Zo.context.subscriptions.push(new mo),Zo.context.subscriptions.push(new uo),Zo.context.subscriptions.push(new go),Zo.context.subscriptions.push(new po),Zo.context.subscriptions.push(new fo),Zo.context.subscriptions.push(new vo),function(e){Kt.validateGitVersion(2,2)||Wi.showUnsupportedGitVersionErrorMessage(e)}(Kt.getGitVersion()),async function(e,t){if(void 0===t)return Ce.log("GitLens first-time install"),void(Zo.config.showWhatsNewAfterUpgrades&&await A.commands.executeCommand(Qt.ShowWelcomePage));if(t!==e&&(Ce.log(`GitLens upgraded from v${t} to v${e}`),0===C.compare(C.fromString(t),C.from(8,0,0))))return void await A.commands.executeCommand(Qt.ShowWelcomePage);if(!Zo.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,r]=t.split(".");i===o&&s===r||i<o||i===o&&s<r||await A.commands.executeCommand(Qt.ShowWelcomePage)}(i,o),Wi.showKeyBindingsInfoMessage(),e.globalState.update(V.GitLensVersion,i);const a=process.hrtime(t);Ce.log(`GitLens(v${i}) activated in ${1e3*a[0]+Math.floor(a[1]/1e6)} ms`)}function or(){}i.d(t,"activate",function(){return sr}),i.d(t,"deactivate",function(){return or})},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("copy-paste")},function(e,t){e.exports=require("tmp")}]);