module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i.w={},i(i.s=9)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t,i){"use strict";var s,o;i.r(t),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const r=s.length;for(let a=0;a<r;a++)e(t,`${i}[${a}]`,s[a],o);0===r&&(t[i]=null)}else{let r=!0;for(const a in s)r=!1,e(t,i?`${i}.${a}`:a,s[a],o);r&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const r=t[o];"object"==typeof r?s.push(...e(r,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(s||(s={})),function(e){function t(e,i,o=!0){if(void 0===e.children)return e;const r=[...s.values(e.children)];for(const e of r)t(e,i,!1);if(!o&&1===r.length){const t=r[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.makeHierarchical=function(e,i,s,o=!1){const r={name:"",relativePath:"",children:Object.create(null),descendants:[]},a=e.reduce((e,t)=>{let o=e,r="";for(const e of i(t)){r=s(r,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:r,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},r);return o?t(a,s,!0):a},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(o||(o={}));var r=i(6);const a=i(8);a.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let r;return r="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+r:r+" ago":r}}}();const n={addSuffix:!0,locale:a};var h;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),r=s.getTime()-6e4*s.getTimezoneOffset(),a=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-a)/864e5)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(r.distanceInWordsToNow)(e,n),format:t=>Object(r.format)(e,t)}}}(h||(h={}));var c=i(3);const l=i(11),d=i(10);var m,u;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,r=c.__rest(s,["track"]);if(!0!==o)return l(e,t,r);let a=!1;const n=l(function(){return a=!1,e.apply(this,arguments)},t,i),h=function(){return a=!0,n.apply(this,arguments)};return h.pending=function(){return a},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return d(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(m||(m={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e){let t,i=0;for(;!(t=e.next()).done;)i++;return i},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(u||(u={}));class g{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}join(e){return e.join("")}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class p{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}join(e){return e.join("/")}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(t===p._fwd||t===p._bwd){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}p._fwd="/".charCodeAt(0),p._bwd="\\".charCodeAt(0);class f{isEmpty(){return void 0===this.left&&void 0===this.mid&&void 0===this.right&&void 0===this.element}}class v{constructor(e){this._iter=e}static forPaths(){return new v(new p)}static forStrings(){return new v(new g)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new f,this._root.str=i.value()),s=this._root;;){const e=i.cmp(s.str);if(e>0)s.left||(s.left=new f,s.left.str=i.value()),s=s.left;else if(e<0)s.right||(s.right=new f,s.right.str=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new f,s.mid.str=i.value()),s=s.mid}}const o=s.element;return s.element=t,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.element:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.element=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.element||i,s=s.mid}}return s&&s.element||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new v(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,[],e)}_forEach(e,t,i){void 0!==e&&(this._forEach(e.left,t,i),t.push(e.str),e.element&&i(e.element,this._iter.join(t)),this._forEach(e.mid,t,i),t.pop(),this._forEach(e.right,t,i))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(){return void 0===this._root||this._root.isEmpty()?0:u.count(this.entries())}entries(){return this._iterator(this._root,[])}values(){return u.map(this.entries(),e=>e[0])}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}*_iterator(e,t){void 0!==e&&(yield*this._iterator(e.left,t),t.push(e.str),e.element&&(yield[e.element,this._iter.join(t)]),yield*this._iterator(e.mid,t),t.pop(),yield*this._iterator(e.right,t))}}var w,C,b=i(5);!function(e){const t=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,i=/\$\{(\w*?)(?:\W|\d)*?\}/g;function s(e,t,i=" "){const s=t-h(e);return s<=0?e:i.repeat(s)+e}function o(e,t,i=" "){const s=t-h(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const i=[];let s=t.exec(e);for(;null!=s;){const o=s[2],r=s[3];i.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===r?"left":"right",collapseWhitespace:"?"===r}}),s=t.exec(e)}return i},e.interpolate=function(e,t){return e?void 0===t?e.replace(i,""):(e=e.replace(i,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(b.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(/\\/g,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=s,e.padLeftOrTruncate=function(e,t,i){const o=h(e);return o<t?s(e,t,i):o>t?a(e,t):e},e.padRight=o,e.padOrTruncate=function(e,t,i){const r=t<0;t=Math.abs(t);const n=h(e);return n<t?r?s(e,t,i):o(e,t,i):n>t?a(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=h(e);return s<t?o(e,t,i):s>t?a(e,t):e};const r=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function a(e,t,i="…"){if(!e)return e;const s=h(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),r=h(e.substring(0,o));for(;r<t;)r+=h(e[o++]);return r>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(r,t):e},e.sha1=function(e,t="base64"){return Object(b.createHash)("sha1").update(e).digest(t)},e.truncate=a;const n=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function h(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(n,"")];for(let e=0;e<o.length;e++){const r=o[e].codePointAt(0);if(!(r<=31||r>=127&&r<=159||r>=768&&r<=879))if(r>=128512&&r<=128591||r>=127744&&r<=128511||r>=128640&&r<=128767||r>=9728&&r<=9983||r>=9984&&r<=10175||r>=65024&&r<=65039||r>=129280&&r<=129535||r>=65024&&r<=65039||r>=8400&&r<=8447){if(r>=127995&&r<=127999)continue;i++,t+=2}else 8205!==r?(r>65535&&e++,t+=c(r)?2:1):(s++,t-=2)}const r=i-s;return r>1&&(t+=r-1),t}function c(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=h}(w||(w={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,r,a]=i.split(".");return t(o,r,a,s)}}(C||(C={}));var y,x,$,S,D,k,_,F,P,R,T,E,B,N,A=i(0);!function(e){e.File="file",e.Window="window"}(y||(y={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(x||(x={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}($||($={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(S||(S={})),function(e){e.Absolute="absolute",e.Relative="relative"}(D||(D={})),function(e){e.List="list",e.Tree="tree"}(k||(k={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(_||(_={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(F||(F={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(P||(P={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(R||(R={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(T||(T={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(E||(E={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(B||(B={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(N||(N={}));const U="gitlens",L="GitLens",O="GitLens",I="eamodio.gitlens",M=1e8;var W,H,j,G,V,Q,K,z,q;function Y(e,t){return A.commands.executeCommand(W.SetContext,e,t)}function X(e){const t=A.window.activeTextEditor;return void 0!==t&&t.document===e}function J(e){const t=e.document.uri.scheme;return t!==V.Output&&t!==V.DebugConsole}(H=W||(W={})).CloseActiveEditor="workbench.action.closeActiveEditor",H.CloseAllEditors="workbench.action.closeAllEditors",H.CursorMove="cursorMove",H.Diff="vscode.diff",H.EditorScroll="editorScroll",H.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",H.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",H.Open="vscode.open",H.NextEditor="workbench.action.nextEditor",H.PreviewHtml="vscode.previewHtml",H.RevealLine="revealLine",H.SetContext="setContext",H.ShowReferences="editor.action.showReferences",(G=j||(j={})).ActiveHasRemote="gitlens:activeHasRemote",G.ActiveIsBlameable="gitlens:activeIsBlameable",G.ActiveFileIsTracked="gitlens:activeIsTracked",G.ActiveIsRevision="gitlens:activeIsRevision",G.AnnotationStatus="gitlens:annotationStatus",G.CanToggleCodeLens="gitlens:canToggleCodeLens",G.Enabled="gitlens:enabled",G.ExplorersCanCompare="gitlens:explorers:canCompare",G.GitExplorer="gitlens:gitExplorer",G.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",G.GitExplorerView="gitlens:gitExplorer:view",G.HasRemotes="gitlens:hasRemotes",G.HistoryExplorer="gitlens:historyExplorer",G.Key="gitlens:key",G.KeyMap="gitlens:keymap",G.ResultsExplorer="gitlens:resultsExplorer",G.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults",(Q=V||(V={})).DebugConsole="debug",Q.File="file",Q.Git="git",Q.GitLensGit="gitlens-git",Q.Output="output",(z=K||(K={})).AngleBracketLeftHeavy="❰",z.AngleBracketRightHeavy="❱",z.ArrowBack="↩",z.ArrowDown="↓",z.ArrowDropRight="⤷",z.ArrowHeadRight="➤",z.ArrowLeft="←",z.ArrowLeftDouble="⇐",z.ArrowLeftRight="↔",z.ArrowLeftRightDouble="⇔",z.ArrowLeftRightDoubleStrike="⇎",z.ArrowLeftRightLong="⟷",z.ArrowRight="→",z.ArrowRightDouble="⇒",z.ArrowRightHollow="⇨",z.ArrowUp="↑",z.ArrowUpRight="↗",z.ArrowsHalfLeftRight="⇋",z.ArrowsHalfRightLeft="⇌",z.ArrowsLeftRight="⇆",z.ArrowsRightLeft="⇄",z.Asterisk="∗",z.Check="✓",z.Dash="—",z.Dot="•",z.Ellipsis="…",z.MiddleEllipsis="⋯",z.MuchGreaterThan="≪",z.MuchLessThan="⋘",z.Pencil="✎",z.Space=" ",z.SpaceThin=" ",z.SquareWithBottomShadow="❏",z.SquareWithTopShadow="❐",z.ZeroWidthSpace="​",(q||(q={})).GitLensVersion="gitlensVersion";const Z=[".png",".gif",".jpg",".jpeg",".webp",".tif",".tiff",".bmp"];var ee,te;(te=ee||(ee={})).GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",te.GitExplorerView="gitlens:gitExplorer:view",te.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults";class ie{}const se=new class extends ie{equals(e,t){return e===t}},oe=new class extends ie{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?se.equals(e.document,t.document):e.id===t.id)}},re=new class extends ie{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var ae,ne,he,ce;(ne=ae||(ae={})).Computing="computing",ne.Computed="computed";class le extends A.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=le.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=A.Disposable.from(A.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(se.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=m.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ae.Computing,e===A.window.activeTextEditor&&await Y(j.AnnotationStatus,this.status),this.editor=e,this.correlationKey=le.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ae.Computed,e===A.window.activeTextEditor&&(await Y(j.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ae.Computing,await this.onProvideAnnotation(e)?(this.status=ae.Computed,!0):(this.status=void 0,!1)}}function de(e){switch(e.type){case he.Branch:return"Branch";case he.Branches:return"Branches";case he.Commit:return"Commit";case he.File:return"File";case he.Repo:return"Repository";case he.Revision:return"Revision";default:return""}}(ce=he||(he={})).Branch="branch",ce.Branches="branches",ce.Commit="commit",ce.File="file",ce.Repo="repo",ce.Revision="revision";class me{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return A.commands.executeCommand(W.Open,A.Uri.parse(e))}open(e){switch(e.type){case he.Branch:return this.openBranch(e.branch);case he.Branches:return this.openBranches();case he.Commit:return this.openCommit(e.sha);case he.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case he.Repo:return this.openRepo();case he.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}const ue=/(^|\s)(issue #([0-9]+))\b/gi,ge=/(^|\s)(pull request #([0-9]+))\b/gi;class pe extends me{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(ue,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ge,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const fe=/(^|\s)(issue #([0-9]+))\b/gi,ve=/(^|\s)(pull request #([0-9]+))\b/gi;class we extends me{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(fe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ve,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class Ce extends me{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return w.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return w.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return w.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return w.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?w.interpolate(this.urls.fileLine,{line:s.start.line}):w.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?w.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?w.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):w.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const be=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,ye=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class xe extends me{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(be,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ye,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const $e=/(^|\s)(#([0-9]+))\b/gi;class Se extends me{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace($e,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const De=`[${L}]`;class ke{static configure(e){e.subscriptions.push(br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}static onConfigurationChanged(e){const t=br.initializing(e);let i=br.name("debug").value;(t||br.changed(e,i))&&(this.debug=br.get(i)),i=br.name("outputLevel").value,(t||br.changed(e,i))&&(this.level=br.get(i),this.level===B.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||A.window.createOutputChannel(L))}static log(e,...t){this.debug&&console.log(this.timestamp,De,e,...t),void 0===this.output||this.level!==B.Verbose&&this.level!==B.Debug||this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){this.debug&&console.error(this.timestamp,De,t,e,...i),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,t,e,...i]:[t,e,...i]).join(" "))}static warn(e,...t){this.debug&&console.warn(this.timestamp,De,e,...t),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t){this.level===B.Debug&&(void 0===this.gitOutput&&(this.gitOutput=A.window.createOutputChannel(`${L} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})`))}}ke.debug=!1,ke.level=B.Silent;const _e=/(^|\s)(#([0-9]+))\b/gi,Fe=new Map([["bitbucket.org",(e,t)=>new pe(e,t)],["github.com",(e,t)=>new xe(e,t)],["gitlab.com",(e,t)=>new Se(e,t)],["visualstudio.com",(e,t)=>new class extends me{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}enrichMessage(e){return e.replace(_e,`$1[$2](${this.baseUrl}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class Pe{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void ke.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(Fe);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case S.Bitbucket:return(t,i)=>new pe(t,i,e.protocol,e.name,!0);case S.BitbucketServer:return(t,i)=>new we(t,i,e.protocol,e.name,!0);case S.Custom:return(t,i)=>new Ce(t,i,e.urls,e.protocol,e.name);case S.GitHub:return(t,i)=>new xe(t,i,e.protocol,e.name,!0);case S.GitLab:return(t,i)=>new Se(t,i,e.protocol,e.name,!0)}}}var Re=i(7),Te=i(2),Ee=i(1);const Be="win32"===process.platform;function Ne(e){if(e.match(/[\\\/]/))return e;const t=Ee.join(".",e);try{if(Te.statSync(t))return t}catch(e){}const i=process.env.PATH.split(Be?";":":");for(const t of i){const i=Ee.join(t,e);try{if(Te.statSync(i))return i}catch(e){}}return e}function Ae(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:r}=s,a=c.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(Re.execFile)(e,t,a,(o,r,n)=>{if(!o)return n&&ke.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(r);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${a.maxBuffer} bytes`)),ke.warn(`Error(${a.cwd}): ${e} ${t.join(" ")})\n    (${o.code}) ${o.message}\n${n}`),s(o)});o&&n.stdin.end(o,r||"utf8")})}async function Ue(e){const t=await Ae(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!Be)return{cmd:Ne(t),args:i};if(!Te.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=Ne(`${t}${o}`);if(Te.existsSync(s))return e(s,i)}}return t.match(/\.ps1$/i)?{cmd:Ee.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)}:t.match(/\.(bat|cmd)$/i)?{cmd:Ee.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]}:t.match(/\.(js)$/i)?{cmd:process.execPath,args:[t].concat(i)}:{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function Le(e){return e?Ue(Ee.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}var Oe=i(4);class Ie extends A.Uri{constructor(e,t){if(void 0===e)return void super();if(e.scheme===V.GitLensGit){const t=JSON.parse(e.query),[i,s]=Ie.ensureValidUNCPath(e.authority,Ee.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!ni.isStagedUncommitted(t.sha)&&ni.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Ie.ensureValidUNCPath(e.authority,Ee.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!ni.isStagedUncommitted(t.sha)&&ni.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&ni.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?A.Uri.file(this.versionedPath):A.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getDirectory(e){return Ie.getDirectory(Ee.relative(this.repoPath||"",this.fsPath),e)}getFilename(e){return Ee.basename(Ee.relative(this.repoPath||"",this.fsPath),e)}getFormattedPath(e=w.pad(K.Dot,2,2),t){let i=Ee.dirname(this.fsPath);return this.repoPath&&(i=Ee.relative(this.repoPath,i)),void 0!==t&&(i=Ee.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?`${Ee.basename(this.fsPath)}${e}${i}`:Ee.basename(this.fsPath)}getRelativePath(e){let t=Ee.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=Ee.relative(e,t)),w.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Ie(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Ie(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=A.Uri.file(Ee.resolve(t,s&&e.originalFileName||e.fileName));return new Ie(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Ie(A.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Ie(e)}static async fromUri(e){if(e instanceof Ie)return e;if(!vr.git.isTrackable(e))return new Ie(e);if(e.scheme===V.GitLensGit)return new Ie(e);if(e.scheme===V.Git){const t=JSON.parse(e.query),i=await vr.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=ni.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Ie(e,{fileName:t.path,repoPath:i,sha:s})}const t=await vr.git.getVersionedUri(e);return void 0!==t?t:new Ie(e,await vr.git.getRepoPath(e))}static getDirectory(e,t){let i=Ee.dirname(e);return void 0!==t&&(i=Ee.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=w.pad(K.Dot,2,2),i){let s;if(e instanceof A.Uri){if(e instanceof Ie)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Ie.getDirectory(s,i);return o?`${Ee.basename(s)}${t}${o}`:Ee.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof A.Uri){if(e instanceof Ie)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=Ee.relative(i||"",s);return void 0!==t&&(o=Ee.relative(t,o)),w.normalizePath(o)}static toKey(e){return w.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,r;"string"==typeof e?(s="string"==typeof t?t:Ee.resolve(i,t.fileName),o=e,r=ni.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,r=e.shortSha);const a={fileName:w.normalizePath(Ee.relative(i,s)),repoPath:i,sha:o},n=Ee.parse(s);return A.Uri.parse(`${V.GitLensGit}:${Ee.join(n.dir,n.name)}:${r}${n.ext}?${JSON.stringify(a)}`)}}const Me=new Map;var We,He;(He=We||(We={})).Blame="blame",He.Branch="branch",He.File="file",He.Stash="stash",He.StashFile="stash-file";const je={dateFormat:void 0,dateStyle:void 0,reset:()=>{je.dateStyle=br.get(br.name("defaultDateStyle").value),je.dateFormat=br.get(br.name("defaultDateFormat").value)}};class Ge{constructor(e,t,i,s,o,r,a,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=r,this.message=a,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return je.dateStyle===D.Absolute?this.formatDate(je.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Mt.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===We.Blame||this.type===We.File||this.type===We.StashFile}get isStash(){return this.type===We.Stash||this.type===We.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Mt.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Mt.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Mt.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Mt.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?A.Uri.file(Ee.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return A.Uri.file(Ee.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=w.pad(K.Dot,2,2)){return Ie.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Me.get(i);if(void 0!==s)return s;const o=(s=A.Uri.parse(`https://www.gravatar.com/avatar/${this.email?w.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Me.set(i,s),s}getShortMessage(e=`${K.Space}${K.Ellipsis}`){const t=this.message.indexOf("\n");return-1===t?this.message:`${this.message.substring(0,t)}${e}`}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await vr.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Ie.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ve extends Ge{constructor(e,t,i,s,o,r,a,n,h,c,l){super(We.Blame,e,t,i,s,o,r,a,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ve(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Qe{constructor(e,t,i=!1,s,o=0,r=0){this.repoPath=e,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.current=i,this.name=t,this.tracking=""===s||null==s?void 0:s,this.state={ahead:o,behind:r}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Qe.getRemote(this.name):void 0!==this.tracking?Qe.getRemote(this.tracking):void 0}getTrackingStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.tracking||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${K.ArrowDown}${e.separator}${this.state.ahead}${K.ArrowUp}`}isValid(){return Qe.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Ke=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,ze=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,qe=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class Ye{static parse(e,t=!1){if(!e)return;const i=[];let s,o,r,a=null;do{if(null==(a=qe.exec(`${e}\n@@`)))break;s=(" "+a[5]).substr(1),o=parseInt(a[3],10),r=parseInt(a[1],10),i.push(new Xe(s,{start:o,end:o+parseInt(a[4],10)},{start:r,end:r+parseInt(a[2],10)}))}while(null!=a);return i.length?{diff:t?e:void 0,chunks:i}:void 0}static parseChunk(e){const t=u.skip(w.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const r=[];let a=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))a={line:n.line,state:n.state,previous:[s[e]]},r.push(a);else{if(void 0===a)continue;if(void 0===a.previous){a.previous=[s[e]];continue}a.previous.push(s[e])}return r}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Ke.exec(e)))break;i.push(Pt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=ze.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class Xe{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=Ye.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class Je extends Ge{constructor(e,t,i,s,o,r,a,n,h,c,l,d,m,u){super(e,t,i,s,o,r,a,n,l,d,m),this.fileStatuses=h,this.status=c,this.parentShas=u}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Mt.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?A.Uri.file(Ee.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=w.normalizePath(Ee.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?We.StashFile:We.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new Je(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ze,et,tt,it;!function(e){e.Fetch="fetch",e.Push="push"}(Ze||(Ze={}));class st{constructor(e,t,i,s,o,r){this.repoPath=e,this.name=t,this.domain=i,this.path=s,this.provider=o,this.types=r}}(tt=et||(et={})).Config="config",tt.Remotes="remotes",tt.Repository="repository",tt.Stashes="stashes",tt.Tags="tags";class ot{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}(it||(it={})).StatusNode="statusNode";class rt extends A.Disposable{constructor(e,t,i,s,o){super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new A.EventEmitter,this._onDidChangeFileSystem=new A.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this.formattedName=i?e.name:`${e.name} (${Ee.relative(e.uri.fsPath,t)})`,this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o;const r=A.workspace.createFileSystemWatcher(new A.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=A.Disposable.from(r,r.onDidChange(this.onRepositoryChanged,this),r.onDidCreate(this.onRepositoryChanged,this),r.onDidDelete(this.onRepositoryChanged,this),br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=br.initializing(e),i=br.name("remotes").value;(t||br.changed(e,i,this.folder.uri))&&(this._providerMap=Pe.createMap(br.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(et.Remotes)))}onFileSystemChanged(e){/\.git(?:\/|\\|$)/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(et.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(et.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(et.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(et.Config,et.Remotes);this.onAnyRepositoryChanged(this),this.fireChange(et.Repository)}}}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=m.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new ot(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=m.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}containsUri(e){return e instanceof Ie&&(e=void 0!==e.repoPath?A.Uri.file(e.repoPath):e.fileUri()),this.folder===A.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=vr.git.getBranch(this.path)),this._branch}getBranches(){return vr.git.getBranches(this.path)}getChangedFilesCount(e){return vr.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=br.get(br.name("remotes").value,this.folder.uri);this._providerMap=Pe.createMap(e)}this._remotes=vr.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return vr.git.getStashList(this.path)}getStatus(){return vr.git.getStatusForRepo(this.path)}getTags(){return vr.git.getTags(this.path)}async hasRemote(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=A.workspace.createFileSystemWatcher(new A.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=A.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}}class at extends Je{constructor(e,t,i,s,o,r,a,n,h,c,l,d){super(e,i,s,"You",void 0,o,r,a,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new at(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class nt{constructor(e,t,i,s,o,r){this.repoPath=e,this.branch=t,this.sha=i,this.files=s,this.state=o,this.upstream=r}getDiffStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),0===this.files.length)return e.empty;if(void 0===this._diff){this._diff={added:0,deleted:0,changed:0};for(const e of this.files)switch(e.status){case"A":case"?":this._diff.added++;break;case"D":this._diff.deleted++;break;default:this._diff.changed++}}if(e.expand){let t="";return this._diff.added&&(t+=`${this._diff.added} ${1===this._diff.added?"file":"files"} added`),this._diff.changed&&(t+=`${""===t?"":e.separator}${this._diff.changed} ${1===this._diff.changed?"file":"files"} changed`),this._diff.deleted&&(t+=`${""===t?"":e.separator}${this._diff.deleted} ${1===this._diff.deleted?"file":"files"} deleted`),`${e.prefix}${t}`}return`${e.prefix}+${this._diff.added}${e.separator}~${this._diff.changed}${e.separator}-${this._diff.deleted}`}getUpstreamStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.upstream||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${K.ArrowDown}${e.separator}${this.state.ahead}${K.ArrowUp}`}}class ht{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return A.Uri.file(Ee.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return ht.getFormattedDirectory(this,e)}getFormattedPath(e=w.pad(K.Dot,2,2)){return ht.getFormattedPath(this,e)}getOcticon(){return lt(this.status)}getStatusText(e){return ht.getStatusText(this.status)}with(e){return new ht(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Ie.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${w.pad(K.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=w.pad(K.Dot,2,2),i){return Ie.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Ie.getRelativePath(e.fileName,t)}static getStatusText(e){return function(e){return ut[e]||ut.X}(e)}}const ct={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function lt(e,t=K.Space.repeat(4)){return ct[e]||t}const dt={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function mt(e){return dt[e]||dt.X}const ut={"!":"ignored","?":"untracked",A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"modified",U:"conflict",X:"unknown",B:"unknown"};class gt{constructor(e,t){this.repoPath=e,this.name=t}}class pt{static parse(e,t,i){if(!e)return;const s=new Map,o=new Map,r=[];let a,n,h=t&&i,c=void 0,l=!0;for(a of w.lines(e))if(!((n=a.split(" ")).length<2))if(void 0!==c)switch(n[0]){case"author":c.author=Mt.isUncommitted(c.sha)?"You":n.slice(1).join(" ").trim();break;case"author-mail":c.authorEmail=n.slice(1).join(" ").trim();const e=c.authorEmail.indexOf("<");if(e>=0){const t=c.authorEmail.indexOf(">",e);c.authorEmail=t>e?c.authorEmail.substring(e+1,t):c.authorEmail.substring(e+1)}break;case"author-time":c.authorDate=n[1];break;case"author-tz":c.authorTimeZone=n[1];break;case"summary":c.summary=n.slice(1).join(" ").trim();break;case"previous":c.previousSha=n[1],c.previousFileName=n.slice(2).join(" ");break;case"filename":c.fileName=n.slice(1).join(" "),l&&void 0===t&&(t=w.normalizePath(i.replace(i.startsWith("/")?`/${c.fileName}`:c.fileName,"")),h=w.normalizePath(Ee.relative(t,i))),l=!1,pt.parseEntry(c,t,h,o,s,r),c=void 0}else c={sha:n[0],originalLine:parseInt(n[1],10)-1,line:parseInt(n[2],10)-1,lineCount:parseInt(n[3],10)};return o.forEach(e=>{if(void 0===e.author)return;const t=s.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...s.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:o,lines:r}}static parseEntry(e,t,i,s,o,r){let a=s.get(e.sha);if(void 0===a){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}a=new Ve(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,a)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};a.previousSha&&(i.previousSha=a.previousSha),a.lines.push(i),r[i.line]=i}}}const ft=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,vt=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class wt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=ft.exec(e)))break;const[o,r]=this.parseState(s[5]);i.push(new Qe(t,s[2],"*"===s[1],s[4],o,r))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=vt.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const Ct=/diff --git a\/(.*) b\/(.*)/,bt={};class yt{static parse(e,t,i,s,r,a,n,h){if(!e)return;let c,l,d=void 0,m=bt,u=void 0,g=0,p=!0;const f=w.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=w.normalizePath(i));const C=new Map,b=new Map;for(;!((v=f.next()).done||(u=v.value,n&&a&&g>=a));)switch(l=u.charCodeAt(1)){case 114:m={ref:u.substring(4)};break;case 97:m.author=Mt.isUncommitted(m.ref)?"You":u.substring(4);break;case 101:m.email=u.substring(4);break;case 100:m.date=u.substring(4);break;case 112:m.parentShas=u.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(u=v.value);)void 0===m.summary?m.summary=u:m.summary+=`\n${u}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(u=v.value);)if(!u.startsWith("warning:"))if(t===We.Branch){const e={status:u[0],fileName:u.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(u.startsWith("diff")){const e=Ct.exec(u);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}m.status=u[0],m.fileName=u.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=o.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===We.File&&void 0!==s?(i=w.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),c=w.normalizePath(Ee.relative(i,s))):c=m.fileName,p=!1;const e=b.get(m.ref);void 0===e&&g++,d=yt.parseEntry(m,e,t,i,c,b,C,d)}return{repoPath:i,authors:C,commits:b,sha:r,count:g,maxCount:a,range:h,truncated:!!(a&&g>=a&&1!==a)}}static parseEntry(e,t,i,s,o,r,a,n){if(void 0===t){if(void 0!==e.author){let t=a.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},a.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===We.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new Je(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),r.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===We.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const xt=/^(.*)\t(.*)\s\((.*)\)$/gm,$t=/^(?:git:\/\/(.*?)\/|https:\/\/(.*?)\/|http:\/\/(.*?)\/|git@(.*):|ssh:\/\/(?:.*@)?(.*?)(?::.*?)?\/)(.*)$/;class St{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let r=null;do{if(null==(r=xt.exec(e)))break;const a=r[2],[n,h]=this.parseGitUrl(a),c=`${n}/${h}`;let l=o[c];void 0===l?(l=new st(t,r[1],n,h,i(n,h),[{url:a,type:r[3]}]),s.push(l),o[c]=l):l.types.push({url:a,type:r[3]})}while(null!=r);return s.length?s:[]}static parseGitUrl(e){const t=$t.exec(e);return null==t?["",""]:[t[1]||t[2]||t[3]||t[4]||t[5],t[6].replace(/\.git\/?$/,"")]}}const Dt={};class kt{static parse(e,t){if(!e)return;const i=w.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=w.normalizePath(t));const r=new Map;let a,n=Dt,h=void 0;for(;!(s=i.next()).done;)switch(a=(h=s.value).charCodeAt(1)){case 114:n={ref:h.substring(4)};break;case 100:n.date=h.substring(4);break;case 108:n.stashName=h.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(h=s.value);)void 0===n.summary?n.summary=h:n.summary+=`\n${h}`;void 0!==n.summary&&(n.summary=n.summary.slice(0,-1));break;case 102:if((s=i.next()).done||"</f>"===s.value)break;for(;!(s=i.next()).done&&"</f>"!==(h=s.value);){if(h.startsWith("warning:"))continue;const e={status:h[0],fileName:h.substring(1),originalFileName:void 0};yt.parseFileName(e),e.fileName&&(void 0===n.fileStatuses&&(n.fileStatuses=[]),n.fileStatuses.push(e))}void 0!==n.fileStatuses&&(n.fileNames=o.filterMap(n.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "));let e=r.get(n.ref);e=kt.parseEntry(n,e,t,r)}return{repoPath:t,commits:r}}static parseEntry(e,t,i,s){return void 0===t&&(t=new at(We.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const _t=/(?:ahead ([0-9]+))/,Ft=/(?:behind ([0-9]+))/;class Pt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let r,a=-1;for(;++a<e.length;){const n=e[a];if(n.startsWith("##")){const e=n.split(" ");if([i,r]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=_t.exec(t);o.ahead=null==i?0:+i[1]||0;const s=Ft.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,r]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,r.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return new nt(w.normalizePath(t),i||"","",s,o,r)}static parseV2(e,t){let i;const s=[];let o;const r={ahead:0,behind:0};let a,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":a=e[2];break;case"branch.ab":r.ahead=+e[2].substring(1),r.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return new nt(w.normalizePath(t),i||"",o||"",s,r,a)}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let r=void 0;return t.length>1&&(""!==(r="."!==t[1]?t[1].trim():void 0)&&null!==r||(r=void 0)),new ht(e,o,r,i,s)}}class Rt{static parse(e,t){if(!e)return;const i=o.filterMap(e.split("\n"),e=>e?new gt(t,e):void 0);return i.length?i:void 0}}let Tt;const Et=["blame","--root","--incremental"],Bt=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],Nt=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],At={notARepository:/Not a git repository/,outsideRepository:/is outside repository/,noPath:/no such path/,noCommits:/does not have any commits/,notFound:/Path \'.*?\' does not exist in/,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/,headNotABranch:/HEAD does not point to a branch/,noUpstream:/no upstream configured for branch \'(.*?)\'/,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree/};async function Ut(e,...t){try{return await Ot(e,...t)}catch(i){return It(i,e,...t)}}const Lt=new Map;async function Ot(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=c.__rest(e,["correlationKey"]),r=e.encoding||"utf8",a=Object.assign({},o,{encoding:"utf8"===r?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,h=`(${a.cwd}${void 0!==s?s:""}): ${n}`;let l,d=Lt.get(h);void 0===d?(ke.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),d=Ae(Tt.path,t,a),Lt.set(h,d)):ke.log(`Awaiting${h}`);try{l=await d}finally{Lt.delete(h);const e=process.hrtime(i),t=`in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;ke.log(`Completed${h} ${t}`),ke.logGitCommand(`${n} ${t}`,a.cwd)}return"utf8"===r||"binary"===r?l:Oe.decode(Buffer.from(l,"binary"),r)}function It(e,t,...i){const o=e&&e.toString();if(o)for(const e of s.values(At))if(e.test(o))return ke.warn("git",...i,`  cwd='${t.cwd}'`,`\n  ${o.replace(/\r?\n|\r/g," ")}`),"";throw ke.error(e,"git",...i,`  cwd='${t.cwd}'`,o&&`\n  ${o.replace(/\r?\n|\r/g," ")}`),e}class Mt{static gitInfo(){return Tt}static getEncoding(e){return void 0!==e&&Oe.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Tt=await async function(e){try{return await Ue(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await Ae("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return Ue(e);try{return await Ae("xcode-select",["-p"]),Ue(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):Ue(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await Le(process.env.ProgramW6432).then(null,()=>Le(process.env["ProgramFiles(x86)"])).then(null,()=>Le(process.env.ProgramFiles)).then(null,()=>Ue("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}(e);const i=process.hrtime(t);return ke.log(`Git found: ${Tt.version} @ ${"git"===Tt.path?"PATH":Tt.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Tt}static async getVersionedFile(e,t,s){const o=await Mt.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Mt.isStagedUncommitted(s)&&(s="");const r=w.truncate(w.sanitizeForFileSystem(Mt.isSha(s)?Mt.shortenSha(s):s),50,""),a=Ee.extname(t),n=await Promise.resolve().then(function(){var e=i(13);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});return new Promise((i,h)=>{n.file({prefix:`${Ee.basename(t,a)}-${r}__`,postfix:a},(r,a,n,c)=>{r?h(r):(ke.log(`getVersionedFile[${a}]('${e}', '${t}', ${s})`),Te.appendFile(a,o,{encoding:"binary"},e=>{e?h(e):i(a)}))})})}static isResolveRequired(e){return Mt.isSha(e)&&!Mt.shaStrictRegex.test(e)}static isSha(e){return Mt.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Mt.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Mt.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"working",working:""},t),""===e)return t.working;if(Mt.isStagedUncommitted(e))return t.stagedUncommitted;if(Mt.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=w.normalizePath(e);const i=((t=w.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=w.normalizePath(i?Ee.dirname(e):t),e=w.normalizePath(i?Ee.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Tt.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,r]=Mt.splitPath(t,e),a=[...Et];let n;return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),i&&(Mt.isStagedUncommitted(i)?(a.push("--contents","-"),n=await Mt.show(e,t,":")):a.push(i)),Ut({cwd:r,stdin:n},...a,"--",o)}static async blame_contents(e,t,i,s={}){const[o,r]=Mt.splitPath(t,e),a=[...Et];return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),a.push("--contents","-"),Ut({cwd:r,stdin:i,correlationKey:s.correlationKey},...a,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),Ut({cwd:e},...i)}static checkout(e,t,i){const[s,o]=Mt.splitPath(t,e);return Ut({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await Ot({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const r=["diff","--diff-filter=M","-M","--no-ext-diff"];return i&&r.push(Mt.isStagedUncommitted(i)?"--staged":i),s&&r.push(Mt.isStagedUncommitted(s)?"--staged":s),Ut({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...r,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),Ut({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),Ut({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),Ut({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),Ut({cwd:e},...o)}static log(e,t){const i=[...Bt,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Mt.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),Ut({cwd:e},...i)}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Mt.splitPath(t,e),r=[...Bt];return i.maxCount&&!i.reverse&&r.push(`-n${i.maxCount}`),i.renames&&r.push("--follow","-m","--first-parent"),i.ref&&!Mt.isStagedUncommitted(i.ref)&&(i.reverse?r.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):r.push(i.ref)),null!=i.startLine&&null!=i.endLine&&r.push(`-L ${i.startLine},${i.endLine}:${s}`),r.push("--",s),Ut({cwd:o},...r)}static async log_recent(e,t){try{return(await Ot({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await Ot({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...Bt,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),Ut({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Mt.isStagedUncommitted(t.ref)&&i.push(t.ref),Ut({cwd:e},...i)}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Mt.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await Ot({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),Ut({cwd:e},...o,t,i)}static remote(e){return Ut({cwd:e},"remote","-v")}static remote_url(e,t){return Ut({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await Ot({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await Ot(i,...t)}catch(e){const s=e&&e.toString();if(At.headNotABranch.test(s))return;const o=At.noUpstream.exec(s);if(null!==o)return o[1];if(At.unknownRevision.test(s))try{const t=["symbolic-ref","-q","--short","HEAD"];return await Ot(i,...t)}catch(e){return}return It(e,i,...t)}}static async revparse_toplevel(e){try{return(await Ot({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,r]=Mt.splitPath(t,e);if(Mt.isStagedUncommitted(i)&&(i=":"),Mt.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const a={cwd:r,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await Ot(a,"show",n)}catch(e){const t=e&&e.toString();if(At.notFound.test(t)||At.foundButNotInRevision.test(t))return;return It(e,a,n)}}static stash_apply(e,t,i){if(t)return Ut({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return Ut({cwd:e},"stash","drop",t)}static stash_list(e){return Ut({cwd:e},...Nt)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),Ut({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),Ut({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return Ut({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Mt.splitPath(t,e),r=i>=2?`--porcelain=v${i}`:"--porcelain";return Ut({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",r,s)}static tag(e){return Ut({cwd:e},...["tag","-l"])}}Mt.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Mt.shaStrictRegex=/^[0-9a-f]{40}$/,Mt.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Mt.stagedUncommittedSha="0000000000000000000000000000000000000000:",Mt.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Mt.uncommittedSha="0000000000000000000000000000000000000000";class Wt extends A.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new A.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===vr.git&&!await m.waitUntil(()=>void 0!==vr.git,2e3))throw ke.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Ie.fromUri(e),this._disposed)return;const t=await vr.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(et.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){Y(j.ActiveIsRevision,this.isRevision),Y(j.ActiveFileIsTracked,this.isTracked),Y(j.ActiveIsBlameable,this.isBlameable),Y(j.ActiveHasRemote,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,ke.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&X(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=A.window.activeTextEditor;return void 0!==t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await vr.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&void 0===(s=e.repo)&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemote(),void 0!==t){const s=this.isBlameable;if(Y(j.ActiveIsRevision,this.isRevision),Y(j.ActiveFileIsTracked,this.isTracked),Y(j.ActiveIsBlameable,s),Y(j.ActiveHasRemote,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class Ht extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new A.EventEmitter,this._onDidChangeDirtyState=new A.EventEmitter,this._onDidTriggerDirtyIdle=new A.EventEmitter,this._documentMap=new Map,this._disposable=A.Disposable.from(br.onDidChange(this.onConfigurationChanged,this),A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,0),this),A.workspace.onDidChangeTextDocument(m.debounce(this.onTextDocumentChanged,50),this),A.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),A.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(br.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(A.window.activeTextEditor)}onConfigurationChanged(e){const t=br.initializing(e);if(!t&&(br.changed(e,br.name("blame")("ignoreWhitespace").value,null)||br.changed(e,br.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=br.name("advanced")("blame")("delayAfterEdit").value;(t||br.changed(e,i))&&(this._dirtyIdleTriggerDelay=br.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!J(e))return;if(void 0===e)return Y(j.ActiveIsRevision,!1),Y(j.ActiveFileIsTracked,!1),Y(j.ActiveIsBlameable,!1),void Y(j.ActiveHasRemote,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==V.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=A.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?X(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof A.Uri)&&(e=Ie.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Ie)try{e=await A.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){const i=t.toString();if(i.includes("File seems to be binary and cannot be opened as text"))e=new Gt(e);else{if(!i.includes("File not found"))throw t;e=new Vt(e)}}else e instanceof A.Uri&&(e=await A.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Ie?e=Ie.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof A.Uri)&&(e=Ie.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Ie.toKey(e.uri),i=new Wt(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),A.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=m.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=m.debounce(async e=>{A.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class jt{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=A.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}class Gt extends jt{}class Vt extends jt{}class Qt{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class Kt extends Ht{}class zt{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=w.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:w.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?w.padLeft(e,i):(t.collapseWhitespace&&(i-=o),w.padRight(e,i))):o<0?w.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof zt)return w.interpolate(t,e);let o=void 0;return o=null==s||"string"==typeof s?{dateFormat:s,tokenOptions:w.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}:s,void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),w.interpolate(t,this._formatter)}}zt._formatter=void 0;class qt extends zt{get _ago(){return this._item.fromNow()}get _date(){return this._item.formatDate(this._options.dateFormat)}get _agoOrDate(){return(void 0!==this._options.dateStyle?this._options.dateStyle:vr.config.defaultDateStyle)===D.Absolute?this._date:this._ago}get ago(){return this._padOrTruncate(this._ago,this._options.tokenOptions.ago)}get agoOrDate(){return this._padOrTruncate(this._agoOrDate,this._options.tokenOptions.agoOrDate)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._ago}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get authorAgoOrDate(){const e=`${this._item.author}, ${this._agoOrDate}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){return this._padOrTruncate(this._date,this._options.tokenOptions.date)}get id(){return this._item.shortSha}get message(){let e;return e=this._item.isStagedUncommitted?"Staged changes":this._item.isUncommitted?"Uncommitted changes":this._options.truncateMessageAtNewLine?this._item.getShortMessage():this._item.message,this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Yt extends zt{get directory(){const e=ht.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=Ee.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=ht.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=ht.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.path)}get status(){const e=ht.getStatusText(this._item.status);return this._padOrTruncate(e,this._options.tokenOptions.status)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${K.Pencil} ${K.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Xt,Jt,Zt,ei,ti,ii,si,oi,ri,ai;(Jt=Xt||(Xt={})).Author="author",Jt.ChangedOccurrences="changed-occurrences",Jt.Changes="changes",Jt.Files="files",Jt.Message="message",Jt.Sha="sha";class ni extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new A.EventEmitter,this._suspended=!1,this._repositoryTree=v.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=A.Disposable.from(A.window.onDidChangeWindowState(this.onWindowStateChanged,this),A.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return vr.config.advanced.caching.enabled}onAnyRepositoryChanged(e){this._trackedCache.clear()}onConfigurationChanged(e){(br.initializing(e)||br.changed(e,br.name("defaultDateStyle").value)||br.changed(e,br.name("defaultDateFormat").value))&&je.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:A.workspace.workspaceFolders||[],removed:[]},ke.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==V.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==V.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...u.map(i.entries(),([t,i])=>[t,Ee.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=br.get(br.name("advanced")("repositorySearchDepth").value,t);ke.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),r=[],a=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(ke.log(`Repository found in '${n}'`),r.push(new rt(e,n,!0,a,this._suspended))),i<=0){const e=process.hrtime(o);return ke.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),r}let h=Object.assign({},A.workspace.getConfiguration("files",t).get("exclude",{}),A.workspace.getConfiguration("search",t).get("exclude",{}));h=[...u.filterMap(s.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const c=await this.repositorySearchCore(t.fsPath,i,h);for(let t of c){if(t=Ee.dirname(t),w.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(ke.log(`Repository found in '${i}'`),r.push(new rt(e,i,!1,a,this._suspended)))}const l=process.hrtime(o);return ke.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*l[0]+Math.floor(l[1]/1e6)} ms`),r}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,r)=>{Te.readdir(e,async(a,n)=>{if(null!=a)return void r(a);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=Ee.resolve(e,t);return new Promise((e,r)=>{Te.stat(o,(r,a)=>{".git"===t?s.push(o):null==r&&!0!==i[t]&&null!=a&&a.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await Y(j.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await Y(j.HasRemotes,i),!t){const e=A.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=A.Disposable.from(e,e.onDidCreate(async e=>{const i=A.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,ke.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Mt.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>Te.exists(Ee.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&u.first(s.commits.values());if(o)return o;const r=await this.findNextFileName(e,t,i);return r&&(o=(s=await this.getLogForFile(e,r,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&u.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Mt.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=u.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Mt.splitPath(s,t)):s=w.normalizePath(Ee.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){if(void 0===e){const e=this.getHighlanderRepoPath();if(void 0!==e)return e}if(void 0===(e=e||A.window.activeTextEditor))return;const t=await vr.tracker.getOrAdd(e.document.uri);return void 0!==t?t.uri.repoPath:void 0}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await vr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return ke.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}ke.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new Qt(i.key))}else ke.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(ke.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return ke.log(`Skipping blame; '${e.fsPath}' is not tracked`),ni.emptyPromise;const[s,o]=Mt.splitPath(e.fsPath,e.repoPath,!1);try{const r=await Mt.blame(o,s,e.sha,{ignoreWhitespace:vr.config.blame.ignoreWhitespace});return pt.parse(r,o,s)}catch(e){if(void 0!==t.state){const s=e&&e.toString();return ke.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:ni.emptyPromise,errorMessage:s}),t.setBlameFailure(),ni.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${w.sha1(t)}`,s=await vr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return ke.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}ke.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new Qt(s.key))}else ke.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(ke.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return ke.log(`Skipping blame; '${e.fsPath}' is not tracked`),ni.emptyPromise;const[o,r]=Mt.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Mt.blame_contents(r,o,t,{correlationKey:`:${s}`,ignoreWhitespace:vr.config.blame.ignoreWhitespace});return pt.parse(a,r,o)}catch(e){if(void 0!==i.state){const t=e&&e.toString();return ke.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:ni.emptyPromise,errorMessage:t}),i.setBlameFailure(),ni.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(ke.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Mt.blame(e.repoPath,o,e.sha,{ignoreWhitespace:vr.config.blame.ignoreWhitespace,startLine:s,endLine:s}),r=pt.parse(i,e.repoPath,o);if(void 0===r)return;return{author:u.first(r.authors.values()),commit:u.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(ke.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const r=s.commits.get(o.sha);if(void 0===r)return;return{author:Object.assign({},s.authors.get(r.author),{lineCount:r.lines.length}),commit:r,line:o}}const o=t+1,r=e.fsPath;try{const s=await Mt.blame_contents(e.repoPath,r,i,{ignoreWhitespace:vr.config.blame.ignoreWhitespace,startLine:o,endLine:o}),a=pt.parse(s,e.repoPath,r);if(void 0===a)return;return{author:u.first(a.authors.values()),commit:u.first(a.commits.values()),line:a.lines[t]}}catch(e){return}}async getBlameForRange(e,t){ke.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(ke.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),r=new Map,a=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});a.set(t.sha,e);let s=r.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},r.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...r.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;ke.log(`getBranch('${e}')`);const t=await Mt.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Qe(e,i[0],!0,i[1])}async getBranches(e){if(void 0===e)return[];ke.log(`getBranches('${e}')`);const t=await Mt.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return wt.parse(t,e)||[]}async getChangedFilesCount(e,t){ke.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Mt.diff_shortstat(e,t);return Ye.parseShortStat(i)}async getConfig(e,t){return ke.log(`getConfig('${e}', '${t}')`),await Mt.config_get(e,t)}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await vr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return ke.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),r.item}ke.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new Qt(o.key))}else ke.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const r=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:ni.getEncoding(e)},o,s);return void 0!==o.state&&(ke.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getDiffForFileCore(e,t,i,s,o,r,a){const[n,h]=Mt.splitPath(t,e,!1);try{const t=await Mt.diff(h,n,i,s,o);return Ye.parse(t)}catch(e){if(void 0!==r.state){const t=e&&e.toString();return ke.log(`Replace diff cache with empty promise for '${r.state.key}:${a}'`),r.state.set(a,{item:ni.emptyPromise,errorMessage:t}),ni.emptyPromise}return}}async getDiffForLine(e,t,i,s){ke.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const r=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===r)return;return r.lines[t-r.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){ke.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Mt.diff_nameStatus(e,t,i,s);return Ye.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Mt.log_recent(e,t)}async getLogCommit(e,t){ke.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){ke.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Mt.isResolveRequired(i.ref)?o||u.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),ke.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?vr.config.advanced.maxListItems||0:t.maxCount;try{const s=await Mt.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=yt.parse(s,We.Branch,e,void 0,t.ref,i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){ke.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?vr.config.advanced.maxListItems||0:s.maxCount,r=void 0;switch(i){case Xt.Author:r=[`--author=${t}`];break;case Xt.ChangedOccurrences:r=[`-S${t}`,"--pickaxe-regex"];break;case Xt.Changes:r=[`-G${t}`];break;case Xt.Files:r=["--",`${t}`];break;case Xt.Message:r=[`--grep=${t}`];break;case Xt.Sha:r=[t],o=1}try{const a=await Mt.log_search(e,r,{maxCount:o}),n=yt.parse(a,We.Branch,e,void 0,void 0,o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===w.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=vr.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await vr.tracker.getOrAdd(new Ie(A.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return ke.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;if("log"!==s){const r=o.state.get("log");if(void 0!==r){if(void 0===i.ref)return ke.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;ke.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await r.item;if(void 0!==o&&o.commits.has(i.ref))return ke.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item}}}ke.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new Qt(o.key))}else ke.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(ke.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return ke.log(`Skipping log; '${t}' is not tracked`),ni.emptyPromise;const[r,a]=Mt.splitPath(t,e,!1);try{const{range:n}=i,h=c.__rest(i,["range"]),l=null==i.maxCount?vr.config.advanced.maxListItems||0:i.maxCount,d=await Mt.log_file(a,r,Object.assign({},h,{maxCount:l,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),m=yt.parse(d,We.File,a,r,h.ref,l,h.reverse,n);if(void 0!==m){const s=Object.assign({},i);m.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return m}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return ke.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:ni.emptyPromise,errorMessage:t}),ni.emptyPromise}return}}async hasRemote(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemote()}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async getMergeBase(e,t,i,s={}){try{const o=await Mt.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void ke.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];ke.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];ke.log(`getRemotesCore('${e}')`),t=t||Pe.createMap(br.get(br.name("remotes").value,null));try{const i=await Mt.remote(e);return St.parse(i,e,Pe.factory(t))}catch(e){return ke.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(void 0===e)return await this.getActiveRepoPath();if(e instanceof Ie)return e.repoPath;const i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await vr.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s),r=void 0===o?A.workspace.getWorkspaceFolder(A.Uri.file(s)):o.folder;if(void 0!==r){const e=new rt(r,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended);this._repositoryTree.set(s,e),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}return s}async getRepoPathCore(e,t){try{return await Mt.revparse_toplevel(t?e:Ee.dirname(e))}catch(e){return void ke.error(e,"GitService.getRepoPathCore")}}async getRepositories(){return(await this.getRepositoryTree()).values()}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Ie){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;ke.log(`getStashList('${e}')`);const t=await Mt.stash_list(e);return kt.parse(t,e)}async getStatusForFile(e,t){ke.log(`getStatusForFile('${e}', '${t}')`);const i=Mt.validateVersion(2,11)?2:1,s=await Mt.status_file(e,t,i),o=Pt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;ke.log(`getStatusForRepo('${e}')`);const t=Mt.validateVersion(2,11)?2:1,i=await Mt.status(e,t);return Pt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];ke.log(`getTags('${e}')`);const t=await Mt.tag(e);return Rt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(ke.log(`getVersionedFile('${e}', '${t}', '${i}')`),!i||Mt.isUncommitted(i)&&!Mt.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await Mt.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Ie.toKey(s),new Ie(A.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return ke.log(`getVersionedFileText('${e}', '${t}', ${i})`),Mt.show(e,t,i,{encoding:ni.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Ie.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===V.File||t===V.Git||t===V.GitLensGit}async isTracked(e,t,i={}){if(i.ref===ni.deletedSha)return!1;let s,o,r=i.ref;if("string"==typeof e)[o,t]=Mt.splitPath(e,t),s=Ie.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,r=e.sha,s=Ie.toKey(o)}void 0!==r&&(s+=`:${r}`),ke.log(`isTracked('${o}', '${t}', '${r}')`);let a=this._trackedCache.get(s);return void 0!==a?await a:(a=this.isTrackedCore(o,void 0===t?"":t,r),i.skipCacheUpdate?a:(this._trackedCache.set(s,a),a=await a,this._trackedCache.set(s,a),a))}async isTrackedCore(e,t,i){if(i===ni.deletedSha)return!1;try{let s=!!await Mt.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Mt.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Mt.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return ke.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Mt.config_get("diff.guitool",e)||await Mt.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ke.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Mt.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ke.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Mt.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return ni.isResolveRequired(t)?(ke.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),void 0===i?await Mt.revparse(e,t)||t:await Mt.log_resolve(e,w.normalizePath(Ee.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return ke.log(`stashApply('${e}', '${t}', ${i})`),Mt.stash_apply(e,t,i)}stashDelete(e,t){return ke.log(`stashDelete('${e}', '${t}')`),Mt.stash_delete(e,t)}stashSave(e,t,i){if(ke.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Mt.stash_save(e,t);const s=i.map(t=>Mt.splitPath(t.fsPath,e)[0]);return Mt.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?A.Uri.file(Ee.join(e,t)):e;return Mt.getEncoding(A.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Mt.getGitInfo(e)}static getGitPath(){return Mt.gitInfo().path}static getGitVersion(){return Mt.gitInfo().version}static isResolveRequired(e){return Mt.isResolveRequired(e)}static isSha(e){return Mt.isSha(e)}static isStagedUncommitted(e){return Mt.isStagedUncommitted(e)}static isUncommitted(e){return Mt.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===ni.deletedSha?t.deleted:Mt.isSha(e)||Mt.isStagedUncommitted(e)?Mt.shortenSha(e,t):e}static validateGitVersion(e,t){const[i,s]=this.getGitVersion().split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}}ni.emptyPromise=Promise.resolve(void 0),ni.deletedSha="ffffffffffffffffffffffffffffffffffffffff",ni.stagedUncommittedSha=Mt.stagedUncommittedSha,ni.uncommittedSha=Mt.uncommittedSha,(ei=Zt||(Zt={})).ActiveEditorChanged="active-editor-changed",ei.AutoRefreshChanged="auto-refresh-changed",ei.Command="command",ei.ConfigurationChanged="configuration",ei.NodeCommand="node-command",ei.RepoChanged="repo-changed",ei.ViewChanged="view-changed",ei.VisibleEditorsChanged="visible-editors-changed",(ii=ti||(ti={})).Branch="gitlens:branch",ii.BranchWithTracking="gitlens:branch:tracking",ii.Branches="gitlens:branches",ii.BranchesWithRemotes="gitlens:branches:remotes",ii.CurrentBranch="gitlens:branch:current",ii.CurrentBranchWithTracking="gitlens:branch:current:tracking",ii.RemoteBranch="gitlens:branch:remote",ii.Commit="gitlens:commit",ii.CommitOnCurrentBranch="gitlens:commit:current",ii.CommitFile="gitlens:file:commit",ii.Commits="gitlens:commits",ii.ComparisonResults="gitlens:results:comparison",ii.FileHistory="gitlens:history-file",ii.Folder="gitlens:folder",ii.History="gitlens:history",ii.Message="gitlens:message",ii.Pager="gitlens:pager",ii.Remote="gitlens:remote",ii.Remotes="gitlens:remotes",ii.Repositories="gitlens:repositories",ii.Repository="gitlens:repository",ii.Results="gitlens:results",ii.ResultsCommits="gitlens:results:commits",ii.ResultsFiles="gitlens:results:files",ii.SearchResults="gitlens:results:search",ii.Stash="gitlens:stash",ii.StashFile="gitlens:file:stash",ii.Stashes="gitlens:stashes",ii.Status="gitlens:status",ii.StatusFile="gitlens:file:status",ii.StatusFiles="gitlens:status:files",ii.StatusFileCommits="gitlens:status:file-commits",ii.StatusUpstream="gitlens:status:upstream",ii.Tag="gitlens:tag",ii.Tags="gitlens:tags";class hi extends A.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class ci extends hi{get repoPath(){return this.uri.repoPath}}class li extends hi{constructor(e,t){super(new Ie),this.message=e,this.tooltip=t}getChildren(){return[]}getTreeItem(){const e=new A.TreeItem(this.message,A.TreeItemCollapsibleState.None);return e.contextValue=ti.Message,e.tooltip=this.tooltip,e}}class di extends hi{constructor(e,t,i){super(new Ie),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new A.TreeItem(this.message,A.TreeItemCollapsibleState.None);return e.contextValue=ti.Pager,e.command=this.getCommand(),e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:vr.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class mi extends di{constructor(e,t,i){super(`${e} ${K.Space}${K.Dash}${K.Space} this may take a while`,t,i),this.args={maxCount:0}}}class ui extends hi{constructor(e,t,i,s,o){super(Ie.fromRepoPath(e)),this.repoPath=e,this.branchFolderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of s.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new ui(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Folder,e.iconPath=A.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.branchFolderName}}(oi=si||(si={}))[oi.CommitLabel=1]="CommitLabel",oi[oi.FileLabel=2]="FileLabel",oi[oi.CommitIcon=4]="CommitIcon",oi[oi.StatusIcon=8]="StatusIcon",oi[oi.Gravatar=16]="Gravatar",oi[oi.File=10]="File";class gi extends hi{constructor(e,t,i,s){super(Ie.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await vr.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,e.tooltip=this.tooltip,(this.displayAs&si.CommitIcon)===si.CommitIcon)e.iconPath={dark:vr.context.asAbsolutePath(Ee.join("images","dark","icon-commit.svg")),light:vr.context.asAbsolutePath(Ee.join("images","light","icon-commit.svg"))};else if((this.displayAs&si.StatusIcon)===si.StatusIcon){const t=mt(this.status.status);e.iconPath={dark:vr.context.asAbsolutePath(Ee.join("images","dark",t)),light:vr.context.asAbsolutePath(Ee.join("images","light",t))}}else(this.displayAs&si.Gravatar)===si.Gravatar&&(e.iconPath=this.commit.getGravatarUri(vr.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,this._tooltip=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Ee.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&si.CommitLabel?qt.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dataFormat:vr.config.defaultDateFormat}):Yt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0,this._tooltip=void 0}get resourceType(){return ti.CommitFile}get tooltip(){return void 0===this._tooltip&&(this.displayAs&si.CommitLabel?this._tooltip=qt.fromTemplate(this.commit.isUncommitted?`\${author} ${K.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${K.Dash} \${id}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dataFormat:vr.config.defaultDateFormat}):this._tooltip=Yt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status)),this._tooltip}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:ri.DiffWithPrevious,arguments:[Ie.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class pi extends hi{constructor(e,t,i,s,o){super(Ie.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(pi.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==_.List){e=[];for(const t of s.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new pi(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof pi?-1:1)-(t instanceof pi?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Folder,e.iconPath=A.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||_.Auto;if(s===_.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return _.List}return _.Tree}return s}}class fi extends ci{constructor(e,t,i,s){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i,this.trackingRef=s}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...u.map(e.fileStatuses,t=>new gi(t,e.toFileCommit(t),this.explorer,si.File))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(Ee.join(...e)),this.explorer.config.files.compact),i=new pi(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){let e=qt.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:vr.config.defaultDateFormat});this.trackingRef===this.commit.sha&&(e=`${K.AngleBracketLeftHeavy}${K.SpaceThin}${this.branch.tracking}${K.SpaceThin}${K.AngleBracketRightHeavy}${K.ArrowHeadRight}${K.Space} ${e}`);const t=new A.TreeItem(e,A.TreeItemCollapsibleState.Collapsed);return t.contextValue=void 0===this.branch||this.branch.current?ti.CommitOnCurrentBranch:ti.Commit,this.explorer.config.avatars?t.iconPath=this.commit.getGravatarUri(vr.config.defaultGravatarsStyle):t.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-commit.svg"),light:vr.context.asAbsolutePath("images/light/icon-commit.svg")},t.tooltip=qt.fromTemplate(this.commit.isUncommitted?`\${author} ${K.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${K.Dash} \${id}${this.trackingRef===this.commit.sha?` (${this.branch.tracking})`:""}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dataFormat:vr.config.defaultDateFormat}),t}getCommand(){return{title:"Compare File with Previous Revision",command:ri.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class vi extends ci{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===k.List?e:Qe.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await vr.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new li("No commits yet")];let t=void 0;void 0!==this.branch.tracking&&(t=await vr.git.getMergeBase(this.uri.repoPath,this.branch.name,this.branch.tracking));const i=[...u.map(e.commits.values(),e=>new fi(e,this.explorer,this.branch,t))];return e.truncated&&i.push(new mi("Show All Commits",this,this.explorer)),i}async getTreeItem(){let e=this.label,t=`${this.branch.getName()}${this.branch.current?" (current)":""}`,i="";this.branch.remote||void 0===this.branch.tracking||(this.explorer.config.showTrackingBranch&&(e+=` ${K.Space}${K.ArrowLeftRightLong}${this.branch.getTrackingStatus({prefix:`${K.Space} `})}${K.Space} ${this.branch.tracking}`),t+=`\n\nTracking ${K.Dash} ${this.branch.tracking}\n${this.branch.getTrackingStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(this.branch.state.ahead||this.branch.state.behind)&&(this.branch.state.behind&&(i="-red"),this.branch.state.ahead&&(i=this.branch.state.behind?"-yellow":"-green")));const s=new A.TreeItem(`${this.branch.current?`${K.Check} ${K.Space}`:""}${e}`,A.TreeItemCollapsibleState.Collapsed);return s.tooltip=t,this.branch.remote?s.contextValue=ti.RemoteBranch:this.branch.current?s.contextValue=this.branch.tracking?ti.CurrentBranchWithTracking:ti.CurrentBranch:s.contextValue=this.branch.tracking?ti.BranchWithTracking:ti.Branch,s.iconPath={dark:vr.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:vr.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},s}}class wi extends hi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:branches`}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...u.filterMap(e,e=>e.remote?void 0:new vi(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===k.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),r=new ui(this.repo.path,"",void 0,s,this.explorer),a=await r.getChildren();return void 0!==i&&a.splice(0,0,i),a}async getTreeItem(){const e=new A.TreeItem("Branches",this.active?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?ti.BranchesWithRemotes:ti.Branches,e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-branch.svg"),light:vr.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class Ci extends hi{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...u.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new vi(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===k.List)return t;const i=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new ui(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ze.Fetch),t=this.remote.types.find(e=>e.type===Ze.Push);let i;i=e&&t?K.ArrowLeftRightLong:e?K.ArrowLeft:t?K.ArrowRight:K.Dash;const s=`${this.remote.name} ${K.Space}${i}${K.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${K.Space}${K.Dot}${K.Space} ${this.remote.path}`,o=new A.TreeItem(s,A.TreeItemCollapsibleState.Collapsed);return o.contextValue=ti.Remote,o.tooltip=`${this.remote.name}\n${this.remote.path} (${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain})`,void 0!==this.remote.provider?o.iconPath={dark:vr.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:vr.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:o.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-remote.svg"),light:vr.context.asAbsolutePath("images/light/icon-remote.svg")},o}}class bi extends hi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:remotes`}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new li("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...u.map(e,e=>new Ci(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new A.TreeItem("Remotes",A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Remotes,e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-remote.svg"),light:vr.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class yi extends hi{constructor(e,t,i,s){super(Ie.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new gi(this.status,e,this.explorer,si.CommitLabel|(this.explorer.config.avatars?si.Gravatar:si.CommitIcon)))}async getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.Collapsed);1===this.commits.length&&this.commit.isUncommitted?(e.collapsibleState=A.TreeItemCollapsibleState.None,e.contextValue=ti.StatusFile,this.commit.isStagedUncommitted?e.tooltip=Yt.fromTemplate("${status} in index\n\n${file}\n${directory}/",this.status):e.tooltip=Yt.fromTemplate("${status} in working tree\n\n${file}\n${directory}/",this.status),e.command=this.getCommand()):(e.contextValue=ti.StatusFileCommits,e.tooltip=Yt.fromTemplate(`\${status} in ${this.getChangedIn()}\n\n\${file}\n\${directory}/`,this.status));const t=mt(this.status.status);return e.iconPath={dark:vr.context.asAbsolutePath(Ee.join("images","dark",t)),light:vr.context.asAbsolutePath(Ee.join("images","light",t))},this._label=void 0,e.tooltip=e.tooltip.charAt(0).toUpperCase()+e.tooltip.slice(1),e}get folderName(){return void 0===this._folderName&&(this._folderName=Ee.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Yt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getChangedIn(){const e=[];let t=0;for(const i of this.commits)i.isUncommitted?i.isStagedUncommitted?e.push("working tree"):e.push("index"):t++;return t>0&&e.push(`${t} ${1===t?"commit":"commits"}`),e.length>2&&(e[e.length-1]=`and ${e[e.length-1]}`),e.join(e.length>2?", ":" and ")}getCommand(){return{title:"Compare File with Previous Revision",command:ri.DiffWithPrevious,arguments:[Ie.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class xi extends hi{constructor(e,t,i,s=!1){super(Ie.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await vr.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(u.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...u.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new Je(We.File,t,ni.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,ni.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new Je(We.File,t,ni.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new Je(We.File,t,ni.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new Je(We.File,t,ni.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const r=o.groupBy(e,e=>e.fileName);let a=[...u.map(s.values(r),e=>new yi(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(a,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(Ee.join(...e)),this.explorer.config.files.compact),i=new pi(t,"",void 0,e,this.explorer);a=await i.getChildren()}else a.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&a.push(new mi("Show All Changes",this,this.explorer)),a}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await vr.git.getChangedFilesCount(this.repoPath,this.status.upstream);void 0!==t&&(e=t.files)}const t=`${e} ${1===e?"file":"files"} changed`,i=new A.TreeItem(t,A.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=ti.StatusFiles,i.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-diff.svg"),light:vr.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class $i extends hi{constructor(e,t,i,s=!1){super(Ie.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream:${this.direction}`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await vr.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...u.map(t.commits.values(),e=>new fi(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await vr.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=u.first(t.commits.values())),[...u.map(i,e=>new fi(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} ${1===this.status.state.ahead?"commit":"commits"} (ahead of ${this.status.upstream})`:`${this.status.state.behind} ${1===this.status.state.behind?"commit":"commits"} (behind ${this.status.upstream})`,t=new A.TreeItem(e,A.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=ti.StatusUpstream,t.iconPath={dark:vr.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:vr.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class Si extends hi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new $i(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new $i(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new xi(e,t,this.explorer,this.active))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new A.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=A.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o=`${e.getUpstreamStatus({prefix:`${K.Space} `})}${i?e.getDiffStatus({prefix:`${K.Space} `}):""}`,r=`${e.branch} (current)`,a="";e.upstream&&(this.explorer.config.showTrackingBranch&&(o+=`${K.Space} ${e.upstream}`),r+=`\n\nTracking ${K.Dash} ${e.upstream}\n${e.getUpstreamStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(e.state.ahead||e.state.behind)&&(t=!0,e.state.behind&&(a="-red"),e.state.ahead&&(a=e.state.behind?"-yellow":"-green"))),o=`${e.branch}${""===o?"":` ${K.Space}${e.upstream?K.ArrowLeftRightLong:K.Dash}${o}`}`,i&&(r+=`\n\nHas uncommitted changes${e.getDiffStatus({expand:!0,prefix:"\n",separator:"\n"})}`),s=t||i?this.active?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.Collapsed:A.TreeItemCollapsibleState.None;const n=new A.TreeItem(o,s);return n.id=this.id,n.contextValue=ti.Status,n.tooltip=r,n.iconPath={dark:vr.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:vr.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},n}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class Di extends gi{constructor(e,t,i){super(e,t,i,si.File)}get resourceType(){return ti.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class ki extends ci{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await vr.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=u.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new Di(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new A.TreeItem(qt.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:vr.config.defaultDateFormat}),A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Stash,e.tooltip=qt.fromTemplate("${ago} (${date})\n\n${message}",this.commit,{dataFormat:vr.config.defaultDateFormat}),e}}class _i extends hi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:stashes`}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new li("No stashed changes")]:[...u.map(e.commits.values(),e=>new ki(e,this.explorer))]}getTreeItem(){const e=new A.TreeItem("Stashes",A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Stashes,e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-stash.svg"),light:vr.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class Fi extends ci{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get ref(){return this.tag.name}async getChildren(){const e=await vr.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new li("No commits yet")];const t=[...u.map(e.commits.values(),e=>new fi(e,this.explorer))];return e.truncated&&t.push(new mi("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new A.TreeItem(this.tag.name,A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Tag,e}}class Pi extends hi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:tags`}async getChildren(){const e=await this.repo.getTags();return 0===e.length?[new li("No tags yet")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...e.map(e=>new Fi(e,this.uri,this.explorer))])}async getTreeItem(){const e=new A.TreeItem("Tags",A.TreeItemCollapsibleState.Collapsed);return e.contextValue=ti.Tags,e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-tag.svg"),light:vr.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class Ri extends hi{constructor(e,t,i,s=!1,o){super(e),this.repo=t,this.explorer=i,this.active=s,this.activeParent=o}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return this.resetChildren(),this.updateSubscription(),this.children=[new Si(this.uri,this.repo,this.explorer,this.active),new wi(this.uri,this.repo,this.explorer,this.active),new bi(this.uri,this.repo,this.explorer,this.active),new _i(this.uri,this.repo,this.explorer,this.active),new Pi(this.uri,this.repo,this.explorer,this.active)],this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${w.pad(K.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new A.TreeItem(e,this.active?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=ti.Repository,t}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||A.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(ke.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(et.Repository)||e.changed(et.Config))this.explorer.refreshNode(this.active&&void 0!==this.activeParent?this.activeParent:this);else{if(e.changed(et.Stashes)){const e=this.children.find(e=>e instanceof _i);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(et.Remotes)){const e=this.children.find(e=>e instanceof bi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(et.Tags)){const e=this.children.find(e=>e instanceof Pi);void 0!==e&&this.explorer.refreshNode(e)}}}}class Ti extends hi{constructor(e){super(void 0),this.explorer=e,vr.context.subscriptions.push(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(A.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!J(e))return;let t=!1;try{const i=await vr.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await vr.git.getRepository(i);if(void 0===s)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new Ri(Ie.fromRepoPath(s.path),s,this.explorer,!0,this)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new A.TreeItem("No active repository",A.TreeItemCollapsibleState.None);return e.id=this.id,e}}class Ei extends hi{constructor(e,t,i=ti.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new fi(this.commit,this.explorer).getChildren();return e.splice(0,0,new li(qt.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!0}),qt.fromTemplate("${message}",this.commit))),e}async getTreeItem(){const e=qt.fromTemplate(`Commit \${sha} ${w.pad(K.Dash,1,1)} \${authorAgo}`,this.commit,vr.config.defaultDateFormat),t=new A.TreeItem(e,A.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class Bi extends hi{constructor(e,t,i,s,o=ti.ResultsCommits){super(Ie.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...u.map(e.commits.values(),e=>new fi(e,this.explorer))];return e.truncated&&t.push(new mi("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new A.TreeItem(await this.getLabel(),e&&e.count>0?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class Ni extends hi{constructor(e,t,i,s,o){super(Ie.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new A.TreeItem(this.label,A.TreeItemCollapsibleState.None);e.contextValue=ti.StatusFile,e.tooltip=Yt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status);const t=mt(this.status.status);return e.iconPath={dark:vr.context.asAbsolutePath(Ee.join("images","dark",t)),light:vr.context.asAbsolutePath(Ee.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=Ee.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Yt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:ri.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Ie.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Ai extends hi{constructor(e,t,i,s){super(Ie.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...u.map(e,e=>new Ni(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(Ee.join(...e)),this.explorer.config.files.compact),i=new pi(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new A.TreeItem(await this.getLabel(),e&&e.length>0?A.TreeItemCollapsibleState.Expanded:A.TreeItemCollapsibleState.None);return t.contextValue=ti.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await vr.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),t=void 0!==e?e.length:0,i=`${0===t?"No":t} ${1===t?"file":"files"} changed`;this._cache={label:i,diff:e}}return this._cache}async getDiff(){return(await this.ensureCache()).diff}async getLabel(){return(await this.ensureCache()).label}}class Ui extends hi{constructor(e,t,i,s){super(Ie.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){return this.resetChildren(),this.children=[new Bi(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>vr.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new Ai(this.uri.repoPath,this.ref1.ref,this.ref2.ref,this.explorer)],this.children}async getTreeItem(){let e="";if(await vr.git.getRepositoryCount()>1){const t=await vr.git.getRepository(this.uri.repoPath);e=` ${w.pad(K.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new A.TreeItem(`Comparing ${this.ref1.label||ni.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||ni.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,A.TreeItemCollapsibleState.Expanded);return t.contextValue=ti.ComparisonResults,t}}class Li extends hi{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=si.CommitLabel|(this.explorer.config.avatars?si.Gravatar:si.StatusIcon),i=await vr.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=ni.uncommittedSha,void 0!==i.indexStatus?o=ni.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=ni.stagedUncommittedSha,o="HEAD");const r=new Je(We.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new gi(i,r,this.explorer,t))}const s=await vr.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...u.map(s.commits.values(),e=>new gi(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new li("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new A.TreeItem(`${this.uri.getFormattedPath()}`,A.TreeItemCollapsibleState.Expanded);return e.contextValue=ti.FileHistory,e.tooltip=`History of ${this.uri.getFilename()}\n${this.uri.getDirectory()}/`,e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-history.svg"),light:vr.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.disposable=this.disposable||this.repo.onDidChange(this.onRepoChanged,this)}onRepoChanged(e){e.changed(et.Repository)&&(ke.log(`FileHistoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class Oi extends hi{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new Li(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new A.TreeItem(`${this.uri.getFormattedPath()}`,A.TreeItemCollapsibleState.Expanded);return e.contextValue=ti.History,e.iconPath={dark:vr.context.asAbsolutePath("images/dark/icon-history.svg"),light:vr.context.asAbsolutePath("images/light/icon-history.svg")},e}}class Ii extends hi{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return this.resetChildren(),this.children=this.repositories.sort((e,t)=>e.index-t.index).map(e=>new Ri(Ie.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new Ti(this.explorer)),this.children}getTreeItem(){const e=new A.TreeItem("Repositories",A.TreeItemCollapsibleState.Expanded);return e.contextValue=ti.Repositories,e}}function Mi(e,t){return e instanceof A.Uri?e:void 0!==t&&void 0!==t.document?t.document.uri:void 0}function Wi(e){return"view"===e.type&&e.node.branch&&e.node.branch instanceof Qe}function Hi(e){return"view"===e.type&&e.node.commit&&e.node.commit instanceof Ge}function ji(e){return"view"===e.type&&e.node.remote&&e.node.remote instanceof st}function Gi(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates)}function Vi(e){return void 0!==e&&void 0!==e.resourceUri}(ai=ri||(ri={})).ClearFileAnnotations="gitlens.clearFileAnnotations",ai.CloseUnchangedFiles="gitlens.closeUnchangedFiles",ai.ComputingFileAnnotations="gitlens.computingFileAnnotations",ai.CopyMessageToClipboard="gitlens.copyMessageToClipboard",ai.CopyShaToClipboard="gitlens.copyShaToClipboard",ai.DiffDirectory="gitlens.diffDirectory",ai.DiffHeadWithBranch="gitlens.diffHeadWithBranch",ai.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",ai.ExternalDiffAll="gitlens.externalDiffAll",ai.DiffWith="gitlens.diffWith",ai.DiffWithBranch="gitlens.diffWithBranch",ai.DiffWithNext="gitlens.diffWithNext",ai.DiffWithPrevious="gitlens.diffWithPrevious",ai.DiffLineWithPrevious="gitlens.diffLineWithPrevious",ai.DiffWithRevision="gitlens.diffWithRevision",ai.DiffWithWorking="gitlens.diffWithWorking",ai.DiffLineWithWorking="gitlens.diffLineWithWorking",ai.ExternalDiff="gitlens.externalDiff",ai.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",ai.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",ai.OpenChangedFiles="gitlens.openChangedFiles",ai.OpenBranchesInRemote="gitlens.openBranchesInRemote",ai.OpenBranchInRemote="gitlens.openBranchInRemote",ai.OpenCommitInRemote="gitlens.openCommitInRemote",ai.OpenFileInRemote="gitlens.openFileInRemote",ai.OpenFileRevision="gitlens.openFileRevision",ai.OpenInRemote="gitlens.openInRemote",ai.OpenRepoInRemote="gitlens.openRepoInRemote",ai.OpenWorkingFile="gitlens.openWorkingFile",ai.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",ai.ShowCommitSearch="gitlens.showCommitSearch",ai.ShowLastQuickPick="gitlens.showLastQuickPick",ai.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",ai.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",ai.ShowQuickFileHistory="gitlens.showQuickFileHistory",ai.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",ai.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",ai.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",ai.ShowQuickStashList="gitlens.showQuickStashList",ai.ShowSettingsPage="gitlens.showSettingsPage",ai.ShowWelcomePage="gitlens.showWelcomePage",ai.StashApply="gitlens.stashApply",ai.StashDelete="gitlens.stashDelete",ai.StashSave="gitlens.stashSave",ai.ToggleCodeLens="gitlens.toggleCodeLens",ai.ToggleFileBlame="gitlens.toggleFileBlame",ai.ToggleFileHeatmap="gitlens.toggleFileHeatmap",ai.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",ai.ToggleLineBlame="gitlens.toggleLineBlame";class Qi extends A.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=A.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>A.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=A.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=Qi.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(void 0===o||function(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(void 0===o||o instanceof A.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof hi){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(Vi(o)){const t=[];let s=0;for(const e of i){if(!Vi(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(Gi(o)){const t=[];let s=0;for(const e of i){if(!Gi(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class Ki extends Qi{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,A.window.activeTextEditor,...t)}}let zi=void 0;class qi extends Ki{constructor(e){super(e)}_execute(e,...t){return zi={command:e,args:t},super._execute(e,...t)}}class Yi extends A.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(A.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=A.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Xi(e,t={}){const{rethrow:i}=t,s=c.__rest(t,["rethrow"]);try{if(e instanceof Ie&&(e=e.fileUri({noSha:!0})),e.scheme===V.GitLensGit){const t=Ie.fromRevisionUri(e);if(Z.includes(Ee.extname(t.fsPath))){const i=await vr.git.getVersionedFile(t.repoPath,t.fsPath,t.sha);if(void 0!==i)return e=A.Uri.file(i),void await A.commands.executeCommand(W.Open,e)}}const o=await A.workspace.openTextDocument(e);return A.window.showTextDocument(o,Object.assign({preserveFocus:!1,preview:!0,viewColumn:A.ViewColumn.Active},s))}catch(t){if(t.toString().includes("File seems to be binary and cannot be opened as text"))return void await A.commands.executeCommand(W.Open,e);if(i)throw t;return void ke.error(t,"openEditor")}}class Ji extends Yi{constructor(){super([ri.ClearFileAnnotations,ri.ComputingFileAnnotations])}async execute(e,t,i){if(void 0!==e){if(void 0!==i&&!re.equals(i,e.document.uri)){const t=A.window.visibleTextEditors.find(e=>re.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return vr.fileAnnotations.clear(e)}catch(e){return ke.error(e,"ClearFileAnnotationsCommand"),A.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class Zi extends A.Disposable{constructor(){super(()=>this.dispose());const e=m.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=A.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return A.commands.executeCommand(W.CloseActiveEditor)}async next(){return A.commands.executeCommand(W.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=0,t(e))}),s=setTimeout(()=>{t(A.window.activeTextEditor),s=0},e)});return this._resolver=void 0,t}}var es,ts;(ts=es||(es={})).CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",ts.CommitNotFoundWarning="suppressCommitNotFoundWarning",ts.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",ts.GitVersionWarning="suppressGitVersionWarning",ts.LineUncommittedWarning="suppressLineUncommittedWarning",ts.NoRepositoryWarning="suppressNoRepositoryWarning",ts.ResultsExplorerNotice="suppressResultsExplorerNotice",ts.ShowKeyBindingsNotice="suppressShowKeyBindingsNotice";class is{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?is.showMessage("info","Commit has no previous commit.",es.CommitHasNoPreviousCommitWarning):is.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit.`,es.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return is.showMessage("warn",`${e}. The commit could not be found.`,es.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return is.showMessage("warn",`${e}. The file is probably not under source control.`,es.FileNotUnderSourceControlWarning)}static async showKeyBindingsInfoMessage(){const e=br.name("advanced")("messages").value,t=br.get(e);if(t[es.ShowKeyBindingsNotice])return;if(vr.config.keymap!==E.Alternate)return t[es.ShowKeyBindingsNotice]=!0,void await br.update(e,t,A.ConfigurationTarget.Global);const i=[{title:"Keep Shortcuts",isCloseAffordance:!0},{title:"Switch Shortcuts"},{title:"No Shortcuts"}],s=await is.showMessage("info","GitLens is using keyboard shortcuts which can conflict with menu mnemonics and different keyboard layouts. To avoid such conflicts, it is recommended to switch to the new default keyboard shortcuts.",es.ShowKeyBindingsNotice,null,...i);switch(s){case i[1]:await br.update(br.name("keymap").value,E.Chorded,A.ConfigurationTarget.Global);break;case i[2]:await br.update(br.name("keymap").value,E.None,A.ConfigurationTarget.Global)}return s}static showLineUncommittedWarningMessage(e){return is.showMessage("warn",`${e}. The line has uncommitted changes.`,es.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return is.showMessage("warn",`${e}. No repository could be found.`,es.NoRepositoryWarning)}static showResultExplorerInfoMessage(){return is.showMessage("info",'If you can\'t find your results, click on "GITLENS RESULTS" at the bottom of the Explorer view.',es.ResultsExplorerNotice,null)}static showUnsupportedGitVersionErrorMessage(e){return is.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git.`,es.GitVersionWarning)}static async showMessage(e,t,i,s={title:"Don't Show Again"},...o){if(ke.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),br.get(br.name("advanced")("messages")(i).value))return void ke.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let r=void 0;switch(e){case"info":r=await A.window.showInformationMessage(t,...o);break;case"warn":r=await A.window.showWarningMessage(t,...o);break;case"error":r=await A.window.showErrorMessage(t,...o)}if(null===s||r===s){ke.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`);const o=br.name("advanced")("messages").value,a=br.get(o);if(a[i]=!0,await br.update(o,a,A.ConfigurationTarget.Global),r===s)return}return ke.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${r?r.title:r}`),r}}class ss extends Ki{constructor(){super(ri.CloseUnchangedFiles)}async execute(e,t,i={}){t=Mi(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await vr.git.getRepoPath(t);if(!e)return is.showNoRepositoryWarningMessage("Unable to close unchanged files");const s=await vr.git.getStatusForRepo(e);if(void 0===s)return A.window.showWarningMessage("Unable to close unchanged files");i.uris=s.files.map(e=>e.uri)}if(0===i.uris.length)return A.commands.executeCommand(W.CloseAllEditors);const s=new Zi;let o=0,r=void 0,a=A.window.activeTextEditor;for(;;){if(void 0!==a){if(oe.equals(r,a,{useId:!0,usePosition:!0}))break;if(void 0!==a.document&&(a.document.isDirty||i.uris.some(e=>re.equals(e,a.document&&a.document.uri)))){const e=r;if(r=a,a=await s.awaitNext(500),oe.equals(e,a,{useId:!0,usePosition:!0}))break;continue}}if(r=a,a=await s.awaitClose(500),void 0===r&&void 0===a){if(++o>=4)break}else o=0}return void s.dispose()}catch(e){return ke.error(e,"CloseUnchangedFilesCommand"),A.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class os extends Ki{constructor(){super(ri.CopyMessageToClipboard)}async preExecute(e,t={}){return Hi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=Mi(t,e);const o=await Promise.resolve().then(function(){var e=i(12);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});try{if(s=Object.assign({},s),void 0===t){const t=await vr.git.getActiveRepoPath(e);if(!t)return;const i=await vr.git.getLog(t,{maxCount:1});if(!i)return;return s.message=u.first(i.commits.values()).message,void o.copy(s.message)}const i=await Ie.fromUri(t);if(void 0===s.message){if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await vr.git.getBlameForLineContents(i,t,e.document.getText()):await vr.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return ke.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const t=await vr.git.getLogCommit(i.repoPath,s.sha);if(void 0===t)return;s.message=t.message}return void o.copy(s.message,e=>{if(e){if(e.message.includes("xclip"))return void A.window.showErrorMessage("Unable to copy message, xclip is not installed. You can install it via `sudo apt-get install xclip`");ke.error(e,"CopyMessageToClipboardCommand"),A.window.showErrorMessage("Unable to copy message. See output channel for more details")}})}catch(e){return ke.error(e,"CopyMessageToClipboardCommand"),A.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class rs extends Ki{constructor(){super(ri.CopyShaToClipboard)}async preExecute(e,t={}){return Hi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=Mi(t,e);const o=await Promise.resolve().then(function(){var e=i(12);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});try{if(s=Object.assign({},s),void 0===t){const t=await vr.git.getActiveRepoPath(e);if(!t)return;const i=await vr.git.getLog(t,{maxCount:1});if(!i)return;return s.sha=u.first(i.commits.values()).sha,void o.copy(s.sha)}const i=await Ie.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await vr.git.getBlameForLineContents(i,t,e.document.getText()):await vr.git.getBlameForLine(i,t);if(void 0===o)return;s.sha=o.commit.sha}catch(e){return ke.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.copy(s.sha,e=>{if(e){if(e.message.includes("xclip"))return void A.window.showErrorMessage("Unable to copy commit id, xclip is not installed. You can install it via `sudo apt-get install xclip`");ke.error(e,"CopyShaToClipboardCommand"),A.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}})}catch(e){return ke.error(e,"CopyShaToClipboardCommand"),A.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}function as(){return!br.get(br.name("advanced")("quickPick")("closeOnFocusOut").value)}function ns(e,t){const i=new A.CancellationTokenSource;return async function(e,t,i){const s=i&&await vr.keyboard.beginScope(i);try{await A.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:as()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class hs{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):A.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class cs extends hs{constructor(e){super({label:e,description:""})}}class ls extends hs{constructor(e,t){super({label:"",description:""},e,t)}}class ds extends hs{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Xi(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class ms extends hs{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Xi(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class us{constructor(e){this.commit=e;const t=e.getShortMessage(`${K.Space}$(ellipsis)`);e.isStash?(this.label=t,this.description="",this.detail=`${K.Space} ${e.stashName||e.shortSha} ${w.pad(K.Dot,1,1)} ${e.formattedDate} ${w.pad(K.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${w.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${K.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${w.pad(K.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class gs extends hs{constructor(e,t={label:"Show in Results",description:`${w.pad(K.Dash,2,2)} displays commit in the GitLens Results view`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){vr.resultsExplorer.showCommitInResults(this.commit)}}class ps extends hs{constructor(e,t,i={label:"Show in Results",description:`${w.pad(K.Dash,2,2)} displays commits in the GitLens Results view`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){vr.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class fs extends ps{constructor(e,t,i={label:"Show in Results",description:`${w.pad(K.Dash,2,2)} displays results in the GitLens Results view`}){super(e,{label:t},i),this.results=e,this.search=t}}class vs extends hs{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${w.pad(K.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Ss.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([vr.git.getBranches(this.repoPath),vr.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Ss.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.dispose()}}}const ws=Object.create(null),Cs=["left","right",",",".","escape"],bs=[];class ys extends A.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||ws}async dispose(){const e=bs.indexOf(this.mapping);ke.log("KeyboardScope.dispose",bs.length,e),e===bs.length-1?(bs.pop(),await this.updateKeyCommandsContext(bs[bs.length-1])):bs.splice(e,1)}async begin(){return bs.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=bs[bs.length-1];t===this.mapping&&t[e]&&(ke.log("KeyboardScope.clearKeyCommand",bs.length,e),t[e]=void 0,await Y(`${j.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=bs[bs.length-1];i===this.mapping&&(ke.log("KeyboardScope.setKeyCommand",bs.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await Y(`${j.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Cs)t.push(Y(`${j.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class xs extends A.Disposable{constructor(){super(()=>this.dispose());const e=Cs.map(e=>A.commands.registerCommand(`${U}.key.${e}`,()=>this.execute(e),this));this._disposable=A.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return ke.log("Keyboard.beginScope",bs.length),await new ys(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(bs.length)try{let t=bs[bs.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return ke.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void ke.error(e,"Keyboard.execute")}}}class $s{constructor(e){this.branchOrTag=e,e instanceof Qe?(this.label=`${e.current?`$(check)${K.Space}`:K.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${K.Space.repeat(2)} remote branch`:""):(this.label=`${K.Space.repeat(4)} ${e.name}`,this.description=`${K.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Qe&&this.branchOrTag.remote}}class Ss{static showProgress(e){return ns(e,{left:ws,",":ws,".":ws})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new $s(e)),...t.map(e=>new $s(e)),...e.filter(e=>e.remote).map(e=>new $s(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await vr.keyboard.beginScope({left:s.goBackCommand||ws});s.progressCancellation&&s.progressCancellation.cancel();const a=await A.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:as()});return await r.dispose(),a}}class Ds{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${K.Space}`:K.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${K.Space.repeat(2)} remote branch`:""}}class ks{static async show(e,t,i={}){const s=e.map(e=>new Ds(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await A.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:as()})}}class _s extends hs{constructor(e,t){super({label:`$(link-external) Open ${de(t)} in ${e.provider.name}`,description:`${w.pad(K.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class Fs extends hs{constructor(e,t,i){const s=de(t);let o="";switch(t.type){case he.Branch:o=`$(git-branch) ${t.branch}`;break;case he.Branches:o="$(git-branch) Branches";break;case he.Commit:o=`$(git-commit) ${ni.shortenSha(t.sha)}`;break;case he.File:o=`$(file-text) ${Ee.basename(t.fileName)}`;break;case he.Repo:o="$(repo) Repository";break;case he.Revision:if(void 0!==t.commit&&t.commit instanceof Je)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${Ee.basename(t.fileName)} in ${K.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${K.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${Ee.basename(t.fileName)} in ${K.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":ni.shortenSha(t.sha);o=`$(file-text) ${Ee.basename(t.fileName)}${e?` in ${K.Space}$(git-commit) ${e}`:""}`}}const r=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===r.provider.name)?r.provider.name:"Remote"}${K.Ellipsis}`,description:`${w.pad(K.Dash,2,3)} ${o}`},ri.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${r.provider.name}`,description:`${w.pad(K.Dash,2,3)} $(repo) ${r.provider.path} ${w.pad(K.Dot,1,1)} ${o}`},ri.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class Ps{static async show(e,t,i,s){const o=e.map(e=>new _s(e,i));s&&o.splice(0,0,s);const r=await A.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:as()});if(void 0!==r)return r}}class Rs{static showProgress(e){return ns(`${e} history ${K.Dash} search by commit message, filename, or commit id`,{left:ws,",":ws,".":ws})}static async show(e,t,i,s,o,r){const a=Array.from(u.map(e.commits.values(),e=>new us(e))),n=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to ${K.Space}$(git-branch) ${i} history`},ri.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=await vr.git.getRemotes(t&&t.repoPath||e.repoPath);h.length&&a.splice(0,0,new Fs(h,{type:"branch",branch:i},n)),a.splice(0,0,new hs({label:"$(search) Show Commit Search",description:`${w.pad(K.Dash,2,3)} search for commits by message, author, files, or commit id`},ri.ShowCommitSearch,[Ie.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&a.splice(0,0,new hs({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ri.ShowQuickBranchHistory,[Ie.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),r&&a.splice(0,0,r),e.truncated)){const s=new hs({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${e.maxCount} newer commits`},ri.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),n=u.last(e.commits.values());null!=n&&(c=new hs({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${e.maxCount} older commits`},ri.ShowQuickBranchHistory,[new Ie(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),a.splice(0,0,c))}if(o&&a.splice(0,0,o),s.token.isCancellationRequested)return;const l=await vr.keyboard.beginScope({left:o,",":c,".":r});s.cancel();const d=await A.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${K.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:as()});return await l.dispose(),d}}class Ts extends hs{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${w.pad(K.Dash,2,3)} $(file-text) ${Ee.basename(e.fileName)} in ${K.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await vr.git.checkoutFile(e),Xi(e,{preserveFocus:!0,preview:!1})}}class Es extends ds{constructor(e,t){super(A.Uri.file(Ee.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${w.pad(K.Dash,2,3)} ${Ee.basename(e.fileName)}`})}}class Bs extends ds{constructor(e,t){let i,s;"D"===e.status?(s=Ie.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${w.pad(K.Dash,2,3)} ${Ee.basename(e.fileName)} in ${K.Space}$(git-commit) ${e.previousShortSha} (deleted in ${K.Space}$(git-commit) ${e.shortSha})`):(s=Ie.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${w.pad(K.Dash,2,3)} ${Ee.basename(e.fileName)} in ${K.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class Ns{static async show(e,t,i,s,o){const r=[],a=e.isStash,n=e.workingFileName&&Ee.basename(e.workingFileName)||Ee.basename(e.fileName),h=e.isUncommitted;if(h){const t=await vr.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),a&&r.push(new Ts(e)),e.previousFileShortSha&&r.push(new hs({label:"$(git-compare) Open Changes",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${K.Space} $(git-compare) ${K.Space} $(git-commit) ${e.shortSha}`},ri.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new hs({label:"$(git-compare) Open Changes with Working Tree",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.shortSha} ${K.Space} $(git-compare) ${K.Space} $(file-text) ${n}`},ri.DiffWithWorking,[A.Uri.file(Ee.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new Es(e)),r.push(new Bs(e));const c=await vr.git.getRemotes(e.repoPath);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await vr.git.getBranch(e.repoPath);r.push(new Fs(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}a||r.push(new Fs(c,{type:"revision",fileName:e.fileName,commit:e},s))}a||(r.push(new Ts(e)),r.push(new hs({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.shortSha}`},ri.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new hs({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ri.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new hs({label:"$(history) Show File History",description:`${w.pad(K.Dash,2,3)} of ${Ee.basename(e.fileName)}`},ri.ShowQuickFileHistory,[A.Uri.file(Ee.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),a||(r.push(new hs({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${w.pad(K.Dash,2,3)} of ${Ee.basename(e.fileName)} ${w.pad(K.Dot,1,1)} from ${K.Space}$(git-commit) ${e.shortSha}`},ri.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),r.push(new hs({label:"$(git-commit) Show Commit Details",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.shortSha}`},ri.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&r.splice(0,0,i);let l=void 0,d=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.previousSha){if(void 0===(s=await vr.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:vr.config.advanced.maxListItems,ref:e.sha,renames:!0})))return ws;void 0===(r=s&&s.commits.get(e.sha))&&e.isMerge&&(r=u.first(s.commits.values())),r&&(r.nextSha=e.nextSha,r.nextFileName=e.nextFileName)}return void 0===r||void 0===r.previousSha?ws:new ls(ri.ShowQuickCommitFileDetails,[r.previousUri,{fileLog:s,sha:r.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.nextSha){s=void 0,r=void 0;const i=await vr.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((r=e).nextSha=i.sha,r.nextFileName=i.originalFileName||i.fileName)}return void 0===r||void 0===r.nextSha?ws:new ls(ri.ShowQuickCommitFileDetails,[r.nextUri,{fileLog:s,sha:r.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new ls(ri.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new ls(ri.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const m=await vr.keyboard.beginScope({left:i,",":l,".":d}),g=await A.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${w.pad(K.Dot,1,1)} ${h?`Uncommitted ${K.ArrowRightHollow} `:""}${e.shortSha} ${w.pad(K.Dot,1,1)} ${e.author}, ${e.formattedDate} ${w.pad(K.Dot,1,1)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`,ignoreFocusOut:as(),onDidSelectItem:e=>{m.setKeyCommand("right",e)}});return await m.dispose(),g}}class As extends ds{constructor(e,t){const i=lt(t.status),s=ht.getFormattedDirectory(t,!0);super(Ie.toRevisionUri(e.sha,t,e.repoPath),{label:`${w.pad(i,4,2)} ${Ee.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):A.commands.executeCommand(ri.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class Us extends ms{constructor(e,t=!1,i){const s=e.repoPath;super(o.filterMap(e.fileStatuses,e=>Ie.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class Ls extends ms{constructor(e,t){super(o.filterMap(e.fileStatuses,t=>Ie.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${w.pad(K.Dash,2,3)} in ${K.Space}$(git-commit) ${e.shortSha}`})}}class Os{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new As(e,t)),a=e.isStash;let n=0;if(a)r.splice(n++,0,new hs({label:"$(git-pull-request) Apply Stashed Changes",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ri.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new hs({label:"$(x) Delete Stashed Changes",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ri.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new gs(e));else{r.splice(n++,0,new gs(e));const t=await vr.git.getRemotes(e.repoPath);t.length&&r.splice(n++,0,new Fs(t,{type:"commit",sha:e.sha},s))}r.splice(n++,0,new Us(e)),r.splice(n++,0,new Ls(e)),r.splice(n++,0,new hs({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${K.Space} $(git-compare) ${K.Space} $(git-commit) ${e.shortSha}`},ri.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(n++,0,new hs({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.shortSha} ${K.Space} $(git-compare) ${K.Space} $(file-directory) Working Tree`},ri.DiffDirectory,[t,{ref1:e.sha}])),a||r.splice(n++,0,new hs({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.shortSha}`},ri.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(n++,0,new hs({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ri.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(n++,0,new hs({label:"Changed Files",description:e.getDiffStatus()},ri.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let h=void 0,c=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await vr.git.getLog(e.repoPath,{maxCount:vr.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?ws:new ls(ri.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await vr.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&u.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?ws:new ls(ri.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new ls(ri.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new ls(ri.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await vr.keyboard.beginScope({left:i,",":h,".":c}),d=await A.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${w.pad(K.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${w.pad(K.Dot,1,1)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`,ignoreFocusOut:as(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class Is{static showProgress(e){return ns(e,{left:ws,",":ws,".":ws})}static async show(e,t,i,s){const o=e&&[...u.map(e.commits.values(),e=>new us(e))]||[new cs("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const r=await vr.keyboard.beginScope({left:s.goBackCommand});i.cancel();const a=await A.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:as()});return await r.dispose(),a}}class Ms{static showProgress(e){return ns(e,{left:ws,",":ws,".":ws})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(u.map(e.commits.values(),e=>new us(e)));let r=0;if(s.pickerOnly&&(r++,o.splice(0,0,new vs(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(r++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)r++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await vr.git.findWorkingFileName(Ee.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,o.splice(0,0,new hs({label:"$(history) Show File History",description:`${w.pad(K.Dash,2,3)} of ${Ee.basename(i)}`},ri.ShowQuickFileHistory,[A.Uri.file(Ee.resolve(e.repoPath,i)),{goBackCommand:new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${Ee.basename(t.fsPath)}${t.sha?` from ${K.Space}$(git-commit) ${t.shortSha}`:""}`},ri.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(r++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(r++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await vr.git.getBranch(t.repoPath),a=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${Ee.basename(t.fsPath)}${t.sha?` from ${K.Space}$(git-commit) ${t.shortSha}`:""}`},ri.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(r++,0,new hs({label:"$(history) Show Branch History",description:`${w.pad(K.Dash,2,3)} shows  ${K.Space}$(git-branch) ${i.name} history`},ri.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:a}]));const n=await vr.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(r++,0,new Fs(n,e,a))}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await vr.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await A.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:as()});return await a.dispose(),n}}class Ws{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class Hs{static async show(e,t){const i=[...u.map(await vr.git.getRepositories(),e=>new Ws(e))];return void 0!==t&&i.splice(0,0,t),await A.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:as()})}}class js extends ds{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":K.Space.repeat(3)}${w.pad(s,2,2)} ${Ee.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new Je(We.File,e.repoPath,ni.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new Je(We.File,e.repoPath,ni.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?ni.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return A.commands.executeCommand(ri.DiffWithPrevious,Ie.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class Gs extends hs{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},ri.OpenChangedFiles,[void 0,{uris:i}])}}class Vs{static computeStatus(e){let t=0,i=0,s=0,o=0,r=0,a=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":r++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":a++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+r,l=i+o+a;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${r}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${a}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...u.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new js(e.with({indexStatus:null}),e.indexStatus),new js(e.with({workTreeStatus:null}))]:[new js(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to ${K.Space}$(git-branch) ${e.branch} status`},ri.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const r=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;r>-1&&(i.splice(r,0,new hs({label:"Unstaged Files",description:o.unstagedStatus},ri.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(r,0,new Gs(o.stagedAddsAndChanges,{label:`${K.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new Gs(o.unstagedAddsAndChanges,{label:`${K.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new hs({label:"Staged Files",description:o.stagedStatus},ri.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new hs({label:"Unstaged Files",description:o.unstagedStatus},ri.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new Gs(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new hs({label:"$(x) Close Unchanged Files",description:""},ri.CloseUnchangedFiles))):i.push(new hs({label:"No changes in the working tree",description:""},ri.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new hs({label:"$(inbox) Show Stashed Changes",description:`${w.pad(K.Dash,2,3)} shows stashed changes in the repository`},ri.ShowQuickStashList,[Ie.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new hs({label:`$(cloud-upload)${K.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${K.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(K.Dash,2,3)} shows commits in ${K.Space}$(git-branch) ${e.branch} but not ${K.Space}$(git-branch) ${e.upstream}`},ri.ShowQuickBranchHistory,[Ie.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new hs({label:`$(cloud-download)${K.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${K.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(K.Dash,2,3)} shows commits in ${K.Space}$(git-branch) ${e.upstream} but not ${K.Space}$(git-branch) ${e.branch}${e.sha?` (since ${K.Space}$(git-commit) ${ni.shortenSha(e.sha)})`:""}`},ri.ShowQuickBranchHistory,[Ie.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new hs({label:`$(git-branch) ${e.branch} is up-to-date with ${K.Space}$(git-branch) ${e.upstream}`,description:""},ri.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await vr.keyboard.beginScope({left:t}),a=await A.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${w.pad(K.ArrowLeftRightLong,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:as(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),a}}class Qs{static showProgress(e){return ns("apply"===e?`Apply stashed changes to your working tree${K.Ellipsis}`:`stashed changes ${K.Dash} search by message, filename, or commit id`,{left:ws,",":ws,".":ws})}static async show(e,t,i,s,o){const r=e&&Array.from(u.map(e.commits.values(),e=>new us(e)))||[];if("list"===t&&r.splice(0,0,new hs({label:"$(plus) Stash Changes",description:`${w.pad(K.Dash,2,3)} stashes all changes`},ri.StashSave,[{goBackCommand:o}])),s&&r.splice(0,0,s),i.token.isCancellationRequested)return;const a=await vr.keyboard.beginScope({left:s});i.cancel();const n=await A.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${K.Ellipsis}`:`stashed changes ${K.Dash} search by message, filename, or commit id`,ignoreFocusOut:as()});return await a.dispose(),n}}class Ks extends Ki{constructor(){super([ri.DiffHeadWithBranch,ri.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case ri.DiffHeadWithBranch:t.ref2="HEAD";break;case ri.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=Mi(t,e);try{const o=await vr.git.getRepoPath(t);if(!o)return is.showNoRepositoryWarningMessage("Unable to open branch compare");if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to ${K.Ellipsis}`;break;case"HEAD":e=`Compare HEAD to ${K.Ellipsis}`;break;default:e=`Compare ${i.ref2} to ${K.Ellipsis}`}s=Ss.showProgress(e);const[t,r]=await Promise.all([vr.git.getBranches(o),vr.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await Ss.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof hs)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void vr.resultsExplorer.showComparisonInResults(o,i.ref1,i.ref2)}catch(e){return ke.error(e,"DiffBranchWithBranchCommand"),A.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.dispose()}}}class zs extends Ki{constructor(){super([ri.DiffDirectory,ri.ExternalDiffAll,ri.ExplorersOpenDirectoryDiff,ri.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case ri.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case ri.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof Ui&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case ri.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof ci})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=Mi(t,e);try{const o=await vr.git.getRepoPath(t);if(!o)return is.showNoRepositoryWarningMessage("Unable to open directory compare");if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to ${K.Ellipsis}`;s=Ss.showProgress(e);const[t,r]=await Promise.all([vr.git.getBranches(o),vr.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await Ss.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof hs)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void vr.git.openDirectoryDiff(o,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await A.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return A.commands.executeCommand(W.Open,A.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return ke.error(e,"DiffDirectoryCommand"),A.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.dispose()}}}class qs extends Ki{constructor(){super(ri.DiffLineWithPrevious)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;const s=await Ie.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||ni.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await vr.git.getBlameForLineContents(s,t,e.document.getText()):await vr.git.getBlameForLine(s,t);if(void 0===o)return is.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await vr.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:ni.stagedUncommittedSha}))}}catch(e){return ke.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:ni.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,o)}}class Ys extends Ki{constructor(){super(ri.DiffLineWithWorking)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;const s=await Ie.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||ni.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await vr.git.getBlameForLineContents(s,t,e.document.getText()):await vr.git.getBlameForLine(s,t);if(void 0===o)return is.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await vr.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?ni.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return ke.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,o)}}class Xs extends Ki{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Ge){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:ni.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(ri.DiffWith,i)}constructor(){super(ri.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{ni.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await vr.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),ni.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await vr.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[t,s]=await Promise.all([vr.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),vr.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===s?o=ni.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==t&&i.lhs.sha!==ni.deletedSha||(o="added in ");let r="";if(void 0===t&&""===i.rhs.sha&&(void 0!==s?(r="not in ",o=""):r="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==ni.deletedSha&&(void 0!==t||""!==r)){const e=ni.shortenSha(i.lhs.sha)||"";i.lhs.title=`${Ee.basename(i.lhs.uri.fsPath)}${""!==e?` (${r}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==ni.deletedSha){const e=ni.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${Ee.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const a=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${K.ArrowLeftRightLong} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=A.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new A.Range(i.line,0,i.line,0)),await A.commands.executeCommand(W.Diff,void 0===t?Ie.toRevisionUri(ni.deletedSha,i.lhs.uri.fsPath,i.repoPath):A.Uri.file(t),void 0===s?Ie.toRevisionUri(ni.deletedSha,i.rhs.uri.fsPath,i.repoPath):A.Uri.file(s),a,i.showOptions)}catch(e){return ke.error(e,"DiffWithCommand","getVersionedFile"),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class Js extends Ki{constructor(){super(ri.DiffWithBranch)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Ie.fromUri(t);if(!s.repoPath)return is.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${Ee.basename(s.fsPath)} with ${K.Ellipsis}`,r=Ss.showProgress(o);try{const[e,t]=await Promise.all([vr.git.getBranches(s.repoPath),vr.git.getTags(s.repoPath)]);if(r.token.isCancellationRequested)return;const a=await Ss.show(e,t,o,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===a)return;if(a instanceof hs)return a.execute();const n=a.name;if(void 0===n)return;let h,c;const l=await vr.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=w.normalizePath(Ee.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=A.Uri.file(Ee.join(s.repoPath,t.originalFileName)),c=`${Ee.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:a.remote?`remotes/${n}`:n,uri:h||s,title:c||`${Ee.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,d)}finally{r.dispose()}}}class Zs extends Ki{constructor(){super(ri.DiffWithNext)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Ie.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof Je)||void 0!==i.range)try{const r=void 0===i.commit?s.sha:i.commit.sha;if(ni.isStagedUncommitted(r))return A.commands.executeCommand(ri.DiffWithWorking,t);const a=await vr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==r?void 0:2,range:i.range,renames:!0});if(void 0===a)return is.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=r&&a.commits.get(r)||u.first(a.commits.values()),void 0===s.sha&&void 0!==(o=await vr.git.getStatusForFile(s.repoPath,s.fsPath)))return A.commands.executeCommand(ri.DiffWithWorking,t)}catch(e){return ke.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await vr.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:ni.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,e)}return A.commands.executeCommand(ri.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,r)}}class eo extends Ki{constructor(){super(ri.DiffWithPrevious)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Ie.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===ni.deletedSha)return is.showCommitHasNoPreviousCommitWarningMessage();let o=!1;ni.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0);const r=await vr.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===r)return is.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&r.commits.get(s)||u.first(r.commits.values()),void 0===e.sha){const s=await vr.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:ni.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:ni.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,e)}return A.commands.executeCommand(ri.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return ke.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:ni.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,s)}}class to extends Ki{constructor(){super(ri.DiffWithRevision)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Ie.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${w.pad(K.Dot,1,1)} ${s.shortSha}`:""} with ${K.Ellipsis}`,r=Ms.showProgress(o);try{const a=await vr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===a)return is.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new hs({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${a.maxCount} newer commits`},ri.DiffWithRevision,[t,Object.assign({},i)]),s=u.last(a.commits.values());null!=s&&(n=new hs({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${a.maxCount} older commits`},ri.DiffWithRevision,[new Ie(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await Ms.show(a,s,o,{pickerOnly:!0,progressCancellation:r,currentCommand:new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${K.Space}$(git-commit) ${s.shortSha}`:""}`},ri.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new hs({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ri.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;let c;if(h instanceof vs){const e=await h.execute();if(void 0===e)return;if(e instanceof hs)return e.execute();c=e.name}else{if(h instanceof hs)return h.execute();c=h.commit.sha}const l={repoPath:s.repoPath,lhs:{sha:c,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await A.commands.executeCommand(ri.DiffWith,l)}catch(e){return ke.error(e,"DiffWithRevisionCommand"),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.dispose()}}}class io extends Ki{constructor(){super(ri.DiffWithWorking)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;const s=await Ie.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||ni.isUncommitted(i.commit.sha)){if(void 0===s.sha)return A.window.showInformationMessage("File matches the working tree");if(ni.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await vr.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:ni.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,e)}}try{if(i.commit=await vr.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return is.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return ke.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),A.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await vr.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return A.commands.executeCommand(ri.DiffWith,r)}}var so,oo,ro,ao;(oo=so||(so={}))[oo.INDEX_MODIFIED=0]="INDEX_MODIFIED",oo[oo.INDEX_ADDED=1]="INDEX_ADDED",oo[oo.INDEX_DELETED=2]="INDEX_DELETED",oo[oo.INDEX_RENAMED=3]="INDEX_RENAMED",oo[oo.INDEX_COPIED=4]="INDEX_COPIED",oo[oo.MODIFIED=5]="MODIFIED",oo[oo.DELETED=6]="DELETED",oo[oo.UNTRACKED=7]="UNTRACKED",oo[oo.IGNORED=8]="IGNORED",oo[oo.ADDED_BY_US=9]="ADDED_BY_US",oo[oo.ADDED_BY_THEM=10]="ADDED_BY_THEM",oo[oo.DELETED_BY_US=11]="DELETED_BY_US",oo[oo.DELETED_BY_THEM=12]="DELETED_BY_THEM",oo[oo.BOTH_ADDED=13]="BOTH_ADDED",oo[oo.BOTH_DELETED=14]="BOTH_DELETED",oo[oo.BOTH_MODIFIED=15]="BOTH_MODIFIED",(ao=ro||(ro={}))[ao.Merge=0]="Merge",ao[ao.Index=1]="Index",ao[ao.WorkingTree=2]="WorkingTree";class no{constructor(e,t){this.uri=e,this.staged=t}}class ho extends Qi{constructor(){super(ri.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new no(e.resourceUri,e.resourceGroupType===ro.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=o.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new no(e.resourceUri,e.resourceGroupType===ro.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===so.BOTH_MODIFIED||t===so.INDEX_MODIFIED||t===so.MODIFIED}async execute(e={}){try{const t=await vr.git.getRepoPath(void 0);if(!t)return is.showNoRepositoryWarningMessage("Unable to open external file compare");const i=await vr.git.getDiffTool(t);if(void 0===i){if(!await A.window.showWarningMessage("Unable to open external file compare because there is no Git diff tool configured","View Git Docs"))return;return A.commands.executeCommand(W.Open,A.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await vr.git.getStatusForRepo(t);if(void 0===i)return A.window.showWarningMessage("Unable to open external file compare");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new no(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new no(t.uri,!1))}for(const s of e.files)vr.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return ke.error(e,"ExternalDiffCommand"),A.window.showErrorMessage("Unable to open external file compare. See output channel for more details")}}}class co extends Ki{constructor(){super(ri.OpenChangedFiles)}async execute(e,t,i={}){t=Mi(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await vr.git.getRepoPath(t);if(!e)return is.showNoRepositoryWarningMessage("Unable to open changed files");const s=await vr.git.getStatusForRepo(e);if(void 0===s)return A.window.showWarningMessage("Unable to open changed files");i.uris=o.filterMap(s.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Xi(e,{preserveFocus:!0,preview:!1});return}catch(e){return ke.error(e,"OpenChangedFilesCommand"),A.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class lo extends Ki{constructor(){super(ri.OpenBranchesInRemote)}async preExecute(e,t={}){return ji(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=Mi(t,e))&&await Ie.fromUri(t),o=void 0===s?vr.git.getHighlanderRepoPath():s.repoPath;if(o)try{const s=await vr.git.getRemotes(o);return A.commands.executeCommand(ri.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:s})}catch(e){return ke.error(e,"OpenBranchesInRemoteCommand"),A.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class mo extends Ki{constructor(){super(ri.OpenBranchInRemote)}async preExecute(e,t={}){return Wi(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=Mi(t,e))&&await Ie.fromUri(t),o=void 0===s?vr.git.getHighlanderRepoPath():s.repoPath;if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=await vr.git.getBranches(o),t=await ks.show(e,`Show history for branch${K.Ellipsis}`);if(void 0===t)return;if(t instanceof hs)return;if(i.branch=t.branch.name,void 0===i.branch)return}const s=await vr.git.getRemotes(o);return A.commands.executeCommand(ri.OpenInRemote,t,{resource:{type:"branch",branch:i.branch},remote:i.remote,remotes:s})}catch(e){return ke.error(e,"OpenBranchInRemoteCommandArgs"),A.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class uo extends Ki{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ri.OpenCommitInRemote,t)}constructor(){super(ri.OpenCommitInRemote)}async preExecute(e,t={}){return Hi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;const s=await Ie.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=void 0===e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await vr.git.getBlameForLineContents(s,t,e.document.getText()):await vr.git.getBlameForLine(s,t);if(void 0===o)return is.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let r=o.commit;r.isUncommitted&&(r=r.with({sha:r.previousSha,fileName:r.previousFileName,previousSha:null,previousFileName:null})),i.sha=r.sha}const o=await vr.git.getRemotes(s.repoPath);return A.commands.executeCommand(ri.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return ke.error(e,"OpenCommitInRemoteCommand"),A.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class go extends Ki{constructor(){super(ri.OpenFileInRemote)}async preExecute(e,t={range:!0}){return Hi(e)?((t=Object.assign({},t)).range=!1,Wi(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(void 0===(t=Mi(t,e)))return;const s=await Ie.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await vr.git.getBranch(s.repoPath);void 0!==e&&(i.branch=e.name)}try{const o=await vr.git.getRemotes(s.repoPath),r=i.range&&void 0!==e?new A.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return A.commands.executeCommand(ri.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch,fileName:s.getRelativePath(),range:r,sha:s.sha},remotes:o})}catch(e){return ke.error(e,"OpenFileInRemoteCommand"),A.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class po extends Ki{static getMarkdownCommandArgs(e,t,i){let s;return s=e instanceof A.Uri?{uri:e,line:i,annotationType:t}:e,super.getMarkdownCommandArgsCore(ri.OpenFileRevision,s)}constructor(){super(ri.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=Mi(t,e)))return;const o=await Ie.fromUri(t),r=`Open ${o.getFormattedPath()}${o.sha?` ${w.pad(K.Dot,1,1)} ${o.shortSha}`:""} in revision ${K.Ellipsis}`;s=Ms.showProgress(r);const a=await vr.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===a)return is.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new hs({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${a.maxCount} newer commits`},ri.OpenFileRevision,[t,Object.assign({},i)]),s=u.last(a.commits.values());null!=s&&(n=new hs({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${a.maxCount} older commits`},ri.OpenFileRevision,[new Ie(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await Ms.show(a,o,r,{pickerOnly:!0,progressCancellation:s,currentCommand:new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${K.Space}$(git-commit) ${o.shortSha}`:""}`},ri.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new hs({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ri.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof vs){const e=await h.execute();if(void 0===e)return;if(e instanceof hs)return e.execute();i.uri=Ie.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof hs)return h.execute();i.uri=Ie.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new A.Range(i.line,0,i.line,0));const o=await Xi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:vr.fileAnnotations.show(o,i.annotationType,i.line)}catch(e){return ke.error(e,"OpenFileRevisionCommand"),A.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.dispose()}}}class fo extends Ki{constructor(){super(ri.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length)return this.ensureRemoteBranchName(i),new _s(i.remotes[0],i.resource).execute();let t="";switch(i.resource.type){case he.Branch:this.ensureRemoteBranchName(i),t=`open ${i.resource.branch} branch in${K.Ellipsis}`;break;case he.Commit:t=`open commit ${ni.shortenSha(i.resource.sha)} in${K.Ellipsis}`;break;case he.File:t=`open ${i.resource.fileName} in${K.Ellipsis}`;break;case he.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof Je)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,t=`open ${i.resource.fileName} ${w.pad(K.Dot,1,1)} ${i.resource.commit.previousShortSha} in${K.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,t=`open ${i.resource.fileName} ${w.pad(K.Dot,1,1)} ${i.resource.commit.shortSha} in${K.Ellipsis}`);else{const e=void 0===i.resource.sha?"":ni.shortenSha(i.resource.sha),s=e?` ${w.pad(K.Dot,1,1)} ${e}`:"";t=`open ${i.resource.fileName}${s} in${K.Ellipsis}`}}if(1===i.remotes.length)return new _s(i.remotes[0],i.resource).execute();const s=await Ps.show(i.remotes,t,i.resource,i.goBackCommand);if(void 0===s)return;return s.execute()}catch(e){return ke.error(e,"OpenInRemoteCommand"),A.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class vo extends Ki{constructor(){super(ri.OpenRepoInRemote)}async preExecute(e,t={}){return ji(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=Mi(t,e))&&await Ie.fromUri(t),o=void 0===s?vr.git.getHighlanderRepoPath():s.repoPath;if(o)try{const s=await vr.git.getRemotes(o);return A.commands.executeCommand(ri.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:s})}catch(e){return ke.error(e,"OpenRepoInRemoteCommand"),A.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class wo extends Ki{constructor(){super(ri.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=Mi(t,e)))return;if(i.uri=await Ie.fromUri(t),i.uri instanceof Ie&&i.uri.sha){const[e,t]=await vr.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Ie(A.Uri.file(Ee.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new A.Range(i.line,0,i.line,0));const s=await Xi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:vr.fileAnnotations.show(s,i.annotationType,i.line)}catch(e){return ke.error(e,"OpenWorkingFileCommand"),A.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class Co extends Qi{constructor(){super(ri.ResetSuppressedWarnings)}async execute(){await br.update(br.name("advanced")("messages").value,void 0,A.ConfigurationTarget.Global)}}const bo=/^([@~=:#])/,yo=new Map([["@",Xt.Author],["~",Xt.Changes],["=",Xt.ChangedOccurrences],[":",Xt.Files],["#",Xt.Sha]]);class xo extends qi{constructor(){super(ri.ShowCommitSearch)}async execute(e,t,i={}){const s=void 0===(t=Mi(t,e))?void 0:await Ie.fromUri(t);let o=void 0===s?vr.git.getHighlanderRepoPath():s.repoPath;if(!o){const e=await Hs.show(`Search for commits in which repository${K.Ellipsis}`,i.goBackCommand);if(e instanceof hs)return e.execute();if(void 0===e)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();o=e.repoPath}i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&void 0!==e&&void 0!==s){const t=await vr.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){ke.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await A.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=bo.exec(i.search);t&&t[1]?(i.searchBy=yo.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):ni.isSha(i.search)?i.searchBy=Xt.Sha:i.searchBy=Xt.Message}void 0===i.searchBy&&(i.searchBy=Xt.Message);let a=void 0;switch(i.searchBy){case Xt.Author:a=`commits with an author matching '${i.search}'`;break;case Xt.Changes:a=`commits with changes matching '${i.search}'`;break;case Xt.ChangedOccurrences:a=`commits with changed occurrences matching '${i.search}'`;break;case Xt.Files:a=`commits with files matching '${i.search}'`;break;case Xt.Message:a=`commits with a message matching '${i.search}'`;break;case Xt.Sha:a=`commits with an id matching '${i.search}'`}const n=Is.showProgress(a);try{const s=await vr.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const h=i.goBackCommand||new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to commit search`},ri.ShowCommitSearch,[t,r]),c=await Is.show(s,a,n,{goBackCommand:h,showAllCommand:void 0!==s&&s.truncated?new hs({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ri.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:h})]):void 0,showInResultsExplorerCommand:void 0!==s?new fs(s,a):void 0});if(void 0===c)return;return c instanceof hs?c.execute():A.commands.executeCommand(ri.ShowQuickCommitDetails,c.commit.toGitUri(),{sha:c.commit.sha,commit:c.commit,goBackCommand:new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,2)} to search for ${a}`},ri.ShowCommitSearch,[t,i])})}catch(e){return ke.error(e,"ShowCommitSearchCommand"),A.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.dispose()}}}class $o extends Qi{constructor(){super(ri.ShowLastQuickPick)}async execute(){const e=zi;if(void 0!==e)try{return A.commands.executeCommand(e.command,...e.args)}catch(e){return ke.error(e,"ShowLastQuickPickCommand"),A.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class So extends qi{constructor(){super(ri.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=Mi(t,e))&&await Ie.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:Rs.showProgress(i.branch);try{const r=void 0===s?vr.git.getHighlanderRepoPath():s.repoPath;if(!r)return is.showNoRepositoryWarningMessage("Unable to show branch history");if(void 0===i.branch){const e=await vr.git.getBranches(r),t=await ks.show(e,`Show history for branch${K.Ellipsis}`);if(void 0===t)return;if(t instanceof hs)return t.execute();if(i.branch=t.branch.name,void 0===i.branch)return;o=Rs.showProgress(i.branch)}if(void 0===i.log&&(i.log=await vr.git.getLog(r,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return A.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const a=await Rs.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===a)return;if(a instanceof hs)return a.execute();const n=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to ${K.Space}$(git-branch) ${i.branch} history`},ri.ShowQuickBranchHistory,[t,Object.assign({},i)]);return A.commands.executeCommand(ri.ShowQuickCommitDetails,a.commit.toGitUri(),{sha:a.commit.sha,commit:a.commit,repoLog:i.log,goBackCommand:n})}catch(e){return ke.error(e,"ShowQuickBranchHistoryCommand"),A.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.dispose()}}}class Do extends qi{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ri.ShowQuickCommitDetails,t)}constructor(){super(ri.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Hi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;const s=await Ie.fromUri(t);let o=s.repoPath,r=Ee.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const a=await vr.git.getBlameForLine(s,t);if(void 0===a)return is.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(a.commit.isUncommitted)return is.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=a.commit.sha,o=a.commit.repoPath,r=a.commit.fileName,i.commit=a.commit}catch(e){return ke.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await vr.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return is.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return is.showCommitNotFoundWarningMessage("Unable to show commit details");void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand&&(i.goBackCommand=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to branch history`},ri.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]));const s=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to details of ${K.Space}$(git-commit) ${i.commit.shortSha}`},ri.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),a=await Os.show(i.commit,t,i.goBackCommand,s,i.repoLog);if(void 0===a)return;return a instanceof As?A.commands.executeCommand(ri.ShowQuickCommitFileDetails,a.commit.toGitUri(),{commit:a.commit,sha:a.sha,goBackCommand:s}):a.execute()}catch(e){return ke.error(e,"ShowQuickCommitDetailsCommand"),A.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class ko extends qi{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ri.ShowQuickCommitFileDetails,t)}constructor(){super(ri.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Hi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Ie.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const r=await vr.git.getBlameForLine(o,t);if(void 0===r)return is.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(r.commit.isUncommitted)return is.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=r.commit.sha,i.commit=r.commit,s=Ee.relative(i.commit.repoPath,o.fsPath)}catch(e){return ke.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),A.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await vr.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return is.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return is.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await vr.git.findWorkingFileName(i.commit);const r=ni.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to details of ${K.Space}$(git-commit) ${r}`},ri.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const a=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to details of ${K.Space}$(file-text) ${Ee.basename(i.commit.fileName)} in ${K.Space}$(git-commit) ${r}`},ri.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await Ns.show(i.commit,t,i.goBackCommand,a,i.fileLog);if(void 0===n)return;return n instanceof hs?n.execute():void 0}catch(e){return ke.error(e,"ShowQuickCommitFileDetailsCommand"),A.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class _o extends qi{constructor(){super(ri.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=Mi(t,e);try{const s=await vr.git.getRepoPath(t);if(!s)return is.showNoRepositoryWarningMessage("Unable to show branch history");const o=await vr.git.getBranch(s);if(void 0===o)return;return A.commands.executeCommand(ri.ShowQuickBranchHistory,t,{branch:o.name,goBackCommand:i.goBackCommand})}catch(e){return ke.error(e,"ShowQuickCurrentBranchHistoryCommand"),A.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class Fo extends qi{constructor(){super(ri.ShowQuickFileHistory)}async execute(e,t,i={}){if(void 0===(t=Mi(t,e)))return A.commands.executeCommand(ri.ShowQuickCurrentBranchHistory);const s=await Ie.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${w.pad(K.Dot,1,1)} ${s.shortSha}`:""}`,r=Ms.showProgress(o);try{if(void 0===i.log&&(i.log=await vr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return is.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let a=void 0;if(i.log.truncated){const e=new hs({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${i.log.maxCount} newer commits`},ri.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),o=u.last(i.log.commits.values());null!=o&&(a=new hs({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${i.log.maxCount} older commits`},ri.ShowQuickFileHistory,[new Ie(t,o),Object.assign({},i,{log:void 0,nextPageCommand:e})]))}const n=await Ms.show(i.log,s,o,{progressCancellation:r,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:a,showAllCommand:void 0!==i.log&&i.log.truncated?new hs({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ri.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new ps(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===n)return;if(n instanceof hs)return n.execute();const h=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${Ee.basename(n.commit.fileName)}${s.sha?` from ${K.Space}$(git-commit) ${s.shortSha}`:""}`},ri.ShowQuickFileHistory,[t,i]);return A.commands.executeCommand(ri.ShowQuickCommitFileDetails,n.commit.toGitUri(),{commit:n.commit,fileLog:i.log,sha:n.commit.sha,goBackCommand:h})}catch(e){return ke.error(e,"ShowQuickFileHistoryCommand"),A.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.dispose()}}}class Po extends qi{constructor(){super(ri.ShowQuickRepoStatus)}async execute(e,t,i={}){t=Mi(t,e);try{const s=await vr.git.getRepoPath(t);if(!s)return is.showNoRepositoryWarningMessage("Unable to show repository status");const o=await vr.git.getStatusForRepo(s);if(void 0===o)return A.window.showWarningMessage("Unable to show repository status");const r=await Vs.show(o,i.goBackCommand);if(void 0===r)return;return r instanceof hs?r.execute():void 0}catch(e){return ke.error(e,"ShowQuickRepoStatusCommand"),A.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class Ro extends qi{constructor(){super(ri.ShowQuickStashList)}async execute(e,t,i={}){t=Mi(t,e);const s=Qs.showProgress("list");try{const o=await vr.git.getRepoPath(t);if(!o)return is.showNoRepositoryWarningMessage("Unable to show stashed changes");const r=await vr.git.getStashList(o);if(void 0===r)return A.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const a=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to stashed changes`},ri.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),n=await Qs.show(r,"list",s,i.goBackCommand,a);if(void 0===n)return;return n instanceof hs?n.execute():A.commands.executeCommand(ri.ShowQuickCommitDetails,n.commit.toGitUri(),{commit:n.commit,sha:n.commit.sha,goBackCommand:a})}catch(e){return ke.error(e,"ShowQuickStashListCommand"),A.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.dispose()}}}class To extends Qi{constructor(){super(ri.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return Hi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await vr.git.getActiveRepoPath();if(!i){const s=await Hs.show(`Apply stashed changes from which repository${K.Ellipsis}`,e.goBackCommand);if(s instanceof hs)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to pick another repository`},ri.StashApply,[e]),i=s.repoPath}const s=Qs.showProgress("apply");try{const o=await vr.git.getStashList(i);if(void 0===o)return A.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const r=new hs({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to apply stashed changes`},ri.StashApply,[e]),a=await Qs.show(o,"apply",s,t||e.goBackCommand,r);if(a instanceof hs)return a.execute();if(void 0===a)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=a.commit}finally{s.dispose()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${K.Ellipsis}`:e.stashItem.message,i=await A.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await vr.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return ke.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?A.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?A.window.showInformationMessage("Stash applied with conflicts"):A.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class Eo extends Qi{constructor(){super(ri.StashDelete)}async preExecute(e,t={confirm:!0}){return Hi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${K.Ellipsis}`:e.stashItem.message,i=await A.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await vr.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return ke.error(e,"StashDeleteCommand"),A.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class Bo extends Qi{constructor(){super(ri.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await vr.git.getHighlanderRepoPath();if(!t){const i=await Hs.show(`Stash changes for which repository${K.Ellipsis}`,e.goBackCommand);if(i instanceof hs)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await A.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await vr.git.stashSave(t,e.message,e.uris)}catch(e){return ke.error(e,"StashSaveCommand"),A.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class No extends Qi{constructor(){super(ri.ToggleCodeLens)}execute(){return vr.codeLens.toggleCodeLens()}}class Ao extends Ki{constructor(){super(ri.ToggleFileBlame)}async execute(e,t,i={}){if(void 0!==e&&void 0!==t&&!re.equals(t,e.document.uri)){const i=A.window.visibleTextEditors.find(e=>re.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:F.Blame})),vr.fileAnnotations.toggle(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return ke.error(e,"ToggleFileBlameCommand"),A.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Uo extends Ki{constructor(){super(ri.ToggleFileHeatmap)}async execute(e,t){A.commands.executeCommand(ri.ToggleFileBlame,t,{type:F.Heatmap})}}class Lo extends Ki{constructor(){super(ri.ToggleFileRecentChanges)}async execute(e,t){A.commands.executeCommand(ri.ToggleFileBlame,t,{type:F.RecentChanges})}}class Oo extends Ki{constructor(){super(ri.ToggleLineBlame)}async execute(e,t){try{return vr.lineAnnotations.toggle(e)}catch(e){return ke.error(e,"ToggleLineBlameCommand"),A.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const Io=/[`\>\#\*\_\-\+\.]/g;class Mo{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=h.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${K.MuchGreaterThan}\`](${Xs.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===F.RecentChanges&&(i=F.Blame);const t=Ie.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${K.SquareWithTopShadow}\`](${po.getMarkdownCommandArgs(t,i||F.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${K.ArrowUpRight}\`](${uo.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+`[\`${K.MiddleEllipsis}\`](${ko.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s,o=0){null===t&&(t="MMMM Do, YYYY h:mma");let r="",a="",n="";if(e.isUncommitted)n=`\`${"working"===e.shortSha?"00000000":e.shortSha}\``;else{a=`\n\n${this.getHoverCommandBar(e,0!==i.length,s,o)}`,n=`[\`${e.shortSha}\`](${Do.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,r=e.message;for(const e of i)if(void 0!==e.provider){r=e.provider.enrichMessage(r);break}r.replace(Io,"\\$&").replace(/^===/gm,`${K.ZeroWidthSpace}===`).replace(/\n/g,"  \n"),r=`\n\n> ${r}`}const h=new A.MarkdownString(`${n} &nbsp; ![](${e.getGravatarUri(vr.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${r}${a}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&ni.isStagedUncommitted(t.sha)?`[\`Changes\`](${Xs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${K.Dash} &nbsp; [\`${e.previousShortSha}\`](${Do.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${K.ArrowLeftRightLong} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Xs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${K.Dash} &nbsp; _uncommitted changes_\n${s}`:`[\`Changes\`](${Xs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${K.Dash} &nbsp; [\`${e.previousShortSha}\`](${Do.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${K.ArrowLeftRightLong} [\`${e.shortSha}\`](${Do.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const r=new A.MarkdownString(o);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&ni.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await vr.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const r=qt.fromTemplate(t,e,i);return o.renderOptions.before.contentText=w.pad(r.replace(/ /g,K.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let r=0;for(const e of s.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){r=-1;break}r+=e.truncateTo}r>=0&&(r+=w.width(w.interpolate(i,void 0)))>0&&(r+=3);let a=void 0,n=void 0;return t.enabled&&(a="solid",n="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new A.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:a,borderWidth:n,color:new A.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:r>=0?`${r}ch`:void 0,uncommittedColor:new A.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return Mo.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:K.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i,s=!0){const o=qt.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new A.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new A.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:w.pad(o.replace(/ /g,K.Space),1,1),fontWeight:"normal",fontStyle:"normal",textDecoration:`none;${s?"":" position: absolute;"}`}}}}}class Wo extends le{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?vr.git.getBlameForFileContents(this._uri,e.document.getText()):vr.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?vr.git.getBlameForFileContents(this._uri,this.editor.document.getText()):vr.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=u.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=o.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new A.Range(e.line,0,e.line,M)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!vr.config.hovers.enabled||!vr.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(A.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(A.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=A.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await vr.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const r=Mo.getHoverMessage(o||s,vr.config.defaultDateFormat,await vr.git.getRemotes(s.repoPath),this.annotationType,this.editor.selection.active.line);return new A.Hover(r,e.validateRange(new A.Range(t.line,0,t.line,M)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await Mo.changesHover(s,t.line,await Ie.fromUri(e.uri));return new A.Hover(o.hoverMessage,e.validateRange(new A.Range(t.line,0,t.line,M)))}async getCommitForHover(e){if("line"!==vr.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class Ho extends Wo{async onProvideAnnotation(e,t){this.annotationType=F.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),r=vr.config.blame,a=w.getTokensFromTemplate(r.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===r.dateFormat?vr.config.defaultDateFormat:r.dateFormat,tokenOptions:a},h=Date.now(),c=r.avatars,l=vr.config.defaultGravatarsStyle,d=r.separateLines,m=Mo.gutterRenderOptions(d,r.heatmap,r.format,n);this.decorations=[];const u=Object.create(null),g=c?Object.create(null):void 0;let p,f,v,C=!1;for(const e of i.lines){const t=e.line;v!==e.sha?(C=!1,v=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=u[e.sha])?(f=Mo.gutter(p,r.format,n,m),r.heatmap.enabled&&Mo.applyHeatmap(f,p.date,h),f.range=new A.Range(t,0,t,0),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g),u[e.sha]=f):(f=Object.assign({},f,{range:new A.Range(t,0,t,0)}),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g)))):(f=Object.assign({},f),r.compact&&!C&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:K.Space.repeat(w.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),C=!0),f.range=new A.Range(t,0,t,0),this.decorations.push(f),c&&!r.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),c)){this.additionalDecorations=[];for(const e of s.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const b=process.hrtime(o);return ke.log(`${1e3*b[0]+Math.floor(b[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(vr.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:A.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class jo extends Wo{async onProvideAnnotation(e,t){this.annotationType=F.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),r=Mo.heatmapRenderOptions();this.decorations=[];const a=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=a[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=Mo.heatmap(n,o,r)).range=new A.Range(t,0,t,0),this.decorations.push(h),a[e.sha]=h):(h=Object.assign({},h,{range:new A.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return ke.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(vr.config.hovers.annotations),this.selection(e,i),!0}}class Go extends le{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=F.RecentChanges;const t=await vr.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await vr.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=vr.config,r=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new A.Range(new A.Position(i,0),new A.Position(i,M)));let a=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:Mo.getHoverMessage(t,r,await vr.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),o.hovers.annotations.changes&&(a=Mo.getHoverDiffMessage(t,this._uri,s))),this.decorations.push({hoverMessage:a,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const a=process.hrtime(s);return ke.log(`${1e3*a[0]+Math.floor(a[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var Vo,Qo;(Qo=Vo||(Vo={})).User="User",Qo.BlameabilityChanged="BlameabilityChanged",Qo.ColumnChanged="ColumnChanged",Qo.Disposing="Disposing",Qo.DocumentChanged="DocumentChanged",Qo.DocumentClosed="DocumentClosed";const Ko={blameAnnotation:A.window.createTextEditorDecorationType({rangeBehavior:A.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:A.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class zo extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new A.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=A.Disposable.from(br.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(br.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),Ko.blameAnnotation&&Ko.blameAnnotation.dispose(),Ko.blameHighlight&&Ko.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=br.initializing(e),i=vr.config;if(t||br.changed(e,br.name("blame")("highlight").value)){Ko.blameHighlight&&Ko.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?Ko.blameHighlight=A.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:A.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new A.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new A.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?vr.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?vr.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):Ko.blameHighlight=void 0}if(t||br.changed(e,br.name("recentChanges")("highlight").value)){Ko.recentChangesAnnotation&&Ko.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;Ko.recentChangesAnnotation=A.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:A.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new A.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new A.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?vr.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?vr.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||br.changed(e,br.name("blame")("toggleMode").value))&&(this._toggleModes.set(F.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==y.File||this.clearAll()),(t||br.changed(e,br.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(F.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==y.File||this.clearAll()),(t||br.changed(e,br.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(F.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==y.File||this.clearAll()),!t&&(br.changed(e,br.name("blame").value)||br.changed(e,br.name("recentChanges").value)||br.changed(e,br.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===F.RecentChanges?e.reset({decoration:Ko.recentChangesAnnotation,highlightDecoration:Ko.recentChangesHighlight}):e.annotationType===F.Blame?e.reset({decoration:Ko.blameAnnotation,highlightDecoration:Ko.blameHighlight}):this.show(e.editor,F.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!J(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.show(e,this._annotationType);const t=this.getProvider(e);void 0===t?(Y(j.AnnotationStatus,void 0),this.detachKeyboardHook()):(Y(j.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=A.window.activeTextEditor;void 0!==t&&this.clear(t,Vo.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,Vo.DocumentChanged)}onTextDocumentClosed(e){if(vr.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,Vo.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=u.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,Vo.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===y.Window}getToggleMode(e){return void 0===e?y.File:this._toggleModes.get(e)||y.File}clear(e,t=Vo.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(le.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,Vo.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await vr.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(le.getCorrelationKey(e))}async show(e,t,i){if(this.getToggleMode(t)===y.Window){let i=void 0===this._annotationType;const s=!i&&this._annotationType!==t;if(this._annotationType=t,s&&(await this.clearAll(),i=!0),i)for(const i of A.window.visibleTextEditors)i!==e&&this.show(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await vr.tracker.getOrAdd(e.document)).isBlameable)return!1;const s=this.getProvider(e);return void 0!==s&&s.annotationType===t?(await s.selection(i),!0):void 0!==await A.window.withProgress({location:A.ProgressLocation.Window},async o=>{await Y(j.AnnotationStatus,ae.Computing);const r=this.showAnnotationsCore(s,e,t,i,o),a=await r;return e===this._editor&&await Y(j.AnnotationStatus,a&&a.status),r})}async toggle(e,t,i){if(void 0!==e){const i=await vr.tracker.getOrAdd(e.document);if(t===F.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.show(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,Vo.User),!!o&&this.show(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await vr.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,Vo.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(ke.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==le.getCorrelationKey(this._editor)||(await Y(j.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(ke.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case F.Blame:e="blame annotations";break;case F.Heatmap:e="heatmap annotations";break;case F.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${Ee.basename(t.document.fileName)}`})}this.attachKeyboardHook();const r=await vr.tracker.getOrAdd(t.document);let a=void 0;switch(i){case F.Blame:a=new Ho(t,r,Ko.blameAnnotation,Ko.blameHighlight);break;case F.Heatmap:a=new jo(t,r,Ko.heatmapAnnotation,Ko.heatmapHighlight);break;case F.RecentChanges:a=new Go(t,r,Ko.recentChangesAnnotation,Ko.recentChangesHighlight)}if(void 0!==a&&await a.validate())return void 0!==e&&await this.clearCore(e.correlationKey,Vo.User),this._annotationsDisposable||0!==this._annotationProviders.size||(ke.log("Add listener registrations for annotations"),this._annotationsDisposable=A.Disposable.from(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,50),this),A.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),A.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleTextEditorsChanged,50),this),A.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),vr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),vr.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(a.correlationKey,a),await a.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),a):void 0}}class qo extends A.CodeLens{constructor(e,t,i,s,o,r,a,n){super(r,n),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame&&this.blame()}}class Yo extends A.CodeLens{constructor(e,t,i,s,o,r,a){super(r),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame()}}class Xo{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new A.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=br.get(br.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=br.get(br.name("codeLens").value,e.uri);let r=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==r&&(r={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}),r.symbolScopes=null!=r.symbolScopes?r.symbolScopes=r.symbolScopes.map(e=>e.toLowerCase()):[];const a=[],n=i.uri;let h,c;if(s)1===r.scopes.length&&r.scopes.includes($.Document)||(c=await A.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return a;if(1===r.scopes.length&&r.scopes.includes($.Document)?h=e.isDirty?await this._git.getBlameForFileContents(n,e.getText()):await this._git.getBlameForFile(n):[h,c]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(n,e.getText()):this._git.getBlameForFile(n),A.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri)]),void 0===h||0===h.lines.length)return a}if(t.isCancellationRequested)return a;const l=m.once(()=>e.validateRange(new A.Range(0,1e6,1e6,1e6))),d=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==c&&(ke.log("GitCodeLensProvider.provideCodeLenses:",`${c.length} symbol(s) found`),c.forEach(t=>this.provideCodeLens(a,e,t,r,l,h,n,o,s,d))),(r.scopes.includes($.Document)||r.symbolScopes.includes("file"))&&!r.symbolScopes.includes("!file")&&!a.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=l();let t=void 0;(s||o.recentChange.enabled)&&(s||(t=m.once(()=>this._git.getBlameForRangeSync(h,n,e))),a.push(new qo(A.SymbolKind.File,n,t,e,!0,new A.Range(0,0,0,e.start.character),o.recentChange.command,d))),!s&&o.authors.enabled&&(void 0===t&&(t=m.once(()=>this._git.getBlameForRangeSync(h,n,e))),a.push(new Yo(A.SymbolKind.File,n,t,e,!0,new A.Range(0,1,0,e.start.character),o.authors.command)))}return a}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const r=A.SymbolKind[e.kind].toLowerCase();switch(e.kind){case A.SymbolKind.File:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&(s=i());break;case A.SymbolKind.Package:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case A.SymbolKind.Class:case A.SymbolKind.Interface:case A.SymbolKind.Module:case A.SymbolKind.Namespace:case A.SymbolKind.Struct:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;case A.SymbolKind.Constructor:case A.SymbolKind.Enum:case A.SymbolKind.Function:case A.SymbolKind.Method:(t.scopes.includes($.Blocks)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;default:t.symbolScopes.includes(r)&&(o=!t.symbolScopes.includes(`!${r}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,r,a,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let u,g=0;if((h||n.recentChange.enabled)&&(h||(u=m.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new qo(i.kind,a,u,l,!1,d.range.with(new A.Position(d.range.start.line,g)),n.recentChange.command,c)),g++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case A.SymbolKind.File:break;case A.SymbolKind.Package:case A.SymbolKind.Module:case A.SymbolKind.Namespace:case A.SymbolKind.Class:case A.SymbolKind.Interface:case A.SymbolKind.Constructor:case A.SymbolKind.Method:case A.SymbolKind.Function:case A.SymbolKind.Enum:s=!0}s&&!h&&(void 0===u&&(u=m.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Yo(i.kind,a,u,l,!1,d.range.with(new A.Position(d.range.start.line,g)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof qo?this.resolveGitRecentChangeCodeLens(e,t):e instanceof Yo?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=u.first(i.commits.values());let o=`${s.author}, ${s.formattedDate}`;switch(vr.config.debug&&(o+=` [${A.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i,s);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i,s);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i,s);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i,s);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i,s);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let o=`${s} ${s>1?"authors":"author"} (${u.first(i.authors.values()).name}${s>1?" and others":""})`;switch(vr.config.debug&&(o+=` [${A.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${u.join(u.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:ri.DiffWithPrevious,arguments:[A.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitDetails,arguments:[A.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitFileDetails,arguments:[A.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickCurrentBranchHistory,arguments:[A.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickFileHistory,arguments:[A.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:ri.ToggleFileBlame,arguments:[A.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?br.get(br.name("strings")("codeLens")("unsavedChanges")("recentChangeAndAuthors").value):e.recentChange.enabled?br.get(br.name("strings")("codeLens")("unsavedChanges")("recentChangeOnly").value):br.get(br.name("strings")("codeLens")("unsavedChanges")("authorsOnly").value)}}Xo.selector=[{scheme:V.File},{scheme:V.Git},{scheme:V.GitLensGit}];class Jo extends A.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=A.Disposable.from(br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=br.initializing(e),i=br.name("codeLens").value;if(t||br.changed(e,i,null)||br.changed(e,br.name("defaultDateStyle").value)||br.changed(e,br.name("defaultDateFormat").value)){t||ke.log("CodeLens config changed; resetting CodeLens provider");const e=br.get(i);e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,Y(j.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(ke.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=br.get(br.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||(ke.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(ke.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new Xo(vr.context,vr.git,vr.tracker),this._providerDisposable=A.Disposable.from(A.languages.registerCodeLensProvider(Xo.selector,this._provider),vr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),vr.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}const Zo=A.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:A.DecorationRangeBehavior.ClosedOpen});class er extends A.Disposable{constructor(){super(()=>this.dispose()),this._enabled=!1,this._disposable=A.Disposable.from(br.onDidChange(this.onConfigurationChanged,this),vr.fileAnnotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),A.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(br.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),vr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=br.initializing(e);(t||br.changed(e,br.name("currentLine").value))&&((t||br.changed(e,br.name("currentLine")("enabled").value))&&(br.get().currentLine.enabled?(this._enabled=!0,vr.lineTracker.start(this,A.Disposable.from(vr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))):(this._enabled=!1,vr.lineTracker.stop(this))),this.refresh(A.window.activeTextEditor))}get suspended(){return!this._enabled||void 0!==this._suspended}resume(e="user"){switch(e){case"debugging":if("user"!==this._suspended)return this._suspended=void 0,!0;break;case"user":if(void 0!==this._suspended)return this._suspended=void 0,!0}return!1}suspend(e="user"){return"user"!==this._suspended&&(this._suspended=e,!0)}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor):this.refresh(e.editor)}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=A.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this)),this.suspend("debugging")&&this.refresh(A.window.activeTextEditor)}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resume("debugging")&&this.refresh(A.window.activeTextEditor)}onFileAnnotationsToggled(){this.refresh(A.window.activeTextEditor)}async clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e)}async toggle(e){this._enabled=!(this._enabled&&!this.suspended),this._enabled?this.resume("user")&&await this.refresh(e):this.suspend("user")&&await this.refresh(e)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Zo,[])}async refresh(e){if(void 0===e&&void 0===this._editor)return;const t=vr.lineTracker.lines;if(void 0===e||void 0===t||!J(e))return this.clear(this._editor);this._editor!==e&&(this.clear(this._editor),this._editor=e);const i=vr.config.currentLine;if(this.suspended)return this.clear(e);if(!(await vr.tracker.getOrAdd(e.document)).isBlameable&&this.suspended)return this.clear(e);if(void 0===e.document||!vr.lineTracker.includesAll(t))return;const s=vr.config.currentLine.scrollable,o=[];for(const r of t){const t=vr.lineTracker.getState(r);if(void 0===t||void 0===t.commit)continue;const a=Mo.trailing(t.commit,i.format,null===i.dateFormat?vr.config.defaultDateFormat:i.dateFormat,s);a.range=e.document.validateRange(new A.Range(r,M,r,M)),o.push(a)}e.setDecorations(Zo,o)}}class tr extends A.Disposable{constructor(){super(()=>this.dispose()),this._disposable=A.Disposable.from(br.onDidChange(this.onConfigurationChanged,this),A.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(br.initializingChangeEvent)}dispose(){this.unregister(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),vr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){if(!br.initializing(e)&&!br.changed(e,br.name("hovers")("enabled").value)&&!br.changed(e,br.name("hovers")("currentLine")("enabled").value))return;const t=br.get();t.hovers.enabled&&t.hovers.currentLine.enabled?(vr.lineTracker.start(this,A.Disposable.from(vr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))),this.register(A.window.activeTextEditor)):(vr.lineTracker.stop(this),this.unregister())}get debugging(){return void 0!==this._debugSessionEndDisposable}onActiveLinesChanged(e){e.pending||"editor"!==e.reason||(void 0!==e.editor&&void 0!==e.lines?this.register(e.editor):this.unregister())}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=A.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0)}async provideDetailsHover(e,t,i){if(!vr.lineTracker.includes(t.line))return;const s=vr.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;const r=await vr.fileAnnotations.getAnnotationType(A.window.activeTextEditor);if(void 0!==r&&vr.config.hovers.annotations.details)return;const a=!this.debugging&&"line"===vr.config.hovers.currentLine.over;if(!a&&vr.lineAnnotations.suspended)return;const n=e.validateRange(new A.Range(t.line,a?0:M,t.line,M));if(!a&&n.start.character!==t.character)return;let h=void 0!==s?s.logCommit:void 0;if(void 0!==h||o.isUncommitted||void 0!==(h=await vr.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(h.previousSha=o.previousSha,h.previousFileName=o.previousFileName,void 0!==s&&(s.logCommit=h)),void 0===await vr.tracker.get(e))return;const c=Mo.getHoverMessage(h||o,vr.config.defaultDateFormat,await vr.git.getRemotes(o.repoPath),r,t.line);return new A.Hover(c,n)}async provideChangesHover(e,t,i){if(!vr.lineTracker.includes(t.line))return;const s=vr.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;if(vr.config.hovers.annotations.changes&&void 0!==await vr.fileAnnotations.getAnnotationType(A.window.activeTextEditor))return;const r=!this.debugging&&"line"===vr.config.hovers.currentLine.over;if(!r&&vr.lineAnnotations.suspended)return;const a=e.validateRange(new A.Range(t.line,r?0:M,t.line,M));if(!r&&a.start.character!==t.character)return;const n=await vr.tracker.get(e);if(void 0===n)return;const h=await Mo.changesHover(o,t.line,n.uri);return void 0!==h.hoverMessage?new A.Hover(h.hoverMessage,a):void 0}register(e){if(this.unregister(),void 0===e)return;const t=vr.config.hovers;if(!t.enabled||!t.currentLine.enabled||!t.currentLine.details&&!t.currentLine.changes)return;const i=[];t.currentLine.changes&&i.push(A.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.currentLine.details&&i.push(A.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=A.Disposable.from(...i)}unregister(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}}class ir extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new A.EventEmitter,this._onDidChangeTreeData=new A.EventEmitter,vr.explorerCommands,A.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),A.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),A.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(_.Auto),this),A.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(_.List),this),A.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(_.Tree),this),A.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(vr.config.gitExplorer.autoRefresh,!0),this),A.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(vr.config.gitExplorer.autoRefresh,!1),this),A.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>ir.setRenameFollowing(!0),this),A.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>ir.setRenameFollowing(!1),this),A.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(P.History),this),A.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(P.Repository),this),A.commands.registerCommand("gitlens.gitExplorer.undockHistory",this.undockHistory,this),vr.context.subscriptions.push(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this),A.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleEditorsChanged,500),this),br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=br.initializing(e);if(!(t||br.changed(e,br.name("gitExplorer").value)||br.changed(e,br.name("explorers").value)||br.changed(e,br.name("defaultGravatarsStyle").value)||br.changed(e,br.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||br.changed(e,br.name("gitExplorer")("enabled").value))&&Y(j.GitExplorer,this.config.enabled),(t||br.changed(e,br.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(vr.config.gitExplorer.autoRefresh);let i=this.view;if((t||br.changed(e,br.name("gitExplorer")("view").value))&&((i=this.config.view)===P.Auto&&(i=vr.context.workspaceState.get(ee.GitExplorerView,P.Repository)),t))return this.view=i,Y(j.GitExplorerView,this.view),this.setRoot(await this.getRootNode(A.window.activeTextEditor)),void(this._disposable=A.window.registerTreeDataProvider("gitlens.gitExplorer",this));this.reset(i,br.changed(e,br.name("advanced")("fileHistoryFollowsRenames").value))}async onActiveEditorChanged(e){if(this.view!==P.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Zt.ActiveEditorChanged,t)}onRepositoriesChanged(){this.view===P.Repository&&(this.clearRoot(),ke.log(`GitExplorer[view=${this.view}].onRepositoriesChanged`),this.refresh(Zt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this.view===P.History&&(0!==e.length&&e.some(e=>e.document&&vr.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Zt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&vr.context.workspaceState.get(ee.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},vr.config.explorers,vr.config.gitExplorer)}get view(){return this._view}set view(e){this._view=vr.config.historyExplorer.enabled?P.Repository:e}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this.view===P.History?[new li(`No active file ${K.Dash} no history to show`)]:[new li("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Zt.Command),ke.log(`GitExplorer[view=${this.view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this.view===P.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(A.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){ke.log(`GitExplorer[view=${this.view}].refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){this.setView(e),t&&void 0!==this._root&&this.clearRoot(),(this.setRoot(await this.getRootNode(A.window.activeTextEditor))||t)&&this.refresh(Zt.ViewChanged)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=vr.context.workspaceState.get(ee.GitExplorerAutoRefresh,!0):(i=t,await vr.context.workspaceState.update(ee.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=vr.git.onDidChangeRepositories(this.onRepositoriesChanged,this),vr.context.subscriptions.push(this._autoRefreshDisposable))),Y(j.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Zt.AutoRefreshChanged)}setView(e){this.view!==e&&(vr.config.gitExplorer.view===P.Auto&&vr.context.workspaceState.update(ee.GitExplorerView,e),this.view=e,Y(j.GitExplorerView,this.view),e!==P.Repository&&vr.git.stopWatchingFileSystem())}async switchTo(e){this.view!==e&&this.reset(e,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){switch(this.view){case P.History:{const t=this.getHistoryNode(e||A.window.activeTextEditor);return this._loading=t.then(e=>m.wait(0)),t}default:{const e=vr.git.getRepositories();this._loading=e.then(e=>m.wait(0));const t=[...await e];if(0===t.length)return;if(1===t.length){const e=t[0];return new Ri(Ie.fromRepoPath(e.path),e,this,!0)}return new Ii(t,this)}}}async getHistoryNode(e){return ir.getHistoryNode(this,e,this._root)}async setFilesLayout(e){return br.update(br.name("gitExplorer")("files")("layout").value,e,A.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}async undockHistory(e=!0){vr.historyExplorer.undock(e)}static async getHistoryNode(e,t,i){if(void 0===t||0===A.window.visibleTextEditors.length||!A.window.visibleTextEditors.some(e=>e.document&&vr.git.isTrackable(e.document.uri)))return;if(void 0===t.document||!vr.git.isTrackable(t.document.uri))return i;const s=await Ie.fromUri(t.document.uri),o=await vr.git.getRepository(s);return void 0!==o?re.equals(s,i&&i.uri)?i:new Oi(s,o,e):void 0}static setRenameFollowing(e){br.updateEffective(br.name("advanced")("fileHistoryFollowsRenames").value,e)}}class sr extends A.Disposable{constructor(){super(()=>this.dispose()),A.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),A.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),A.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),A.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),A.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),A.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),A.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),A.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),A.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),A.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),A.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),A.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),A.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),A.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),A.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),A.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),A.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),A.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),A.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),A.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),A.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),A.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),A.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),A.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),A.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),A.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),A.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),A.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),A.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),A.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),A.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await vr.git.checkoutFile(e.uri),this.openFile(e)}compareWithHead(e){e instanceof ci&&vr.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&vr.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof ci&&vr.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await vr.git.getBranch(e.repoPath);if(void 0===t)return;const i=await vr.git.getMergeBase(e.repoPath,t.name,e.ref);void 0!==i&&vr.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${ni.shortenSha(i)})`},"")}compareWithSelected(e){void 0!==this._selection&&e instanceof ci&&this._selection.repoPath===e.repoPath&&vr.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof ci))return;const t=e instanceof vi?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},Y(j.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,A.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return A.commands.executeCommand(ri.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Xi(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Xi(t.uri||("D"===e.commit.status?Ie.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Ie.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Ie.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:ni.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Ie.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>Ie.fromFileStatus(e,i));for(const e of s)await Xi(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=o.filterMap(e.commit.fileStatuses,t=>Ie.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Xi(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return A.commands.executeCommand(ri.DiffWith,o)}async openFileRevisionInRemote(e){return A.commands.executeCommand(ri.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){e instanceof vi&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof ci))return;let t=!1,i=void 0;e instanceof vi&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await A.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});void 0!==s&&""!==s&&this.sendTerminalCommand("branch",`${t?"-t ":""}${s} ${e.ref}`,e.repoPath)}terminalDeleteBranch(e){e instanceof vi&&(e.branch.remote?this.sendTerminalCommand("push",`${e.branch.remote} :${e.ref}`,e.repoPath):this.sendTerminalCommand("branch",`-d ${e.ref}`,e.repoPath))}terminalMergeBranch(e){e instanceof vi&&this.sendTerminalCommand("merge",`${e.ref}`,e.repoPath)}terminalRebaseBranch(e){e instanceof vi&&this.sendTerminalCommand("rebase",`-i ${e.ref}`,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof vi){if(!e.branch.current||!e.branch.tracking)return;this.sendTerminalCommand("rebase",`-i ${e.branch.tracking}`,e.repoPath)}else e instanceof $i&&this.sendTerminalCommand("rebase",`-i ${e.status.upstream}`,e.status.repoPath)}terminalSquashBranchIntoCommit(e){e instanceof vi&&this.sendTerminalCommand("merge",`--squash ${e.ref}`,e.repoPath)}terminalCherryPickCommit(e){e instanceof fi&&this.sendTerminalCommand("cherry-pick",`-e ${e.ref}`,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof fi))return;const t=e.branch||await vr.git.getBranch(e.repoPath);void 0!==t&&this.sendTerminalCommand("push",`${t.getRemote()} ${e.ref}:${t.getName()}`,e.repoPath)}terminalRebaseCommit(e){e instanceof fi&&this.sendTerminalCommand("rebase",`-i ${e.ref}^`,e.repoPath)}terminalResetCommit(e){e instanceof fi&&this.sendTerminalCommand("reset",`--soft ${e.ref}^`,e.repoPath)}terminalRevertCommit(e){e instanceof fi&&this.sendTerminalCommand("revert",`-e ${e.ref}`,e.repoPath)}terminalRemoveRemote(e){e instanceof Ci&&this.sendTerminalCommand("remote",`remove ${e.remote.name}`,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof ci))return;const t=await A.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await A.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand("tag",s,e.repoPath)}terminalDeleteTag(e){e instanceof Fi&&this.sendTerminalCommand("tag",`-d ${e.ref}`,e.repoPath)}ensureTerminal(e){return void 0===this._terminal&&(this._terminal=A.window.createTerminal(O),this._disposable=A.window.onDidCloseTerminal(e=>{e.name===O&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),vr.context.subscriptions.push(this._disposable),this._terminalCwd=void 0),this._terminalCwd!==e&&(this._terminal.sendText(`cd "${e}"`,!0),this._terminalCwd=e),this._terminal}sendTerminalCommand(e,t,i){const s=this.ensureTerminal(i);s.show(!1),s.sendText(`git ${e} ${t}`,!1)}}class or{async provideTextDocumentContent(e,t){const i=Ie.fromRevisionUri(e);if(!i.repoPath||i.sha===ni.deletedSha)return"";try{return await vr.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return ke.error(e,"GitContentProvider","getVersionedFileText"),void A.window.showErrorMessage(`Unable to show Git revision ${ni.shortenSha(i.sha)} of '${Ee.relative(i.repoPath,i.fsPath)}'`)}}}or.scheme=V.GitLensGit;class rr extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLines=new A.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||J(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.trigger("editor"))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!J(e.textEditor))return;const t=this._editor===e.textEditor?"selection":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.trigger(t))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return rr.includesAll(e,this._lines)}refresh(){this.trigger("editor")}reset(){this._state.clear()}start(e,t){void 0===this._disposable&&(this._disposable=A.Disposable.from(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,0),this),A.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(A.window.activeTextEditor)))}stop(e){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}async fireLinesChanged(e){this._onDidChangeActiveLines.fire(e)}trigger(e){this.onLinesChanged({editor:this._editor,lines:this._lines,reason:e})}onLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=m.debounce(e=>{A.window.activeTextEditor===e.editor&&rr.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this.fireLinesChanged(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this.fireLinesChanged(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{A.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this.fireLinesChanged(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&t.length===e.length&&t.every((t,i)=>t===e[i])}}class ar{constructor(e,t){this.commit=e,this.logCommit=t}}class nr extends rr{constructor(){super(...arguments),this._count=0,this._subscriptions=new Map,this._suspended=!1}async fireLinesChanged(e){this.reset();let t=!1;this._suspended||e.pending||void 0===e.lines||void 0===e.editor||(t=await this.updateState(e.lines,e.editor)),super.fireLinesChanged(t?e:Object.assign({},e,{lines:void 0}))}onBlameStateChanged(e){this.trigger("editor")}onDirtyIdleTriggered(e){const t=vr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||this.resume()}async onDirtyStateChanged(e){e.dirty?this.suspend():this.resume({force:!0})}async resume(e={}){(e.force||this._suspended)&&(this._suspended=!1,this.trigger("editor"))}async suspend(e={}){!e.force&&this._suspended||(this._suspended=!0,this.trigger("editor"))}start(e,t){this._subscriptions.has(e)||(this._subscriptions.set(e,t),this._count++,1===this._count&&(super.start(),this._disposable=A.Disposable.from(this._disposable,vr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),vr.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),vr.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))))}stop(e){const t=this._subscriptions.get(e);void 0!==t&&(this._subscriptions.delete(e),t.dispose(),void 0!==this._disposable?(this._count--,0===this._count&&super.stop()):this._count=0)}async updateState(e,t){const i=await vr.tracker.getOrAdd(t.document);if(!i.isBlameable||!this.includesAll(e))return!1;if(1===e.length){const s=t.document.isDirty?await vr.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await vr.git.getBlameForLine(i.uri,e[0]);if(void 0===s)return!1;this.setState(s.line.line,new ar(s.commit))}else{const s=t.document.isDirty?await vr.git.getBlameForFileContents(i.uri,t.document.getText()):await vr.git.getBlameForFile(i.uri);if(void 0===s)return!1;for(const t of e){const e=s.lines[t];this.setState(t,new ar(s.commits.get(e.sha)))}}return!(!i.isBlameable||!this.includesAll(e)||(t.document.isDirty&&i.setForceDirtyStateChangeOnNextDocumentChange(),0))}}class hr extends A.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class cr extends A.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class lr{async provideCodeLenses(e,t){const i=Ie.fromRevisionUri(e.uri),s=[],o=await vr.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new cr(o.previousUri.fsPath,o,new A.Range(0,0,0,1))),s.push(new hr(o.uri.fsPath,o,new A.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof hr?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof cr?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:ri.DiffWithWorking,arguments:[A.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:ri.DiffWithPrevious,arguments:[A.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}lr.selector={scheme:V.GitLensGit};class dr extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeTreeData=new A.EventEmitter,vr.explorerCommands,A.commands.registerCommand("gitlens.historyExplorer.refresh",this.refresh,this),A.commands.registerCommand("gitlens.historyExplorer.refreshNode",this.refreshNode,this),A.commands.registerCommand("gitlens.historyExplorer.close",()=>this.dock(!1),this),A.commands.registerCommand("gitlens.historyExplorer.dock",this.dock,this),A.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOn",()=>ir.setRenameFollowing(!0),this),A.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOff",()=>ir.setRenameFollowing(!1),this),vr.context.subscriptions.push(A.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this),A.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleEditorsChanged,500),this),br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=br.initializing(e);(t||br.changed(e,br.name("historyExplorer").value)||br.changed(e,br.name("explorers").value)||br.changed(e,br.name("defaultGravatarsStyle").value)||br.changed(e,br.name("advanced")("fileHistoryFollowsRenames").value))&&((t||br.changed(e,br.name("historyExplorer")("enabled").value))&&(vr.config.historyExplorer.enabled?this.undock(!t):this.dock(!t)),t||void 0!==this._root||this.refresh(Zt.ConfigurationChanged),t&&(this.setRoot(await this.getRootNode(A.window.activeTextEditor)),this._disposable=A.window.registerTreeDataProvider("gitlens.historyExplorer",this)))}async onActiveEditorChanged(e){const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Zt.ActiveEditorChanged,t)}onVisibleEditorsChanged(e){void 0!==this._root&&(0!==e.length&&e.some(e=>e.document&&vr.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Zt.VisibleEditorsChanged)))}get config(){return Object.assign({},vr.config.explorers)}async getChildren(e){return void 0===this._root?[new li(`No active file ${K.Dash} no history to show`)]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async dock(e=!0){e&&await vr.gitExplorer.switchTo(P.History),Y(j.HistoryExplorer,!1),br.updateEffective(br.name("historyExplorer")("enabled").value,!1)}getQualifiedCommand(e){return`gitlens.historyExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Zt.Command),ke.log("HistoryExplorer.refresh",`reason='${e}'`),void 0!==this._root&&void 0!==t||(this.clearRoot(),this.setRoot(await this.getRootNode(A.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){ke.log(`HistoryExplorer.refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._root===e?void 0:e)}async undock(e=!0){e&&await vr.gitExplorer.switchTo(P.Repository),Y(j.HistoryExplorer,!0),br.updateEffective(br.name("historyExplorer")("enabled").value,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){return ir.getHistoryNode(this,e,this._root)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}}const mr=A.Uri.parse("gitlens://authority/settings"),ur=A.Uri.parse("gitlens://authority/welcome");class gr extends A.Disposable{constructor(){super(()=>this.dispose()),this._onDidChange=new A.EventEmitter,this._scope=new Map,this._disposable=A.Disposable.from(A.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),A.workspace.registerTextDocumentContentProvider(mr.scheme,this),A.commands.registerCommand("gitlens.showSettingsPage",this.showSettings,this),A.commands.registerCommand("gitlens.showWelcomePage",this.showWelcome,this),A.commands.registerCommand("gitlens.saveSettings",this.save,this))}get onDidChange(){return this._onDidChange.event}dispose(){this._disposable.dispose()}onTextDocumentClosed(e){this._scope.delete(e.uri.toString())}async provideTextDocumentContent(e){let t=(await A.workspace.openTextDocument(A.Uri.file(vr.context.asAbsolutePath(`${e.path}.html`)))).getText().replace(/{{root}}/g,A.Uri.file(vr.context.asAbsolutePath(".")).toString());return t.includes("'{{data}}'")&&(t=t.replace(/'{{data}}'/g,JSON.stringify({config:vr.config,scope:this.getScope(e),scopes:this.getAvailableScopes(),uri:e.toString()}))),t}getAvailableScopes(){const e=[["user","User Settings"]];return void 0!==A.workspace.workspaceFolders&&A.workspace.workspaceFolders.length&&e.push(["workspace","Workspace Settings"]),e}getScope(e){return this._scope.get(e.toString())||"user"}refresh(e){ke.log("PageProvider.refresh"),this._onDidChange.fire(e||mr)}async save(e){ke.log(`PageProvider.save: options=${JSON.stringify(e)}`),this._scope.set(e.uri,e.scope);const t="workspace"===e.scope?A.ConfigurationTarget.Workspace:A.ConfigurationTarget.Global;for(const i in e.changes)(await br.inspect(i)).defaultValue===e.changes[i]?await br.update(i,void 0,t):await br.update(i,e.changes[i],t)}async showSettings(){return await A.commands.executeCommand("vscode.previewHtml",mr,A.ViewColumn.Active,"GitLens Settings")}async showWelcome(){return await A.commands.executeCommand("vscode.previewHtml",ur,A.ViewColumn.Active,"Welcome to GitLens")}}class pr extends A.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new A.EventEmitter,vr.explorerCommands,A.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),A.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),A.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(_.Auto),this),A.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(_.List),this),A.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(_.Tree),this),A.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),A.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),A.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),A.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),A.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),Y(j.ResultsExplorerKeepResults,this.keepResults),vr.context.subscriptions.push(br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=br.initializing(e);(t||br.changed(e,br.name("resultsExplorer").value)||br.changed(e,br.name("explorers").value)||br.changed(e,br.name("defaultGravatarsStyle").value))&&(t||0===this._roots.length||this.refresh(Zt.ConfigurationChanged),t&&(this._disposable=A.window.registerTreeDataProvider("gitlens.resultsExplorer",this)))}get config(){return Object.assign({},vr.config.explorers,vr.config.resultsExplorer)}get keepResults(){return vr.context.workspaceState.get(ee.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),Y(j.ResultsExplorer,!1)}async getChildren(e){return 0===this._roots.length?[new li("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Zt.Command),ke.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){ke.log(`ResultsExplorer.refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){ke.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}showComparisonInResults(e,t,i){this.addResults(new Ui(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)),this.showResults()}showCommitInResults(e){this.addResults(new Ei(e,this)),this.showResults()}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.addResults(new Bi(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,r=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let a="";if(await vr.git.getRepositoryCount()>1){const t=await vr.git.getRepository(e.repoPath);a=` ${w.pad(K.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${r.singular} for ${t.label}${a}`:`${0===s?"No":`${s}${o?"+":""}`} ${r.plural} for ${t.label}${a}`},m.seeded(i,e),this,ti.SearchResults)),this.showResults()}async showResults(){await A.commands.executeCommand("workbench.view.explorer"),is.showResultExplorerInfoMessage(),Y(j.ResultsExplorer,!0)}addResults(e){return!this._roots.includes(e)&&(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),!0)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return br.update(br.name("resultsExplorer")("files")("layout").value,e,A.ConfigurationTarget.Global)}setKeepResults(e){vr.context.workspaceState.update(ee.ResultsExplorerKeepResults,e),Y(j.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof Ui&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class fr extends A.Disposable{constructor(){super(()=>this.dispose()),this._disposable=A.Disposable.from(br.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(br.initializingChangeEvent)}dispose(){this.clear(),this._statusBarItem&&this._statusBarItem.dispose(),vr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=br.initializing(e);if(!t&&!br.changed(e,br.name("statusBar").value))return;const i=br.get();if(i.statusBar.enabled){const s="left"!==i.statusBar.alignment?A.StatusBarAlignment.Right:A.StatusBarAlignment.Left;br.changed(e,br.name("statusBar")("alignment").value)&&void 0!==this._statusBarItem&&this._statusBarItem.alignment!==s&&(this._statusBarItem.dispose(),this._statusBarItem=void 0),this._statusBarItem=this._statusBarItem||A.window.createStatusBarItem(s,s===A.StatusBarAlignment.Right?1e3:0),this._statusBarItem.command=i.statusBar.command,(t||br.changed(e,br.name("statusBar")("enabled").value))&&vr.lineTracker.start(this,A.Disposable.from(vr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))}else br.changed(e,br.name("statusBar")("enabled").value)&&(vr.lineTracker.stop(this),void 0!==this._statusBarItem&&(this._statusBarItem.dispose(),this._statusBarItem=void 0))}onActiveLinesChanged(e){let t=!(vr.config.statusBar.reduceFlicker&&"selection"===e.reason&&(e.pending||void 0!==e.lines));if(!e.pending&&void 0!==e.lines){const i=vr.lineTracker.getState(e.lines[0]);if(void 0!==i&&void 0!==i.commit)return void this.updateStatusBar(i.commit,e.editor);t=!0}t&&this.clear()}async clear(){void 0!==this._statusBarItem&&this._statusBarItem.hide()}updateStatusBar(e,t){const i=vr.config.statusBar;if(i.enabled&&void 0!==this._statusBarItem&&J(t)){switch(this._statusBarItem.text=`$(git-commit) ${qt.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?vr.config.defaultDateFormat:i.dateFormat})}`,i.command){case N.ToggleFileBlame:this._statusBarItem.tooltip="Toggle Blame Annotations";break;case N.DiffWithPrevious:this._statusBarItem.command=ri.DiffLineWithPrevious,this._statusBarItem.tooltip="Compare Line Revision with Previous";break;case N.DiffWithWorking:this._statusBarItem.command=ri.DiffLineWithWorking,this._statusBarItem.tooltip="Compare Line Revision with Working";break;case N.ToggleCodeLens:this._statusBarItem.tooltip="Toggle Git CodeLens";break;case N.ShowQuickCommitDetails:this._statusBarItem.tooltip="Show Commit Details";break;case N.ShowQuickCommitFileDetails:this._statusBarItem.tooltip="Show Line Commit Details";break;case N.ShowQuickFileHistory:this._statusBarItem.tooltip="Show File History";break;case N.ShowQuickCurrentBranchHistory:this._statusBarItem.tooltip="Show Branch History"}this._statusBarItem.show()}}}class vr{static initialize(e,t){if(this._context=e,this._config=t,e.subscriptions.push(this._lineTracker=new nr),e.subscriptions.push(this._tracker=new Kt),e.subscriptions.push(this._git=new ni),this._tracker.initialize(),e.subscriptions.push(this._fileAnnotationController=new zo),e.subscriptions.push(this._lineAnnotationController=new er),e.subscriptions.push(this._lineHoverController=new tr),e.subscriptions.push(this._statusBarController=new fr),e.subscriptions.push(this._codeLensController=new Jo),e.subscriptions.push(this._keyboard=new xs),e.subscriptions.push(this._pageProvider=new gr),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new ir);else{let t;t=br.onDidChange(i=>{br.changed(i,br.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new ir))})}if(t.historyExplorer.enabled)e.subscriptions.push(this._historyExplorer=new dr);else{let t;t=br.onDidChange(i=>{br.changed(i,br.name("historyExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._historyExplorer=new dr))})}e.subscriptions.push(A.workspace.registerTextDocumentContentProvider(or.scheme,new or)),e.subscriptions.push(A.languages.registerCodeLensProvider(lr.selector,new lr))}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=br.get()),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new sr),this._explorerCommands}static get fileAnnotations(){return this._fileAnnotationController}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get historyExplorer(){return void 0===this._historyExplorer&&this._context.subscriptions.push(this._historyExplorer=new dr),this._historyExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._lineAnnotationController}static get lineHovers(){return this._lineHoverController}static get lineTracker(){return this._lineTracker}static get pages(){return this._pageProvider}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new pr),this._resultsExplorer}static get statusBar(){return this._statusBarController}static get tracker(){return this._tracker}static resetConfig(){this._config=void 0}}const wr=new Proxy({},{get:(e,t,i)=>wr});class Cr{constructor(){this._onDidChange=new A.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1}}static configure(e){e.subscriptions.push(A.workspace.onDidChangeConfiguration(br.onConfigurationChanged,br))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(U,null))return;vr.resetConfig(),void 0!==vr.pages&&vr.pages.refresh(),br.changed(e,br.name("defaultGravatarsStyle").value)&&Me.clear();const t=br.name("keymap").value;br.changed(e,t)&&Y(j.KeyMap,this.get(t)),this._onDidChange.fire(e)}get(e,t,i){return void 0===i?A.workspace.getConfiguration(void 0===e?void 0:U,t).get(void 0===e?U:e):A.workspace.getConfiguration(void 0===e?void 0:U,t).get(void 0===e?U:e,i)}changed(e,t,i){return e.affectsConfiguration(`${U}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return A.workspace.getConfiguration(void 0===e?void 0:U,t).inspect(void 0===e?U:e)}async migrate(e,t,i={}){const s=br.inspect(e);if(void 0===s)return!1;let o=!1;return void 0!==s.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,A.ConfigurationTarget.Global),o=!0),void 0!==s.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,A.ConfigurationTarget.Workspace),o=!0),void 0!==s.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,A.ConfigurationTarget.WorkspaceFolder),o=!0),o||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,A.ConfigurationTarget.Global),o=!0),o}async migrateIfMissing(e,t,i={}){const s=br.inspect(e);if(void 0===s)return;const o=br.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,A.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,A.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,A.ConfigurationTarget.WorkspaceFolder))}name(e){return m.propOf(wr,e)}update(e,t,i,s){return A.workspace.getConfiguration(U,i===A.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await br.inspect(e,i);if(void 0!==s.workspaceFolderValue){if(s.workspaceFolderValue===t)return;await br.update(e,t,A.ConfigurationTarget.WorkspaceFolder,i)}else if(void 0!==s.workspaceValue){if(s.workspaceValue===t)return;await br.update(e,t,A.ConfigurationTarget.Workspace)}else{if(s.globalValue===t)return;await br.update(e,t,A.ConfigurationTarget.Global)}}}const br=new Cr;async function yr(e){const t=process.hrtime();ke.configure(e);const i=A.extensions.getExtension(I).packageJSON.version,s=A.workspace.getConfiguration("git",null).get("enabled",!0);if(!s)return ke.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),void Y(j.Enabled,s);Cr.configure(e);const o=e.globalState.get(q.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=C.fromString(t);try{if(1!==C.compare(i,C.from(7,5,10))&&(await br.migrate("annotations.file.gutter.gravatars",br.name("blame")("avatars").value),await br.migrate("annotations.file.gutter.compact",br.name("blame")("compact").value),await br.migrate("annotations.file.gutter.dateFormat",br.name("blame")("dateFormat").value),await br.migrate("annotations.file.gutter.format",br.name("blame")("format").value),await br.migrate("annotations.file.gutter.heatmap.enabled",br.name("blame")("heatmap")("enabled").value),await br.migrate("annotations.file.gutter.heatmap.location",br.name("blame")("heatmap")("location").value),await br.migrate("annotations.file.gutter.lineHighlight.enabled",br.name("blame")("highlight")("enabled").value),await br.migrate("annotations.file.gutter.lineHighlight.locations",br.name("blame")("highlight")("locations").value),await br.migrate("annotations.file.gutter.separateLines",br.name("blame")("separateLines").value),await br.migrate("codeLens.locations",br.name("codeLens")("scopes").value),await br.migrate("codeLens.perLanguageLocations",br.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await br.migrate("codeLens.customLocationSymbols",br.name("codeLens")("symbolScopes").value),await br.migrate("annotations.line.trailing.dateFormat",br.name("currentLine")("dateFormat").value),await br.migrate("blame.line.enabled",br.name("currentLine")("enabled").value),await br.migrate("annotations.line.trailing.format",br.name("currentLine")("format").value),await br.migrate("annotations.file.gutter.hover.changes",br.name("hovers")("annotations")("changes").value),await br.migrate("annotations.file.gutter.hover.details",br.name("hovers")("annotations")("details").value),await br.migrate("annotations.file.gutter.hover.details",br.name("hovers")("annotations")("enabled").value),await br.migrate("annotations.file.gutter.hover.wholeLine",br.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await br.migrate("annotations.line.trailing.hover.changes",br.name("hovers")("currentLine")("changes").value),await br.migrate("annotations.line.trailing.hover.details",br.name("hovers")("currentLine")("details").value),await br.migrate("blame.line.enabled",br.name("hovers")("currentLine")("enabled").value),await br.migrate("annotations.line.trailing.hover.wholeLine",br.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await br.migrate("gitExplorer.gravatars",br.name("explorers")("avatars").value),await br.migrate("gitExplorer.commitFileFormat",br.name("explorers")("commitFileFormat").value),await br.migrate("gitExplorer.commitFormat",br.name("explorers")("commitFormat").value),await br.migrate("gitExplorer.stashFileFormat",br.name("explorers")("stashFileFormat").value),await br.migrate("gitExplorer.stashFormat",br.name("explorers")("stashFormat").value),await br.migrate("gitExplorer.statusFileFormat",br.name("explorers")("statusFileFormat").value),await br.migrate("recentChanges.file.lineHighlight.locations",br.name("recentChanges")("highlight")("locations").value)),1!==C.compare(i,C.from(8,0,0,"beta2"))&&(await br.migrate("debug",br.name("outputLevel").value,{migrationFn:e=>e?B.Debug:br.get(br.name("outputLevel").value)}),await br.migrate("debug",br.name("debug").value,{migrationFn:e=>void 0})),1!==C.compare(i,C.from(8,0,0,"rc"))){let e=br.name("blame")("highlight")("locations").value;await br.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=br.name("recentChanges")("highlight")("locations").value,await br.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==C.compare(i,C.from(8,0,0))&&(await br.migrateIfMissing("annotations.file.gutter.gravatars",br.name("blame")("avatars").value),await br.migrateIfMissing("annotations.file.gutter.compact",br.name("blame")("compact").value),await br.migrateIfMissing("annotations.file.gutter.dateFormat",br.name("blame")("dateFormat").value),await br.migrateIfMissing("annotations.file.gutter.format",br.name("blame")("format").value),await br.migrateIfMissing("annotations.file.gutter.heatmap.enabled",br.name("blame")("heatmap")("enabled").value),await br.migrateIfMissing("annotations.file.gutter.heatmap.location",br.name("blame")("heatmap")("location").value),await br.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",br.name("blame")("highlight")("enabled").value),await br.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",br.name("blame")("highlight")("locations").value),await br.migrateIfMissing("annotations.file.gutter.separateLines",br.name("blame")("separateLines").value),await br.migrateIfMissing("codeLens.locations",br.name("codeLens")("scopes").value),await br.migrateIfMissing("codeLens.perLanguageLocations",br.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await br.migrateIfMissing("codeLens.customLocationSymbols",br.name("codeLens")("symbolScopes").value),await br.migrateIfMissing("annotations.line.trailing.dateFormat",br.name("currentLine")("dateFormat").value),await br.migrateIfMissing("blame.line.enabled",br.name("currentLine")("enabled").value),await br.migrateIfMissing("annotations.line.trailing.format",br.name("currentLine")("format").value),await br.migrateIfMissing("annotations.file.gutter.hover.changes",br.name("hovers")("annotations")("changes").value),await br.migrateIfMissing("annotations.file.gutter.hover.details",br.name("hovers")("annotations")("details").value),await br.migrateIfMissing("annotations.file.gutter.hover.details",br.name("hovers")("annotations")("enabled").value),await br.migrateIfMissing("annotations.file.gutter.hover.wholeLine",br.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await br.migrateIfMissing("annotations.line.trailing.hover.changes",br.name("hovers")("currentLine")("changes").value),await br.migrateIfMissing("annotations.line.trailing.hover.details",br.name("hovers")("currentLine")("details").value),await br.migrateIfMissing("blame.line.enabled",br.name("hovers")("currentLine")("enabled").value),await br.migrateIfMissing("annotations.line.trailing.hover.wholeLine",br.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await br.migrateIfMissing("gitExplorer.gravatars",br.name("explorers")("avatars").value),await br.migrateIfMissing("gitExplorer.commitFileFormat",br.name("explorers")("commitFileFormat").value),await br.migrateIfMissing("gitExplorer.commitFormat",br.name("explorers")("commitFormat").value),await br.migrateIfMissing("gitExplorer.stashFileFormat",br.name("explorers")("stashFileFormat").value),await br.migrateIfMissing("gitExplorer.stashFormat",br.name("explorers")("stashFormat").value),await br.migrateIfMissing("gitExplorer.statusFileFormat",br.name("explorers")("statusFileFormat").value),await br.migrateIfMissing("recentChanges.file.lineHighlight.locations",br.name("recentChanges")("highlight")("locations").value)),1!==C.compare(i,C.from(8,0,2))){const e=br.name("keymap").value;await br.migrate(e,e,{fallbackValue:E.Alternate,migrationFn:e=>"standard"===e?E.Alternate:e})}}catch(e){ke.error(e,"migrateSettings")}}(0,o);const r=br.get();try{await ni.initialize(r.advanced.git||A.workspace.getConfiguration("git").get("path"))}catch(e){return ke.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await A.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${U}.${br.name("advanced")("git").value}' is pointed to its installed location.`),void Y(j.Enabled,!1)}vr.initialize(e,r),Y(j.KeyMap,vr.config.keymap),vr.context.subscriptions.push(new ss),vr.context.subscriptions.push(new co),vr.context.subscriptions.push(new ho),vr.context.subscriptions.push(new os),vr.context.subscriptions.push(new rs),vr.context.subscriptions.push(new Ks),vr.context.subscriptions.push(new zs),vr.context.subscriptions.push(new qs),vr.context.subscriptions.push(new Ys),vr.context.subscriptions.push(new Xs),vr.context.subscriptions.push(new Js),vr.context.subscriptions.push(new Zs),vr.context.subscriptions.push(new eo),vr.context.subscriptions.push(new to),vr.context.subscriptions.push(new io),vr.context.subscriptions.push(new lo),vr.context.subscriptions.push(new mo),vr.context.subscriptions.push(new uo),vr.context.subscriptions.push(new go),vr.context.subscriptions.push(new po),vr.context.subscriptions.push(new fo),vr.context.subscriptions.push(new vo),vr.context.subscriptions.push(new wo),vr.context.subscriptions.push(new Ji),vr.context.subscriptions.push(new Ao),vr.context.subscriptions.push(new Uo),vr.context.subscriptions.push(new Lo),vr.context.subscriptions.push(new Oo),vr.context.subscriptions.push(new Co),vr.context.subscriptions.push(new $o),vr.context.subscriptions.push(new So),vr.context.subscriptions.push(new _o),vr.context.subscriptions.push(new Do),vr.context.subscriptions.push(new ko),vr.context.subscriptions.push(new xo),vr.context.subscriptions.push(new Fo),vr.context.subscriptions.push(new Po),vr.context.subscriptions.push(new Ro),vr.context.subscriptions.push(new To),vr.context.subscriptions.push(new Eo),vr.context.subscriptions.push(new Bo),vr.context.subscriptions.push(new No),function(e){ni.validateGitVersion(2,2)||is.showUnsupportedGitVersionErrorMessage(e)}(ni.getGitVersion()),async function(e,t){if(void 0===t)return ke.log("GitLens first-time install"),void(vr.config.showWhatsNewAfterUpgrades&&await A.commands.executeCommand(ri.ShowWelcomePage));if(t!==e&&(ke.log(`GitLens upgraded from v${t} to v${e}`),0===C.compare(C.fromString(t),C.from(8,0,0))))return void await A.commands.executeCommand(ri.ShowWelcomePage);if(!vr.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,r]=t.split(".");i===o&&s===r||i<o||i===o&&s<r||await A.commands.executeCommand(ri.ShowWelcomePage)}(i,o),is.showKeyBindingsInfoMessage(),e.globalState.update(q.GitLensVersion,i);const a=process.hrtime(t);ke.log(`GitLens(v${i}) activated in ${1e3*a[0]+Math.floor(a[1]/1e6)} ms`)}function xr(){}i.d(t,"activate",function(){return yr}),i.d(t,"deactivate",function(){return xr})},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("copy-paste")},function(e,t){e.exports=require("tmp")}]);